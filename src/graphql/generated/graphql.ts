export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Date: { input: any; output: any; }
  DateTime: { input: any; output: any; }
};

export type AiResponse = {
  __typename?: 'AiResponse';
  choices?: Maybe<Array<Scalars['String']['output']>>;
  hint?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  placeholder?: Maybe<Scalars['String']['output']>;
  type: AiResponseType;
};

export type AiResponseAggregateSelection = {
  __typename?: 'AiResponseAggregateSelection';
  count: Scalars['Int']['output'];
  hint: StringAggregateSelection;
  name: StringAggregateSelection;
  placeholder: StringAggregateSelection;
};

export type AiResponseCreateInput = {
  choices?: InputMaybe<Array<Scalars['String']['input']>>;
  hint?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  placeholder?: InputMaybe<Scalars['String']['input']>;
  type: AiResponseType;
};

export type AiResponseEdge = {
  __typename?: 'AiResponseEdge';
  cursor: Scalars['String']['output'];
  node: AiResponse;
};

export type AiResponseOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more AiResponseSort objects to sort AiResponses by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<AiResponseSort>>;
};

/** Fields to sort AiResponses by. The order in which sorts are applied is not guaranteed when specifying many fields in one AiResponseSort object. */
export type AiResponseSort = {
  hint?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  placeholder?: InputMaybe<SortDirection>;
  type?: InputMaybe<SortDirection>;
};

export enum AiResponseType {
  Boolean = 'Boolean',
  Date = 'Date',
  Finished = 'Finished',
  MultipleChoices = 'MultipleChoices',
  SingleChoice = 'SingleChoice',
  Text = 'Text'
}

export type AiResponseUpdateInput = {
  choices?: InputMaybe<Array<Scalars['String']['input']>>;
  choices_POP?: InputMaybe<Scalars['Int']['input']>;
  choices_PUSH?: InputMaybe<Array<Scalars['String']['input']>>;
  hint?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<AiResponseType>;
};

export type AiResponseWhere = {
  AND?: InputMaybe<Array<AiResponseWhere>>;
  NOT?: InputMaybe<AiResponseWhere>;
  OR?: InputMaybe<Array<AiResponseWhere>>;
  choices?: InputMaybe<Array<Scalars['String']['input']>>;
  choices_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  hint_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  hint_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hint_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  placeholder_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  placeholder_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  placeholder_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  placeholder_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<AiResponseType>;
  type_IN?: InputMaybe<Array<AiResponseType>>;
};

export type AiResponsesConnection = {
  __typename?: 'AiResponsesConnection';
  edges: Array<AiResponseEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Alert = {
  __typename?: 'Alert';
  condition: ConditionGroup;
  conditionAggregate?: Maybe<AlertConditionGroupConditionAggregationSelection>;
  conditionConnection: AlertConditionConnection;
  message?: Maybe<Scalars['String']['output']>;
};


export type AlertConditionArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<ConditionGroupOptions>;
  where?: InputMaybe<ConditionGroupWhere>;
};


export type AlertConditionAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<ConditionGroupWhere>;
};


export type AlertConditionConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<AlertConditionConnectionSort>>;
  where?: InputMaybe<AlertConditionConnectionWhere>;
};

export type AlertAggregateSelection = {
  __typename?: 'AlertAggregateSelection';
  count: Scalars['Int']['output'];
  message: StringAggregateSelection;
};

export type AlertConditionAggregateInput = {
  AND?: InputMaybe<Array<AlertConditionAggregateInput>>;
  NOT?: InputMaybe<AlertConditionAggregateInput>;
  OR?: InputMaybe<Array<AlertConditionAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<AlertConditionNodeAggregationWhereInput>;
};

export type AlertConditionConnectFieldInput = {
  connect?: InputMaybe<ConditionGroupConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<ConditionGroupConnectWhere>;
};

export type AlertConditionConnection = {
  __typename?: 'AlertConditionConnection';
  edges: Array<AlertConditionRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type AlertConditionConnectionSort = {
  node?: InputMaybe<ConditionGroupSort>;
};

export type AlertConditionConnectionWhere = {
  AND?: InputMaybe<Array<AlertConditionConnectionWhere>>;
  NOT?: InputMaybe<AlertConditionConnectionWhere>;
  OR?: InputMaybe<Array<AlertConditionConnectionWhere>>;
  node?: InputMaybe<ConditionGroupWhere>;
};

export type AlertConditionCreateFieldInput = {
  node: ConditionGroupCreateInput;
};

export type AlertConditionDeleteFieldInput = {
  delete?: InputMaybe<ConditionGroupDeleteInput>;
  where?: InputMaybe<AlertConditionConnectionWhere>;
};

export type AlertConditionDisconnectFieldInput = {
  disconnect?: InputMaybe<ConditionGroupDisconnectInput>;
  where?: InputMaybe<AlertConditionConnectionWhere>;
};

export type AlertConditionFieldInput = {
  connect?: InputMaybe<AlertConditionConnectFieldInput>;
  create?: InputMaybe<AlertConditionCreateFieldInput>;
};

export type AlertConditionGroupConditionAggregationSelection = {
  __typename?: 'AlertConditionGroupConditionAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<AlertConditionGroupConditionNodeAggregateSelection>;
};

export type AlertConditionGroupConditionNodeAggregateSelection = {
  __typename?: 'AlertConditionGroupConditionNodeAggregateSelection';
  label: StringAggregateSelection;
};

export type AlertConditionNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AlertConditionNodeAggregationWhereInput>>;
  NOT?: InputMaybe<AlertConditionNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<AlertConditionNodeAggregationWhereInput>>;
  label_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  label_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type AlertConditionRelationship = {
  __typename?: 'AlertConditionRelationship';
  cursor: Scalars['String']['output'];
  node: ConditionGroup;
};

export type AlertConditionUpdateConnectionInput = {
  node?: InputMaybe<ConditionGroupUpdateInput>;
};

export type AlertConditionUpdateFieldInput = {
  connect?: InputMaybe<AlertConditionConnectFieldInput>;
  create?: InputMaybe<AlertConditionCreateFieldInput>;
  delete?: InputMaybe<AlertConditionDeleteFieldInput>;
  disconnect?: InputMaybe<AlertConditionDisconnectFieldInput>;
  update?: InputMaybe<AlertConditionUpdateConnectionInput>;
  where?: InputMaybe<AlertConditionConnectionWhere>;
};

export type AlertConnectInput = {
  condition?: InputMaybe<AlertConditionConnectFieldInput>;
};

export type AlertConnectWhere = {
  node: AlertWhere;
};

export type AlertCreateInput = {
  condition?: InputMaybe<AlertConditionFieldInput>;
  message?: InputMaybe<Scalars['String']['input']>;
};

export type AlertDeleteInput = {
  condition?: InputMaybe<AlertConditionDeleteFieldInput>;
};

export type AlertDisconnectInput = {
  condition?: InputMaybe<AlertConditionDisconnectFieldInput>;
};

export type AlertEdge = {
  __typename?: 'AlertEdge';
  cursor: Scalars['String']['output'];
  node: Alert;
};

export type AlertGroup = {
  __typename?: 'AlertGroup';
  severe?: Maybe<Alert>;
  severeAggregate?: Maybe<AlertGroupAlertSevereAggregationSelection>;
  severeConnection: AlertGroupSevereConnection;
  warning?: Maybe<Alert>;
  warningAggregate?: Maybe<AlertGroupAlertWarningAggregationSelection>;
  warningConnection: AlertGroupWarningConnection;
};


export type AlertGroupSevereArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AlertOptions>;
  where?: InputMaybe<AlertWhere>;
};


export type AlertGroupSevereAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AlertWhere>;
};


export type AlertGroupSevereConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<AlertGroupSevereConnectionSort>>;
  where?: InputMaybe<AlertGroupSevereConnectionWhere>;
};


export type AlertGroupWarningArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AlertOptions>;
  where?: InputMaybe<AlertWhere>;
};


export type AlertGroupWarningAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AlertWhere>;
};


export type AlertGroupWarningConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<AlertGroupWarningConnectionSort>>;
  where?: InputMaybe<AlertGroupWarningConnectionWhere>;
};

export type AlertGroupAggregateSelection = {
  __typename?: 'AlertGroupAggregateSelection';
  count: Scalars['Int']['output'];
};

export type AlertGroupAlertSevereAggregationSelection = {
  __typename?: 'AlertGroupAlertSevereAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<AlertGroupAlertSevereNodeAggregateSelection>;
};

export type AlertGroupAlertSevereNodeAggregateSelection = {
  __typename?: 'AlertGroupAlertSevereNodeAggregateSelection';
  message: StringAggregateSelection;
};

export type AlertGroupAlertWarningAggregationSelection = {
  __typename?: 'AlertGroupAlertWarningAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<AlertGroupAlertWarningNodeAggregateSelection>;
};

export type AlertGroupAlertWarningNodeAggregateSelection = {
  __typename?: 'AlertGroupAlertWarningNodeAggregateSelection';
  message: StringAggregateSelection;
};

export type AlertGroupConnectInput = {
  severe?: InputMaybe<AlertGroupSevereConnectFieldInput>;
  warning?: InputMaybe<AlertGroupWarningConnectFieldInput>;
};

export type AlertGroupConnectWhere = {
  node: AlertGroupWhere;
};

export type AlertGroupCreateInput = {
  severe?: InputMaybe<AlertGroupSevereFieldInput>;
  warning?: InputMaybe<AlertGroupWarningFieldInput>;
};

export type AlertGroupDeleteInput = {
  severe?: InputMaybe<AlertGroupSevereDeleteFieldInput>;
  warning?: InputMaybe<AlertGroupWarningDeleteFieldInput>;
};

export type AlertGroupDisconnectInput = {
  severe?: InputMaybe<AlertGroupSevereDisconnectFieldInput>;
  warning?: InputMaybe<AlertGroupWarningDisconnectFieldInput>;
};

export type AlertGroupEdge = {
  __typename?: 'AlertGroupEdge';
  cursor: Scalars['String']['output'];
  node: AlertGroup;
};

export type AlertGroupInput = {
  severe?: InputMaybe<AlertInput>;
  warning?: InputMaybe<AlertInput>;
};

export type AlertGroupOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type AlertGroupRelationInput = {
  severe?: InputMaybe<AlertGroupSevereCreateFieldInput>;
  warning?: InputMaybe<AlertGroupWarningCreateFieldInput>;
};

export type AlertGroupSevereAggregateInput = {
  AND?: InputMaybe<Array<AlertGroupSevereAggregateInput>>;
  NOT?: InputMaybe<AlertGroupSevereAggregateInput>;
  OR?: InputMaybe<Array<AlertGroupSevereAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<AlertGroupSevereNodeAggregationWhereInput>;
};

export type AlertGroupSevereConnectFieldInput = {
  connect?: InputMaybe<AlertConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AlertConnectWhere>;
};

export type AlertGroupSevereConnection = {
  __typename?: 'AlertGroupSevereConnection';
  edges: Array<AlertGroupSevereRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type AlertGroupSevereConnectionSort = {
  node?: InputMaybe<AlertSort>;
};

export type AlertGroupSevereConnectionWhere = {
  AND?: InputMaybe<Array<AlertGroupSevereConnectionWhere>>;
  NOT?: InputMaybe<AlertGroupSevereConnectionWhere>;
  OR?: InputMaybe<Array<AlertGroupSevereConnectionWhere>>;
  node?: InputMaybe<AlertWhere>;
};

export type AlertGroupSevereCreateFieldInput = {
  node: AlertCreateInput;
};

export type AlertGroupSevereDeleteFieldInput = {
  delete?: InputMaybe<AlertDeleteInput>;
  where?: InputMaybe<AlertGroupSevereConnectionWhere>;
};

export type AlertGroupSevereDisconnectFieldInput = {
  disconnect?: InputMaybe<AlertDisconnectInput>;
  where?: InputMaybe<AlertGroupSevereConnectionWhere>;
};

export type AlertGroupSevereFieldInput = {
  connect?: InputMaybe<AlertGroupSevereConnectFieldInput>;
  create?: InputMaybe<AlertGroupSevereCreateFieldInput>;
};

export type AlertGroupSevereNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AlertGroupSevereNodeAggregationWhereInput>>;
  NOT?: InputMaybe<AlertGroupSevereNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<AlertGroupSevereNodeAggregationWhereInput>>;
  message_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  message_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  message_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  message_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  message_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  message_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  message_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  message_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  message_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  message_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  message_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  message_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  message_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  message_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  message_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type AlertGroupSevereRelationship = {
  __typename?: 'AlertGroupSevereRelationship';
  cursor: Scalars['String']['output'];
  node: Alert;
};

export type AlertGroupSevereUpdateConnectionInput = {
  node?: InputMaybe<AlertUpdateInput>;
};

export type AlertGroupSevereUpdateFieldInput = {
  connect?: InputMaybe<AlertGroupSevereConnectFieldInput>;
  create?: InputMaybe<AlertGroupSevereCreateFieldInput>;
  delete?: InputMaybe<AlertGroupSevereDeleteFieldInput>;
  disconnect?: InputMaybe<AlertGroupSevereDisconnectFieldInput>;
  update?: InputMaybe<AlertGroupSevereUpdateConnectionInput>;
  where?: InputMaybe<AlertGroupSevereConnectionWhere>;
};

export type AlertGroupUpdateInput = {
  severe?: InputMaybe<AlertGroupSevereUpdateFieldInput>;
  warning?: InputMaybe<AlertGroupWarningUpdateFieldInput>;
};

export type AlertGroupWarningAggregateInput = {
  AND?: InputMaybe<Array<AlertGroupWarningAggregateInput>>;
  NOT?: InputMaybe<AlertGroupWarningAggregateInput>;
  OR?: InputMaybe<Array<AlertGroupWarningAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<AlertGroupWarningNodeAggregationWhereInput>;
};

export type AlertGroupWarningConnectFieldInput = {
  connect?: InputMaybe<AlertConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AlertConnectWhere>;
};

export type AlertGroupWarningConnection = {
  __typename?: 'AlertGroupWarningConnection';
  edges: Array<AlertGroupWarningRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type AlertGroupWarningConnectionSort = {
  node?: InputMaybe<AlertSort>;
};

export type AlertGroupWarningConnectionWhere = {
  AND?: InputMaybe<Array<AlertGroupWarningConnectionWhere>>;
  NOT?: InputMaybe<AlertGroupWarningConnectionWhere>;
  OR?: InputMaybe<Array<AlertGroupWarningConnectionWhere>>;
  node?: InputMaybe<AlertWhere>;
};

export type AlertGroupWarningCreateFieldInput = {
  node: AlertCreateInput;
};

export type AlertGroupWarningDeleteFieldInput = {
  delete?: InputMaybe<AlertDeleteInput>;
  where?: InputMaybe<AlertGroupWarningConnectionWhere>;
};

export type AlertGroupWarningDisconnectFieldInput = {
  disconnect?: InputMaybe<AlertDisconnectInput>;
  where?: InputMaybe<AlertGroupWarningConnectionWhere>;
};

export type AlertGroupWarningFieldInput = {
  connect?: InputMaybe<AlertGroupWarningConnectFieldInput>;
  create?: InputMaybe<AlertGroupWarningCreateFieldInput>;
};

export type AlertGroupWarningNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AlertGroupWarningNodeAggregationWhereInput>>;
  NOT?: InputMaybe<AlertGroupWarningNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<AlertGroupWarningNodeAggregationWhereInput>>;
  message_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  message_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  message_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  message_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  message_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  message_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  message_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  message_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  message_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  message_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  message_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  message_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  message_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  message_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  message_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type AlertGroupWarningRelationship = {
  __typename?: 'AlertGroupWarningRelationship';
  cursor: Scalars['String']['output'];
  node: Alert;
};

export type AlertGroupWarningUpdateConnectionInput = {
  node?: InputMaybe<AlertUpdateInput>;
};

export type AlertGroupWarningUpdateFieldInput = {
  connect?: InputMaybe<AlertGroupWarningConnectFieldInput>;
  create?: InputMaybe<AlertGroupWarningCreateFieldInput>;
  delete?: InputMaybe<AlertGroupWarningDeleteFieldInput>;
  disconnect?: InputMaybe<AlertGroupWarningDisconnectFieldInput>;
  update?: InputMaybe<AlertGroupWarningUpdateConnectionInput>;
  where?: InputMaybe<AlertGroupWarningConnectionWhere>;
};

export type AlertGroupWhere = {
  AND?: InputMaybe<Array<AlertGroupWhere>>;
  NOT?: InputMaybe<AlertGroupWhere>;
  OR?: InputMaybe<Array<AlertGroupWhere>>;
  severe?: InputMaybe<AlertWhere>;
  severeAggregate?: InputMaybe<AlertGroupSevereAggregateInput>;
  severeConnection?: InputMaybe<AlertGroupSevereConnectionWhere>;
  severeConnection_NOT?: InputMaybe<AlertGroupSevereConnectionWhere>;
  severe_NOT?: InputMaybe<AlertWhere>;
  warning?: InputMaybe<AlertWhere>;
  warningAggregate?: InputMaybe<AlertGroupWarningAggregateInput>;
  warningConnection?: InputMaybe<AlertGroupWarningConnectionWhere>;
  warningConnection_NOT?: InputMaybe<AlertGroupWarningConnectionWhere>;
  warning_NOT?: InputMaybe<AlertWhere>;
};

export type AlertGroupsConnection = {
  __typename?: 'AlertGroupsConnection';
  edges: Array<AlertGroupEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type AlertInput = {
  condition: ConditionGroupInput;
  message?: InputMaybe<Scalars['String']['input']>;
};

export enum AlertLevel {
  None = 'None',
  Severe = 'Severe',
  Warning = 'Warning'
}

export type AlertOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more AlertSort objects to sort Alerts by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<AlertSort>>;
};

export type AlertRelationInput = {
  condition?: InputMaybe<AlertConditionCreateFieldInput>;
};

/** Fields to sort Alerts by. The order in which sorts are applied is not guaranteed when specifying many fields in one AlertSort object. */
export type AlertSort = {
  message?: InputMaybe<SortDirection>;
};

export type AlertUpdateInput = {
  condition?: InputMaybe<AlertConditionUpdateFieldInput>;
  message?: InputMaybe<Scalars['String']['input']>;
};

export type AlertWhere = {
  AND?: InputMaybe<Array<AlertWhere>>;
  NOT?: InputMaybe<AlertWhere>;
  OR?: InputMaybe<Array<AlertWhere>>;
  condition?: InputMaybe<ConditionGroupWhere>;
  conditionAggregate?: InputMaybe<AlertConditionAggregateInput>;
  conditionConnection?: InputMaybe<AlertConditionConnectionWhere>;
  conditionConnection_NOT?: InputMaybe<AlertConditionConnectionWhere>;
  condition_NOT?: InputMaybe<ConditionGroupWhere>;
  message?: InputMaybe<Scalars['String']['input']>;
  message_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  message_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  message_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  message_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type AlertsConnection = {
  __typename?: 'AlertsConnection';
  edges: Array<AlertEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Answer = {
  __typename?: 'Answer';
  alert?: Maybe<AlertLevel>;
  choices?: Maybe<Array<Scalars['String']['output']>>;
  createdAt: Scalars['DateTime']['output'];
  field?: Maybe<Scalars['String']['output']>;
  hint?: Maybe<Scalars['String']['output']>;
  interview: Interview;
  interviewAggregate?: Maybe<AnswerInterviewInterviewAggregationSelection>;
  interviewConnection: AnswerInterviewConnection;
  label?: Maybe<Scalars['String']['output']>;
  order: Scalars['Int']['output'];
  question: QuestionnaireStep;
  questionAggregate?: Maybe<AnswerQuestionnaireStepQuestionAggregationSelection>;
  questionConnection: AnswerQuestionConnection;
  type?: Maybe<AiResponseType>;
  values: Array<Scalars['String']['output']>;
};


export type AnswerInterviewArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<InterviewOptions>;
  where?: InputMaybe<InterviewWhere>;
};


export type AnswerInterviewAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<InterviewWhere>;
};


export type AnswerInterviewConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<AnswerInterviewConnectionSort>>;
  where?: InputMaybe<AnswerInterviewConnectionWhere>;
};


export type AnswerQuestionArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type AnswerQuestionAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type AnswerQuestionConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<AnswerQuestionConnectionSort>>;
  where?: InputMaybe<AnswerQuestionConnectionWhere>;
};

export type AnswerAggregateSelection = {
  __typename?: 'AnswerAggregateSelection';
  count: Scalars['Int']['output'];
  createdAt: DateTimeAggregateSelection;
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type AnswerConnectInput = {
  interview?: InputMaybe<AnswerInterviewConnectFieldInput>;
  question?: InputMaybe<AnswerQuestionConnectFieldInput>;
};

export type AnswerConnectOrCreateInput = {
  interview?: InputMaybe<AnswerInterviewConnectOrCreateFieldInput>;
};

export type AnswerConnectWhere = {
  node: AnswerWhere;
};

export type AnswerCreateInput = {
  alert?: InputMaybe<AlertLevel>;
  choices?: InputMaybe<Array<Scalars['String']['input']>>;
  field?: InputMaybe<Scalars['String']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  interview?: InputMaybe<AnswerInterviewFieldInput>;
  order: Scalars['Int']['input'];
  question?: InputMaybe<AnswerQuestionFieldInput>;
  type?: InputMaybe<AiResponseType>;
  values: Array<Scalars['String']['input']>;
};

export type AnswerDeleteInput = {
  interview?: InputMaybe<AnswerInterviewDeleteFieldInput>;
  question?: InputMaybe<AnswerQuestionDeleteFieldInput>;
};

export type AnswerDisconnectInput = {
  interview?: InputMaybe<AnswerInterviewDisconnectFieldInput>;
  question?: InputMaybe<AnswerQuestionDisconnectFieldInput>;
};

export type AnswerEdge = {
  __typename?: 'AnswerEdge';
  cursor: Scalars['String']['output'];
  node: Answer;
};

export type AnswerFiltersParams = {
  anonymous?: InputMaybe<Scalars['Boolean']['input']>;
  criteria: Array<ExportCriterion>;
  filters: Array<ExportFilterGroup>;
};

export type AnswerInterviewAggregateInput = {
  AND?: InputMaybe<Array<AnswerInterviewAggregateInput>>;
  NOT?: InputMaybe<AnswerInterviewAggregateInput>;
  OR?: InputMaybe<Array<AnswerInterviewAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<AnswerInterviewNodeAggregationWhereInput>;
};

export type AnswerInterviewConnectFieldInput = {
  connect?: InputMaybe<InterviewConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<InterviewConnectWhere>;
};

export type AnswerInterviewConnectOrCreateFieldInput = {
  onCreate: AnswerInterviewConnectOrCreateFieldInputOnCreate;
  where: InterviewConnectOrCreateWhere;
};

export type AnswerInterviewConnectOrCreateFieldInputOnCreate = {
  node: InterviewOnCreateInput;
};

export type AnswerInterviewConnection = {
  __typename?: 'AnswerInterviewConnection';
  edges: Array<AnswerInterviewRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type AnswerInterviewConnectionSort = {
  node?: InputMaybe<InterviewSort>;
};

export type AnswerInterviewConnectionWhere = {
  AND?: InputMaybe<Array<AnswerInterviewConnectionWhere>>;
  NOT?: InputMaybe<AnswerInterviewConnectionWhere>;
  OR?: InputMaybe<Array<AnswerInterviewConnectionWhere>>;
  node?: InputMaybe<InterviewWhere>;
};

export type AnswerInterviewCreateFieldInput = {
  node: InterviewCreateInput;
};

export type AnswerInterviewDeleteFieldInput = {
  delete?: InputMaybe<InterviewDeleteInput>;
  where?: InputMaybe<AnswerInterviewConnectionWhere>;
};

export type AnswerInterviewDisconnectFieldInput = {
  disconnect?: InputMaybe<InterviewDisconnectInput>;
  where?: InputMaybe<AnswerInterviewConnectionWhere>;
};

export type AnswerInterviewFieldInput = {
  connect?: InputMaybe<AnswerInterviewConnectFieldInput>;
  connectOrCreate?: InputMaybe<AnswerInterviewConnectOrCreateFieldInput>;
  create?: InputMaybe<AnswerInterviewCreateFieldInput>;
};

export type AnswerInterviewInterviewAggregationSelection = {
  __typename?: 'AnswerInterviewInterviewAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<AnswerInterviewInterviewNodeAggregateSelection>;
};

export type AnswerInterviewInterviewNodeAggregateSelection = {
  __typename?: 'AnswerInterviewInterviewNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
  id: IdAggregateSelection;
};

export type AnswerInterviewNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AnswerInterviewNodeAggregationWhereInput>>;
  NOT?: InputMaybe<AnswerInterviewNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<AnswerInterviewNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type AnswerInterviewRelationship = {
  __typename?: 'AnswerInterviewRelationship';
  cursor: Scalars['String']['output'];
  node: Interview;
};

export type AnswerInterviewUpdateConnectionInput = {
  node?: InputMaybe<InterviewUpdateInput>;
};

export type AnswerInterviewUpdateFieldInput = {
  connect?: InputMaybe<AnswerInterviewConnectFieldInput>;
  connectOrCreate?: InputMaybe<AnswerInterviewConnectOrCreateFieldInput>;
  create?: InputMaybe<AnswerInterviewCreateFieldInput>;
  delete?: InputMaybe<AnswerInterviewDeleteFieldInput>;
  disconnect?: InputMaybe<AnswerInterviewDisconnectFieldInput>;
  update?: InputMaybe<AnswerInterviewUpdateConnectionInput>;
  where?: InputMaybe<AnswerInterviewConnectionWhere>;
};

export type AnswerOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more AnswerSort objects to sort Answers by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<AnswerSort>>;
};

export type AnswerQuestionAggregateInput = {
  AND?: InputMaybe<Array<AnswerQuestionAggregateInput>>;
  NOT?: InputMaybe<AnswerQuestionAggregateInput>;
  OR?: InputMaybe<Array<AnswerQuestionAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<AnswerQuestionNodeAggregationWhereInput>;
};

export type AnswerQuestionConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type AnswerQuestionConnection = {
  __typename?: 'AnswerQuestionConnection';
  edges: Array<AnswerQuestionRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type AnswerQuestionConnectionSort = {
  node?: InputMaybe<QuestionnaireStepSort>;
};

export type AnswerQuestionConnectionWhere = {
  AND?: InputMaybe<Array<AnswerQuestionConnectionWhere>>;
  NOT?: InputMaybe<AnswerQuestionConnectionWhere>;
  OR?: InputMaybe<Array<AnswerQuestionConnectionWhere>>;
  node?: InputMaybe<QuestionnaireStepWhere>;
};

export type AnswerQuestionCreateFieldInput = {
  node: QuestionnaireStepCreateInput;
};

export type AnswerQuestionDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<AnswerQuestionConnectionWhere>;
};

export type AnswerQuestionDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<AnswerQuestionConnectionWhere>;
};

export type AnswerQuestionFieldInput = {
  connect?: InputMaybe<AnswerQuestionConnectFieldInput>;
  create?: InputMaybe<AnswerQuestionCreateFieldInput>;
};

export type AnswerQuestionNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AnswerQuestionNodeAggregationWhereInput>>;
  NOT?: InputMaybe<AnswerQuestionNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<AnswerQuestionNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type AnswerQuestionRelationship = {
  __typename?: 'AnswerQuestionRelationship';
  cursor: Scalars['String']['output'];
  node: QuestionnaireStep;
};

export type AnswerQuestionUpdateConnectionInput = {
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type AnswerQuestionUpdateFieldInput = {
  connect?: InputMaybe<AnswerQuestionConnectFieldInput>;
  create?: InputMaybe<AnswerQuestionCreateFieldInput>;
  delete?: InputMaybe<AnswerQuestionDeleteFieldInput>;
  disconnect?: InputMaybe<AnswerQuestionDisconnectFieldInput>;
  update?: InputMaybe<AnswerQuestionUpdateConnectionInput>;
  where?: InputMaybe<AnswerQuestionConnectionWhere>;
};

export type AnswerQuestionnaireStepQuestionAggregationSelection = {
  __typename?: 'AnswerQuestionnaireStepQuestionAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<AnswerQuestionnaireStepQuestionNodeAggregateSelection>;
};

export type AnswerQuestionnaireStepQuestionNodeAggregateSelection = {
  __typename?: 'AnswerQuestionnaireStepQuestionNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type AnswerRelationInput = {
  interview?: InputMaybe<AnswerInterviewCreateFieldInput>;
  question?: InputMaybe<AnswerQuestionCreateFieldInput>;
};

/** Fields to sort Answers by. The order in which sorts are applied is not guaranteed when specifying many fields in one AnswerSort object. */
export type AnswerSort = {
  alert?: InputMaybe<SortDirection>;
  createdAt?: InputMaybe<SortDirection>;
  field?: InputMaybe<SortDirection>;
  hint?: InputMaybe<SortDirection>;
  label?: InputMaybe<SortDirection>;
  order?: InputMaybe<SortDirection>;
  type?: InputMaybe<SortDirection>;
};

export type AnswerUpdateInput = {
  alert?: InputMaybe<AlertLevel>;
  choices?: InputMaybe<Array<Scalars['String']['input']>>;
  choices_POP?: InputMaybe<Scalars['Int']['input']>;
  choices_PUSH?: InputMaybe<Array<Scalars['String']['input']>>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  field?: InputMaybe<Scalars['String']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  interview?: InputMaybe<AnswerInterviewUpdateFieldInput>;
  order?: InputMaybe<Scalars['Int']['input']>;
  order_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  order_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<AnswerQuestionUpdateFieldInput>;
  type?: InputMaybe<AiResponseType>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
  values_POP?: InputMaybe<Scalars['Int']['input']>;
  values_PUSH?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type AnswerWhere = {
  AND?: InputMaybe<Array<AnswerWhere>>;
  NOT?: InputMaybe<AnswerWhere>;
  OR?: InputMaybe<Array<AnswerWhere>>;
  alert?: InputMaybe<AlertLevel>;
  alert_IN?: InputMaybe<Array<InputMaybe<AlertLevel>>>;
  choices?: InputMaybe<Array<Scalars['String']['input']>>;
  choices_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_IN?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  createdAt_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  field?: InputMaybe<Scalars['String']['input']>;
  field_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  field_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  field_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  field_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  hint_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  hint_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hint_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  interview?: InputMaybe<InterviewWhere>;
  interviewAggregate?: InputMaybe<AnswerInterviewAggregateInput>;
  interviewConnection?: InputMaybe<AnswerInterviewConnectionWhere>;
  interviewConnection_NOT?: InputMaybe<AnswerInterviewConnectionWhere>;
  interview_NOT?: InputMaybe<InterviewWhere>;
  label?: InputMaybe<Scalars['String']['input']>;
  label_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  label_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  label_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  label_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  order_GT?: InputMaybe<Scalars['Int']['input']>;
  order_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_IN?: InputMaybe<Array<Scalars['Int']['input']>>;
  order_LT?: InputMaybe<Scalars['Int']['input']>;
  order_LTE?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<QuestionnaireStepWhere>;
  questionAggregate?: InputMaybe<AnswerQuestionAggregateInput>;
  questionConnection?: InputMaybe<AnswerQuestionConnectionWhere>;
  questionConnection_NOT?: InputMaybe<AnswerQuestionConnectionWhere>;
  question_NOT?: InputMaybe<QuestionnaireStepWhere>;
  type?: InputMaybe<AiResponseType>;
  type_IN?: InputMaybe<Array<InputMaybe<AiResponseType>>>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
  values_INCLUDES?: InputMaybe<Scalars['String']['input']>;
};

export type AnswersConnection = {
  __typename?: 'AnswersConnection';
  edges: Array<AnswerEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type BaseQuestionnaire = {
  id: Scalars['ID']['output'];
  latest: VersionnedGraph;
  name: Scalars['String']['output'];
  owner?: Maybe<Owner>;
  ownerConnection: BaseQuestionnaireOwnerConnection;
  versions: Array<VersionnedGraph>;
  versionsConnection: BaseQuestionnaireVersionsConnection;
};


export type BaseQuestionnaireOwnerArgs = {
  options?: InputMaybe<QueryOptions>;
  where?: InputMaybe<OwnerWhere>;
};


export type BaseQuestionnaireOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BaseQuestionnaireOwnerConnectionWhere>;
};


export type BaseQuestionnaireVersionsArgs = {
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type BaseQuestionnaireVersionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<BaseQuestionnaireVersionsConnectionSort>>;
  where?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
};

export type BaseQuestionnaireAggregateSelection = {
  __typename?: 'BaseQuestionnaireAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type BaseQuestionnaireConnectInput = {
  owner?: InputMaybe<BaseQuestionnaireOwnerConnectInput>;
  versions?: InputMaybe<Array<BaseQuestionnaireVersionsConnectFieldInput>>;
};

export type BaseQuestionnaireConnectWhere = {
  node: BaseQuestionnaireWhere;
};

export type BaseQuestionnaireCreateInput = {
  Questionnaire?: InputMaybe<QuestionnaireCreateInput>;
  Workflow?: InputMaybe<WorkflowCreateInput>;
};

export type BaseQuestionnaireDeleteInput = {
  owner?: InputMaybe<BaseQuestionnaireOwnerDeleteInput>;
  versions?: InputMaybe<Array<BaseQuestionnaireVersionsDeleteFieldInput>>;
};

export type BaseQuestionnaireDisconnectInput = {
  owner?: InputMaybe<BaseQuestionnaireOwnerDisconnectInput>;
  versions?: InputMaybe<Array<BaseQuestionnaireVersionsDisconnectFieldInput>>;
};

export type BaseQuestionnaireEdge = {
  __typename?: 'BaseQuestionnaireEdge';
  cursor: Scalars['String']['output'];
  node: BaseQuestionnaire;
};

export enum BaseQuestionnaireImplementation {
  Questionnaire = 'Questionnaire',
  Workflow = 'Workflow'
}

export type BaseQuestionnaireOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more BaseQuestionnaireSort objects to sort BaseQuestionnaires by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<InputMaybe<BaseQuestionnaireSort>>>;
};

export type BaseQuestionnaireOwnerConnectInput = {
  Doctor?: InputMaybe<BaseQuestionnaireOwnerDoctorConnectFieldInput>;
  Institution?: InputMaybe<BaseQuestionnaireOwnerInstitutionConnectFieldInput>;
};

export type BaseQuestionnaireOwnerConnection = {
  __typename?: 'BaseQuestionnaireOwnerConnection';
  edges: Array<BaseQuestionnaireOwnerRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type BaseQuestionnaireOwnerConnectionWhere = {
  Doctor?: InputMaybe<BaseQuestionnaireOwnerDoctorConnectionWhere>;
  Institution?: InputMaybe<BaseQuestionnaireOwnerInstitutionConnectionWhere>;
};

export type BaseQuestionnaireOwnerDeleteInput = {
  Doctor?: InputMaybe<BaseQuestionnaireOwnerDoctorDeleteFieldInput>;
  Institution?: InputMaybe<BaseQuestionnaireOwnerInstitutionDeleteFieldInput>;
};

export type BaseQuestionnaireOwnerDisconnectInput = {
  Doctor?: InputMaybe<BaseQuestionnaireOwnerDoctorDisconnectFieldInput>;
  Institution?: InputMaybe<BaseQuestionnaireOwnerInstitutionDisconnectFieldInput>;
};

export type BaseQuestionnaireOwnerDoctorConnectFieldInput = {
  connect?: InputMaybe<DoctorConnectInput>;
  where?: InputMaybe<DoctorConnectWhere>;
};

export type BaseQuestionnaireOwnerDoctorConnectOrCreateFieldInput = {
  onCreate: BaseQuestionnaireOwnerDoctorConnectOrCreateFieldInputOnCreate;
  where: DoctorConnectOrCreateWhere;
};

export type BaseQuestionnaireOwnerDoctorConnectOrCreateFieldInputOnCreate = {
  node: DoctorOnCreateInput;
};

export type BaseQuestionnaireOwnerDoctorConnectionWhere = {
  AND?: InputMaybe<Array<BaseQuestionnaireOwnerDoctorConnectionWhere>>;
  NOT?: InputMaybe<BaseQuestionnaireOwnerDoctorConnectionWhere>;
  OR?: InputMaybe<Array<BaseQuestionnaireOwnerDoctorConnectionWhere>>;
  node?: InputMaybe<DoctorWhere>;
};

export type BaseQuestionnaireOwnerDoctorCreateFieldInput = {
  node: DoctorCreateInput;
};

export type BaseQuestionnaireOwnerDoctorDeleteFieldInput = {
  delete?: InputMaybe<DoctorDeleteInput>;
  where?: InputMaybe<BaseQuestionnaireOwnerDoctorConnectionWhere>;
};

export type BaseQuestionnaireOwnerDoctorDisconnectFieldInput = {
  disconnect?: InputMaybe<DoctorDisconnectInput>;
  where?: InputMaybe<BaseQuestionnaireOwnerDoctorConnectionWhere>;
};

export type BaseQuestionnaireOwnerDoctorUpdateConnectionInput = {
  node?: InputMaybe<DoctorUpdateInput>;
};

export type BaseQuestionnaireOwnerDoctorUpdateFieldInput = {
  connect?: InputMaybe<BaseQuestionnaireOwnerDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<BaseQuestionnaireOwnerDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<BaseQuestionnaireOwnerDoctorCreateFieldInput>;
  delete?: InputMaybe<BaseQuestionnaireOwnerDoctorDeleteFieldInput>;
  disconnect?: InputMaybe<BaseQuestionnaireOwnerDoctorDisconnectFieldInput>;
  update?: InputMaybe<BaseQuestionnaireOwnerDoctorUpdateConnectionInput>;
  where?: InputMaybe<BaseQuestionnaireOwnerDoctorConnectionWhere>;
};

export type BaseQuestionnaireOwnerInstitutionConnectFieldInput = {
  connect?: InputMaybe<InstitutionConnectInput>;
  where?: InputMaybe<InstitutionConnectWhere>;
};

export type BaseQuestionnaireOwnerInstitutionConnectOrCreateFieldInput = {
  onCreate: BaseQuestionnaireOwnerInstitutionConnectOrCreateFieldInputOnCreate;
  where: InstitutionConnectOrCreateWhere;
};

export type BaseQuestionnaireOwnerInstitutionConnectOrCreateFieldInputOnCreate = {
  node: InstitutionOnCreateInput;
};

export type BaseQuestionnaireOwnerInstitutionConnectionWhere = {
  AND?: InputMaybe<Array<BaseQuestionnaireOwnerInstitutionConnectionWhere>>;
  NOT?: InputMaybe<BaseQuestionnaireOwnerInstitutionConnectionWhere>;
  OR?: InputMaybe<Array<BaseQuestionnaireOwnerInstitutionConnectionWhere>>;
  node?: InputMaybe<InstitutionWhere>;
};

export type BaseQuestionnaireOwnerInstitutionCreateFieldInput = {
  node: InstitutionCreateInput;
};

export type BaseQuestionnaireOwnerInstitutionDeleteFieldInput = {
  delete?: InputMaybe<InstitutionDeleteInput>;
  where?: InputMaybe<BaseQuestionnaireOwnerInstitutionConnectionWhere>;
};

export type BaseQuestionnaireOwnerInstitutionDisconnectFieldInput = {
  disconnect?: InputMaybe<InstitutionDisconnectInput>;
  where?: InputMaybe<BaseQuestionnaireOwnerInstitutionConnectionWhere>;
};

export type BaseQuestionnaireOwnerInstitutionUpdateConnectionInput = {
  node?: InputMaybe<InstitutionUpdateInput>;
};

export type BaseQuestionnaireOwnerInstitutionUpdateFieldInput = {
  connect?: InputMaybe<BaseQuestionnaireOwnerInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<BaseQuestionnaireOwnerInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<BaseQuestionnaireOwnerInstitutionCreateFieldInput>;
  delete?: InputMaybe<BaseQuestionnaireOwnerInstitutionDeleteFieldInput>;
  disconnect?: InputMaybe<BaseQuestionnaireOwnerInstitutionDisconnectFieldInput>;
  update?: InputMaybe<BaseQuestionnaireOwnerInstitutionUpdateConnectionInput>;
  where?: InputMaybe<BaseQuestionnaireOwnerInstitutionConnectionWhere>;
};

export type BaseQuestionnaireOwnerRelationship = {
  __typename?: 'BaseQuestionnaireOwnerRelationship';
  cursor: Scalars['String']['output'];
  node: Owner;
};

export type BaseQuestionnaireOwnerUpdateInput = {
  Doctor?: InputMaybe<BaseQuestionnaireOwnerDoctorUpdateFieldInput>;
  Institution?: InputMaybe<BaseQuestionnaireOwnerInstitutionUpdateFieldInput>;
};

/** Fields to sort BaseQuestionnaires by. The order in which sorts are applied is not guaranteed when specifying many fields in one BaseQuestionnaireSort object. */
export type BaseQuestionnaireSort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type BaseQuestionnaireUpdateInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<BaseQuestionnaireOwnerUpdateInput>;
  versions?: InputMaybe<Array<BaseQuestionnaireVersionsUpdateFieldInput>>;
};

export type BaseQuestionnaireVersionsAggregateInput = {
  AND?: InputMaybe<Array<BaseQuestionnaireVersionsAggregateInput>>;
  NOT?: InputMaybe<BaseQuestionnaireVersionsAggregateInput>;
  OR?: InputMaybe<Array<BaseQuestionnaireVersionsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<BaseQuestionnaireVersionsEdgeAggregationWhereInput>;
  node?: InputMaybe<BaseQuestionnaireVersionsNodeAggregationWhereInput>;
};

export type BaseQuestionnaireVersionsConnectFieldInput = {
  connect?: InputMaybe<Array<VersionnedGraphConnectInput>>;
  edge: BaseQuestionnaireVersionsEdgeCreateInput;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type BaseQuestionnaireVersionsConnection = {
  __typename?: 'BaseQuestionnaireVersionsConnection';
  edges: Array<BaseQuestionnaireVersionsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type BaseQuestionnaireVersionsConnectionSort = {
  edge?: InputMaybe<BaseQuestionnaireVersionsEdgeSort>;
  node?: InputMaybe<VersionnedGraphSort>;
};

export type BaseQuestionnaireVersionsConnectionWhere = {
  AND?: InputMaybe<Array<BaseQuestionnaireVersionsConnectionWhere>>;
  NOT?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  OR?: InputMaybe<Array<BaseQuestionnaireVersionsConnectionWhere>>;
  edge?: InputMaybe<BaseQuestionnaireVersionsEdgeWhere>;
  node?: InputMaybe<VersionnedGraphWhere>;
};

export type BaseQuestionnaireVersionsCreateFieldInput = {
  edge: BaseQuestionnaireVersionsEdgeCreateInput;
  node: VersionnedGraphCreateInput;
};

export type BaseQuestionnaireVersionsDeleteFieldInput = {
  delete?: InputMaybe<VersionnedGraphDeleteInput>;
  where?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
};

export type BaseQuestionnaireVersionsDisconnectFieldInput = {
  disconnect?: InputMaybe<VersionnedGraphDisconnectInput>;
  where?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
};

export type BaseQuestionnaireVersionsEdgeAggregationWhereInput = {
  /**
   * Relationship properties when source node is of type:
   * * Questionnaire
   * * Workflow
   */
  VersionnedRelation?: InputMaybe<VersionnedRelationAggregationWhereInput>;
};

export type BaseQuestionnaireVersionsEdgeCreateInput = {
  /**
   * Relationship properties when source node is of type:
   * * Questionnaire
   * * Workflow
   */
  VersionnedRelation: VersionnedRelationCreateInput;
};

export type BaseQuestionnaireVersionsEdgeSort = {
  /**
   * Relationship properties when source node is of type:
   * * Questionnaire
   * * Workflow
   */
  VersionnedRelation?: InputMaybe<VersionnedRelationSort>;
};

export type BaseQuestionnaireVersionsEdgeUpdateInput = {
  /**
   * Relationship properties when source node is of type:
   * * Questionnaire
   * * Workflow
   */
  VersionnedRelation?: InputMaybe<VersionnedRelationUpdateInput>;
};

export type BaseQuestionnaireVersionsEdgeWhere = {
  /**
   * Relationship properties when source node is of type:
   * * Questionnaire
   * * Workflow
   */
  VersionnedRelation?: InputMaybe<VersionnedRelationWhere>;
};

export type BaseQuestionnaireVersionsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<BaseQuestionnaireVersionsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<BaseQuestionnaireVersionsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<BaseQuestionnaireVersionsNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type BaseQuestionnaireVersionsRelationship = {
  __typename?: 'BaseQuestionnaireVersionsRelationship';
  cursor: Scalars['String']['output'];
  node: VersionnedGraph;
  properties: BaseQuestionnaireVersionsRelationshipProperties;
};

export type BaseQuestionnaireVersionsRelationshipProperties = VersionnedRelation;

export type BaseQuestionnaireVersionsUpdateConnectionInput = {
  edge?: InputMaybe<BaseQuestionnaireVersionsEdgeUpdateInput>;
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type BaseQuestionnaireVersionsUpdateFieldInput = {
  connect?: InputMaybe<Array<BaseQuestionnaireVersionsConnectFieldInput>>;
  create?: InputMaybe<Array<BaseQuestionnaireVersionsCreateFieldInput>>;
  delete?: InputMaybe<Array<BaseQuestionnaireVersionsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<BaseQuestionnaireVersionsDisconnectFieldInput>>;
  update?: InputMaybe<BaseQuestionnaireVersionsUpdateConnectionInput>;
  where?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
};

export type BaseQuestionnaireWhere = {
  AND?: InputMaybe<Array<BaseQuestionnaireWhere>>;
  NOT?: InputMaybe<BaseQuestionnaireWhere>;
  OR?: InputMaybe<Array<BaseQuestionnaireWhere>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<OwnerWhere>;
  ownerConnection?: InputMaybe<BaseQuestionnaireOwnerConnectionWhere>;
  ownerConnection_NOT?: InputMaybe<BaseQuestionnaireOwnerConnectionWhere>;
  owner_NOT?: InputMaybe<OwnerWhere>;
  typename_IN?: InputMaybe<Array<BaseQuestionnaireImplementation>>;
  versionsAggregate?: InputMaybe<BaseQuestionnaireVersionsAggregateInput>;
  /** Return BaseQuestionnaires where all of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_ALL?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return BaseQuestionnaires where none of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_NONE?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return BaseQuestionnaires where one of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_SINGLE?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return BaseQuestionnaires where some of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_SOME?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return BaseQuestionnaires where all of the related VersionnedGraphs match this filter */
  versions_ALL?: InputMaybe<VersionnedGraphWhere>;
  /** Return BaseQuestionnaires where none of the related VersionnedGraphs match this filter */
  versions_NONE?: InputMaybe<VersionnedGraphWhere>;
  /** Return BaseQuestionnaires where one of the related VersionnedGraphs match this filter */
  versions_SINGLE?: InputMaybe<VersionnedGraphWhere>;
  /** Return BaseQuestionnaires where some of the related VersionnedGraphs match this filter */
  versions_SOME?: InputMaybe<VersionnedGraphWhere>;
};

export type BaseQuestionnairesConnection = {
  __typename?: 'BaseQuestionnairesConnection';
  edges: Array<BaseQuestionnaireEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type CheckboxQuestion = Question & QuestionnaireStep & {
  __typename?: 'CheckboxQuestion';
  alerts?: Maybe<AlertGroup>;
  alertsAggregate?: Maybe<CheckboxQuestionAlertGroupAlertsAggregationSelection>;
  alertsConnection: QuestionAlertsConnection;
  answers: Array<Answer>;
  answersAggregate?: Maybe<CheckboxQuestionAnswerAnswersAggregationSelection>;
  answersConnection: QuestionAnswersConnection;
  choices: Array<QuestionItem>;
  choicesAggregate?: Maybe<CheckboxQuestionQuestionItemChoicesAggregationSelection>;
  choicesConnection: CheckboxQuestionChoicesConnection;
  cooldown?: Maybe<Cooldown>;
  cooldownAggregate?: Maybe<CheckboxQuestionCooldownCooldownAggregationSelection>;
  cooldownConnection: CheckboxQuestionCooldownConnection;
  field?: Maybe<Scalars['String']['output']>;
  graph: VersionnedGraph;
  graphAggregate?: Maybe<CheckboxQuestionVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  hint?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<CheckboxQuestionQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<CheckboxQuestionQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type CheckboxQuestionAlertsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AlertGroupOptions>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type CheckboxQuestionAlertsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type CheckboxQuestionAlertsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};


export type CheckboxQuestionAnswersArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AnswerOptions>;
  where?: InputMaybe<AnswerWhere>;
};


export type CheckboxQuestionAnswersAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AnswerWhere>;
};


export type CheckboxQuestionAnswersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionAnswersConnectionSort>>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};


export type CheckboxQuestionChoicesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionItemOptions>;
  where?: InputMaybe<QuestionItemWhere>;
};


export type CheckboxQuestionChoicesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionItemWhere>;
};


export type CheckboxQuestionChoicesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<CheckboxQuestionChoicesConnectionSort>>;
  where?: InputMaybe<CheckboxQuestionChoicesConnectionWhere>;
};


export type CheckboxQuestionCooldownArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<CooldownOptions>;
  where?: InputMaybe<CooldownWhere>;
};


export type CheckboxQuestionCooldownAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<CooldownWhere>;
};


export type CheckboxQuestionCooldownConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<CheckboxQuestionCooldownConnectionSort>>;
  where?: InputMaybe<CheckboxQuestionCooldownConnectionWhere>;
};


export type CheckboxQuestionGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type CheckboxQuestionGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type CheckboxQuestionGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type CheckboxQuestionNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type CheckboxQuestionNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type CheckboxQuestionNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type CheckboxQuestionPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type CheckboxQuestionPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type CheckboxQuestionPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type CheckboxQuestionAggregateSelection = {
  __typename?: 'CheckboxQuestionAggregateSelection';
  count: Scalars['Int']['output'];
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  id: IdAggregateSelection;
  image: StringAggregateSelection;
  name: StringAggregateSelection;
};

export type CheckboxQuestionAlertGroupAlertsAggregationSelection = {
  __typename?: 'CheckboxQuestionAlertGroupAlertsAggregationSelection';
  count: Scalars['Int']['output'];
};

export type CheckboxQuestionAlertsAggregateInput = {
  AND?: InputMaybe<Array<CheckboxQuestionAlertsAggregateInput>>;
  NOT?: InputMaybe<CheckboxQuestionAlertsAggregateInput>;
  OR?: InputMaybe<Array<CheckboxQuestionAlertsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type CheckboxQuestionAlertsConnectFieldInput = {
  connect?: InputMaybe<AlertGroupConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AlertGroupConnectWhere>;
};

export type CheckboxQuestionAlertsCreateFieldInput = {
  node: AlertGroupCreateInput;
};

export type CheckboxQuestionAlertsFieldInput = {
  connect?: InputMaybe<CheckboxQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<CheckboxQuestionAlertsCreateFieldInput>;
};

export type CheckboxQuestionAlertsUpdateConnectionInput = {
  node?: InputMaybe<AlertGroupUpdateInput>;
};

export type CheckboxQuestionAlertsUpdateFieldInput = {
  connect?: InputMaybe<CheckboxQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<CheckboxQuestionAlertsCreateFieldInput>;
  delete?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  update?: InputMaybe<CheckboxQuestionAlertsUpdateConnectionInput>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};

export type CheckboxQuestionAnswerAnswersAggregationSelection = {
  __typename?: 'CheckboxQuestionAnswerAnswersAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<CheckboxQuestionAnswerAnswersNodeAggregateSelection>;
};

export type CheckboxQuestionAnswerAnswersNodeAggregateSelection = {
  __typename?: 'CheckboxQuestionAnswerAnswersNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type CheckboxQuestionAnswersAggregateInput = {
  AND?: InputMaybe<Array<CheckboxQuestionAnswersAggregateInput>>;
  NOT?: InputMaybe<CheckboxQuestionAnswersAggregateInput>;
  OR?: InputMaybe<Array<CheckboxQuestionAnswersAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<CheckboxQuestionAnswersNodeAggregationWhereInput>;
};

export type CheckboxQuestionAnswersConnectFieldInput = {
  connect?: InputMaybe<Array<AnswerConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AnswerConnectWhere>;
};

export type CheckboxQuestionAnswersCreateFieldInput = {
  node: AnswerCreateInput;
};

export type CheckboxQuestionAnswersFieldInput = {
  connect?: InputMaybe<Array<CheckboxQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<CheckboxQuestionAnswersCreateFieldInput>>;
};

export type CheckboxQuestionAnswersNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CheckboxQuestionAnswersNodeAggregationWhereInput>>;
  NOT?: InputMaybe<CheckboxQuestionAnswersNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<CheckboxQuestionAnswersNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  field_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  field_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  hint_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type CheckboxQuestionAnswersUpdateConnectionInput = {
  node?: InputMaybe<AnswerUpdateInput>;
};

export type CheckboxQuestionAnswersUpdateFieldInput = {
  connect?: InputMaybe<Array<CheckboxQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<CheckboxQuestionAnswersCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  update?: InputMaybe<CheckboxQuestionAnswersUpdateConnectionInput>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};

export type CheckboxQuestionChoicesAggregateInput = {
  AND?: InputMaybe<Array<CheckboxQuestionChoicesAggregateInput>>;
  NOT?: InputMaybe<CheckboxQuestionChoicesAggregateInput>;
  OR?: InputMaybe<Array<CheckboxQuestionChoicesAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<CheckboxQuestionChoicesNodeAggregationWhereInput>;
};

export type CheckboxQuestionChoicesConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<QuestionItemConnectWhere>;
};

export type CheckboxQuestionChoicesConnectOrCreateFieldInput = {
  onCreate: CheckboxQuestionChoicesConnectOrCreateFieldInputOnCreate;
  where: QuestionItemConnectOrCreateWhere;
};

export type CheckboxQuestionChoicesConnectOrCreateFieldInputOnCreate = {
  node: QuestionItemOnCreateInput;
};

export type CheckboxQuestionChoicesConnection = {
  __typename?: 'CheckboxQuestionChoicesConnection';
  edges: Array<CheckboxQuestionChoicesRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type CheckboxQuestionChoicesConnectionSort = {
  node?: InputMaybe<QuestionItemSort>;
};

export type CheckboxQuestionChoicesConnectionWhere = {
  AND?: InputMaybe<Array<CheckboxQuestionChoicesConnectionWhere>>;
  NOT?: InputMaybe<CheckboxQuestionChoicesConnectionWhere>;
  OR?: InputMaybe<Array<CheckboxQuestionChoicesConnectionWhere>>;
  node?: InputMaybe<QuestionItemWhere>;
};

export type CheckboxQuestionChoicesCreateFieldInput = {
  node: QuestionItemCreateInput;
};

export type CheckboxQuestionChoicesDeleteFieldInput = {
  where?: InputMaybe<CheckboxQuestionChoicesConnectionWhere>;
};

export type CheckboxQuestionChoicesDisconnectFieldInput = {
  where?: InputMaybe<CheckboxQuestionChoicesConnectionWhere>;
};

export type CheckboxQuestionChoicesFieldInput = {
  connect?: InputMaybe<Array<CheckboxQuestionChoicesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<CheckboxQuestionChoicesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<CheckboxQuestionChoicesCreateFieldInput>>;
};

export type CheckboxQuestionChoicesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CheckboxQuestionChoicesNodeAggregationWhereInput>>;
  NOT?: InputMaybe<CheckboxQuestionChoicesNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<CheckboxQuestionChoicesNodeAggregationWhereInput>>;
  label_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  label_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
  score_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  score_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type CheckboxQuestionChoicesRelationship = {
  __typename?: 'CheckboxQuestionChoicesRelationship';
  cursor: Scalars['String']['output'];
  node: QuestionItem;
};

export type CheckboxQuestionChoicesUpdateConnectionInput = {
  node?: InputMaybe<QuestionItemUpdateInput>;
};

export type CheckboxQuestionChoicesUpdateFieldInput = {
  connect?: InputMaybe<Array<CheckboxQuestionChoicesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<CheckboxQuestionChoicesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<CheckboxQuestionChoicesCreateFieldInput>>;
  delete?: InputMaybe<Array<CheckboxQuestionChoicesDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<CheckboxQuestionChoicesDisconnectFieldInput>>;
  update?: InputMaybe<CheckboxQuestionChoicesUpdateConnectionInput>;
  where?: InputMaybe<CheckboxQuestionChoicesConnectionWhere>;
};

export type CheckboxQuestionConnectInput = {
  alerts?: InputMaybe<CheckboxQuestionAlertsConnectFieldInput>;
  answers?: InputMaybe<Array<CheckboxQuestionAnswersConnectFieldInput>>;
  choices?: InputMaybe<Array<CheckboxQuestionChoicesConnectFieldInput>>;
  cooldown?: InputMaybe<CheckboxQuestionCooldownConnectFieldInput>;
  graph?: InputMaybe<CheckboxQuestionGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<CheckboxQuestionNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<CheckboxQuestionPrevsConnectFieldInput>>;
};

export type CheckboxQuestionConnectOrCreateInput = {
  choices?: InputMaybe<Array<CheckboxQuestionChoicesConnectOrCreateFieldInput>>;
};

export type CheckboxQuestionCooldownAggregateInput = {
  AND?: InputMaybe<Array<CheckboxQuestionCooldownAggregateInput>>;
  NOT?: InputMaybe<CheckboxQuestionCooldownAggregateInput>;
  OR?: InputMaybe<Array<CheckboxQuestionCooldownAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<CheckboxQuestionCooldownNodeAggregationWhereInput>;
};

export type CheckboxQuestionCooldownConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<CooldownConnectWhere>;
};

export type CheckboxQuestionCooldownConnection = {
  __typename?: 'CheckboxQuestionCooldownConnection';
  edges: Array<CheckboxQuestionCooldownRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type CheckboxQuestionCooldownConnectionSort = {
  node?: InputMaybe<CooldownSort>;
};

export type CheckboxQuestionCooldownConnectionWhere = {
  AND?: InputMaybe<Array<CheckboxQuestionCooldownConnectionWhere>>;
  NOT?: InputMaybe<CheckboxQuestionCooldownConnectionWhere>;
  OR?: InputMaybe<Array<CheckboxQuestionCooldownConnectionWhere>>;
  node?: InputMaybe<CooldownWhere>;
};

export type CheckboxQuestionCooldownCooldownAggregationSelection = {
  __typename?: 'CheckboxQuestionCooldownCooldownAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<CheckboxQuestionCooldownCooldownNodeAggregateSelection>;
};

export type CheckboxQuestionCooldownCooldownNodeAggregateSelection = {
  __typename?: 'CheckboxQuestionCooldownCooldownNodeAggregateSelection';
  value: IntAggregateSelection;
};

export type CheckboxQuestionCooldownCreateFieldInput = {
  node: CooldownCreateInput;
};

export type CheckboxQuestionCooldownDeleteFieldInput = {
  where?: InputMaybe<CheckboxQuestionCooldownConnectionWhere>;
};

export type CheckboxQuestionCooldownDisconnectFieldInput = {
  where?: InputMaybe<CheckboxQuestionCooldownConnectionWhere>;
};

export type CheckboxQuestionCooldownFieldInput = {
  connect?: InputMaybe<CheckboxQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<CheckboxQuestionCooldownCreateFieldInput>;
};

export type CheckboxQuestionCooldownNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CheckboxQuestionCooldownNodeAggregationWhereInput>>;
  NOT?: InputMaybe<CheckboxQuestionCooldownNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<CheckboxQuestionCooldownNodeAggregationWhereInput>>;
  value_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  value_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type CheckboxQuestionCooldownRelationship = {
  __typename?: 'CheckboxQuestionCooldownRelationship';
  cursor: Scalars['String']['output'];
  node: Cooldown;
};

export type CheckboxQuestionCooldownUpdateConnectionInput = {
  node?: InputMaybe<CooldownUpdateInput>;
};

export type CheckboxQuestionCooldownUpdateFieldInput = {
  connect?: InputMaybe<CheckboxQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<CheckboxQuestionCooldownCreateFieldInput>;
  delete?: InputMaybe<CheckboxQuestionCooldownDeleteFieldInput>;
  disconnect?: InputMaybe<CheckboxQuestionCooldownDisconnectFieldInput>;
  update?: InputMaybe<CheckboxQuestionCooldownUpdateConnectionInput>;
  where?: InputMaybe<CheckboxQuestionCooldownConnectionWhere>;
};

export type CheckboxQuestionCreateInput = {
  alerts?: InputMaybe<CheckboxQuestionAlertsFieldInput>;
  answers?: InputMaybe<CheckboxQuestionAnswersFieldInput>;
  choices?: InputMaybe<CheckboxQuestionChoicesFieldInput>;
  cooldown?: InputMaybe<CheckboxQuestionCooldownFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<CheckboxQuestionGraphFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  nexts?: InputMaybe<CheckboxQuestionNextsFieldInput>;
  prevs?: InputMaybe<CheckboxQuestionPrevsFieldInput>;
};

export type CheckboxQuestionDeleteInput = {
  alerts?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  choices?: InputMaybe<Array<CheckboxQuestionChoicesDeleteFieldInput>>;
  cooldown?: InputMaybe<CheckboxQuestionCooldownDeleteFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<CheckboxQuestionNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<CheckboxQuestionPrevsDeleteFieldInput>>;
};

export type CheckboxQuestionDisconnectInput = {
  alerts?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  choices?: InputMaybe<Array<CheckboxQuestionChoicesDisconnectFieldInput>>;
  cooldown?: InputMaybe<CheckboxQuestionCooldownDisconnectFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<CheckboxQuestionNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<CheckboxQuestionPrevsDisconnectFieldInput>>;
};

export type CheckboxQuestionEdge = {
  __typename?: 'CheckboxQuestionEdge';
  cursor: Scalars['String']['output'];
  node: CheckboxQuestion;
};

export type CheckboxQuestionGraphAggregateInput = {
  AND?: InputMaybe<Array<CheckboxQuestionGraphAggregateInput>>;
  NOT?: InputMaybe<CheckboxQuestionGraphAggregateInput>;
  OR?: InputMaybe<Array<CheckboxQuestionGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<CheckboxQuestionGraphNodeAggregationWhereInput>;
};

export type CheckboxQuestionGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type CheckboxQuestionGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type CheckboxQuestionGraphFieldInput = {
  connect?: InputMaybe<CheckboxQuestionGraphConnectFieldInput>;
  create?: InputMaybe<CheckboxQuestionGraphCreateFieldInput>;
};

export type CheckboxQuestionGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CheckboxQuestionGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<CheckboxQuestionGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<CheckboxQuestionGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type CheckboxQuestionGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type CheckboxQuestionGraphUpdateFieldInput = {
  connect?: InputMaybe<CheckboxQuestionGraphConnectFieldInput>;
  create?: InputMaybe<CheckboxQuestionGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<CheckboxQuestionGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type CheckboxQuestionNextsAggregateInput = {
  AND?: InputMaybe<Array<CheckboxQuestionNextsAggregateInput>>;
  NOT?: InputMaybe<CheckboxQuestionNextsAggregateInput>;
  OR?: InputMaybe<Array<CheckboxQuestionNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<CheckboxQuestionNextsNodeAggregationWhereInput>;
};

export type CheckboxQuestionNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type CheckboxQuestionNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type CheckboxQuestionNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type CheckboxQuestionNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type CheckboxQuestionNextsFieldInput = {
  connect?: InputMaybe<Array<CheckboxQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<CheckboxQuestionNextsCreateFieldInput>>;
};

export type CheckboxQuestionNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CheckboxQuestionNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<CheckboxQuestionNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<CheckboxQuestionNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type CheckboxQuestionNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type CheckboxQuestionNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<CheckboxQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<CheckboxQuestionNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<CheckboxQuestionNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<CheckboxQuestionNextsDisconnectFieldInput>>;
  update?: InputMaybe<CheckboxQuestionNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type CheckboxQuestionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more CheckboxQuestionSort objects to sort CheckboxQuestions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<CheckboxQuestionSort>>;
};

export type CheckboxQuestionPrevsAggregateInput = {
  AND?: InputMaybe<Array<CheckboxQuestionPrevsAggregateInput>>;
  NOT?: InputMaybe<CheckboxQuestionPrevsAggregateInput>;
  OR?: InputMaybe<Array<CheckboxQuestionPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<CheckboxQuestionPrevsNodeAggregationWhereInput>;
};

export type CheckboxQuestionPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type CheckboxQuestionPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type CheckboxQuestionPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type CheckboxQuestionPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type CheckboxQuestionPrevsFieldInput = {
  connect?: InputMaybe<Array<CheckboxQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<CheckboxQuestionPrevsCreateFieldInput>>;
};

export type CheckboxQuestionPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CheckboxQuestionPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<CheckboxQuestionPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<CheckboxQuestionPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type CheckboxQuestionPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type CheckboxQuestionPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<CheckboxQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<CheckboxQuestionPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<CheckboxQuestionPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<CheckboxQuestionPrevsDisconnectFieldInput>>;
  update?: InputMaybe<CheckboxQuestionPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type CheckboxQuestionQuestionItemChoicesAggregationSelection = {
  __typename?: 'CheckboxQuestionQuestionItemChoicesAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<CheckboxQuestionQuestionItemChoicesNodeAggregateSelection>;
};

export type CheckboxQuestionQuestionItemChoicesNodeAggregateSelection = {
  __typename?: 'CheckboxQuestionQuestionItemChoicesNodeAggregateSelection';
  id: IdAggregateSelection;
  label: StringAggregateSelection;
  medicalLabel: StringAggregateSelection;
  order: IntAggregateSelection;
  score: IntAggregateSelection;
};

export type CheckboxQuestionQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'CheckboxQuestionQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<CheckboxQuestionQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<CheckboxQuestionQuestionnaireStepNextsNodeAggregateSelection>;
};

export type CheckboxQuestionQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'CheckboxQuestionQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type CheckboxQuestionQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'CheckboxQuestionQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type CheckboxQuestionQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'CheckboxQuestionQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<CheckboxQuestionQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<CheckboxQuestionQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type CheckboxQuestionQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'CheckboxQuestionQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type CheckboxQuestionQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'CheckboxQuestionQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type CheckboxQuestionRelationInput = {
  alerts?: InputMaybe<CheckboxQuestionAlertsCreateFieldInput>;
  answers?: InputMaybe<Array<CheckboxQuestionAnswersCreateFieldInput>>;
  choices?: InputMaybe<Array<CheckboxQuestionChoicesCreateFieldInput>>;
  cooldown?: InputMaybe<CheckboxQuestionCooldownCreateFieldInput>;
  graph?: InputMaybe<CheckboxQuestionGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<CheckboxQuestionNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<CheckboxQuestionPrevsCreateFieldInput>>;
};

/** Fields to sort CheckboxQuestions by. The order in which sorts are applied is not guaranteed when specifying many fields in one CheckboxQuestionSort object. */
export type CheckboxQuestionSort = {
  field?: InputMaybe<SortDirection>;
  hint?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  image?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type CheckboxQuestionUpdateInput = {
  alerts?: InputMaybe<CheckboxQuestionAlertsUpdateFieldInput>;
  answers?: InputMaybe<Array<CheckboxQuestionAnswersUpdateFieldInput>>;
  choices?: InputMaybe<Array<CheckboxQuestionChoicesUpdateFieldInput>>;
  cooldown?: InputMaybe<CheckboxQuestionCooldownUpdateFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<CheckboxQuestionGraphUpdateFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<CheckboxQuestionNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<CheckboxQuestionPrevsUpdateFieldInput>>;
};

export type CheckboxQuestionVersionnedGraphGraphAggregationSelection = {
  __typename?: 'CheckboxQuestionVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<CheckboxQuestionVersionnedGraphGraphNodeAggregateSelection>;
};

export type CheckboxQuestionVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'CheckboxQuestionVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type CheckboxQuestionWhere = {
  AND?: InputMaybe<Array<CheckboxQuestionWhere>>;
  NOT?: InputMaybe<CheckboxQuestionWhere>;
  OR?: InputMaybe<Array<CheckboxQuestionWhere>>;
  alerts?: InputMaybe<AlertGroupWhere>;
  alertsAggregate?: InputMaybe<CheckboxQuestionAlertsAggregateInput>;
  alertsConnection?: InputMaybe<QuestionAlertsConnectionWhere>;
  alertsConnection_NOT?: InputMaybe<QuestionAlertsConnectionWhere>;
  alerts_NOT?: InputMaybe<AlertGroupWhere>;
  answersAggregate?: InputMaybe<CheckboxQuestionAnswersAggregateInput>;
  /** Return CheckboxQuestions where all of the related QuestionAnswersConnections match this filter */
  answersConnection_ALL?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return CheckboxQuestions where none of the related QuestionAnswersConnections match this filter */
  answersConnection_NONE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return CheckboxQuestions where one of the related QuestionAnswersConnections match this filter */
  answersConnection_SINGLE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return CheckboxQuestions where some of the related QuestionAnswersConnections match this filter */
  answersConnection_SOME?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return CheckboxQuestions where all of the related Answers match this filter */
  answers_ALL?: InputMaybe<AnswerWhere>;
  /** Return CheckboxQuestions where none of the related Answers match this filter */
  answers_NONE?: InputMaybe<AnswerWhere>;
  /** Return CheckboxQuestions where one of the related Answers match this filter */
  answers_SINGLE?: InputMaybe<AnswerWhere>;
  /** Return CheckboxQuestions where some of the related Answers match this filter */
  answers_SOME?: InputMaybe<AnswerWhere>;
  choicesAggregate?: InputMaybe<CheckboxQuestionChoicesAggregateInput>;
  /** Return CheckboxQuestions where all of the related CheckboxQuestionChoicesConnections match this filter */
  choicesConnection_ALL?: InputMaybe<CheckboxQuestionChoicesConnectionWhere>;
  /** Return CheckboxQuestions where none of the related CheckboxQuestionChoicesConnections match this filter */
  choicesConnection_NONE?: InputMaybe<CheckboxQuestionChoicesConnectionWhere>;
  /** Return CheckboxQuestions where one of the related CheckboxQuestionChoicesConnections match this filter */
  choicesConnection_SINGLE?: InputMaybe<CheckboxQuestionChoicesConnectionWhere>;
  /** Return CheckboxQuestions where some of the related CheckboxQuestionChoicesConnections match this filter */
  choicesConnection_SOME?: InputMaybe<CheckboxQuestionChoicesConnectionWhere>;
  /** Return CheckboxQuestions where all of the related QuestionItems match this filter */
  choices_ALL?: InputMaybe<QuestionItemWhere>;
  /** Return CheckboxQuestions where none of the related QuestionItems match this filter */
  choices_NONE?: InputMaybe<QuestionItemWhere>;
  /** Return CheckboxQuestions where one of the related QuestionItems match this filter */
  choices_SINGLE?: InputMaybe<QuestionItemWhere>;
  /** Return CheckboxQuestions where some of the related QuestionItems match this filter */
  choices_SOME?: InputMaybe<QuestionItemWhere>;
  cooldown?: InputMaybe<CooldownWhere>;
  cooldownAggregate?: InputMaybe<CheckboxQuestionCooldownAggregateInput>;
  cooldownConnection?: InputMaybe<CheckboxQuestionCooldownConnectionWhere>;
  cooldownConnection_NOT?: InputMaybe<CheckboxQuestionCooldownConnectionWhere>;
  cooldown_NOT?: InputMaybe<CooldownWhere>;
  field?: InputMaybe<Scalars['String']['input']>;
  field_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  field_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  field_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  field_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<CheckboxQuestionGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  hint?: InputMaybe<Scalars['String']['input']>;
  hint_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  hint_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hint_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  image_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  image_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  image_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  image_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<CheckboxQuestionNextsAggregateInput>;
  /** Return CheckboxQuestions where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return CheckboxQuestions where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return CheckboxQuestions where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return CheckboxQuestions where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return CheckboxQuestions where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return CheckboxQuestions where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return CheckboxQuestions where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return CheckboxQuestions where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<CheckboxQuestionPrevsAggregateInput>;
  /** Return CheckboxQuestions where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return CheckboxQuestions where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return CheckboxQuestions where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return CheckboxQuestions where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return CheckboxQuestions where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return CheckboxQuestions where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return CheckboxQuestions where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return CheckboxQuestions where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type CheckboxQuestionsConnection = {
  __typename?: 'CheckboxQuestionsConnection';
  edges: Array<CheckboxQuestionEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Condition = {
  __typename?: 'Condition';
  comparator: ConditionComparison;
  value: Scalars['String']['output'];
  var: Scalars['String']['output'];
};

export type ConditionAggregateSelection = {
  __typename?: 'ConditionAggregateSelection';
  count: Scalars['Int']['output'];
  value: StringAggregateSelection;
  var: StringAggregateSelection;
};

export enum ConditionComparison {
  Higher = 'Higher',
  HigherOrEqual = 'HigherOrEqual',
  Is = 'Is',
  Lower = 'Lower',
  LowerOrEqual = 'LowerOrEqual',
  Not = 'Not'
}

export type ConditionConnectWhere = {
  node: ConditionWhere;
};

export type ConditionCreateInput = {
  comparator: ConditionComparison;
  value: Scalars['String']['input'];
  var: Scalars['String']['input'];
};

export type ConditionEdge = {
  __typename?: 'ConditionEdge';
  cursor: Scalars['String']['output'];
  node: Condition;
};

export type ConditionGroup = {
  __typename?: 'ConditionGroup';
  conditions: Array<Conditions>;
  conditionsConnection: ConditionGroupConditionsConnection;
  label?: Maybe<Scalars['String']['output']>;
  order: ConditionLogic;
};


export type ConditionGroupConditionsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QueryOptions>;
  where?: InputMaybe<ConditionsWhere>;
};


export type ConditionGroupConditionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ConditionGroupConditionsConnectionWhere>;
};

export type ConditionGroupAggregateSelection = {
  __typename?: 'ConditionGroupAggregateSelection';
  count: Scalars['Int']['output'];
  label: StringAggregateSelection;
};

export type ConditionGroupConditionsConditionConnectFieldInput = {
  where?: InputMaybe<ConditionConnectWhere>;
};

export type ConditionGroupConditionsConditionConnectionWhere = {
  AND?: InputMaybe<Array<ConditionGroupConditionsConditionConnectionWhere>>;
  NOT?: InputMaybe<ConditionGroupConditionsConditionConnectionWhere>;
  OR?: InputMaybe<Array<ConditionGroupConditionsConditionConnectionWhere>>;
  node?: InputMaybe<ConditionWhere>;
};

export type ConditionGroupConditionsConditionCreateFieldInput = {
  node: ConditionCreateInput;
};

export type ConditionGroupConditionsConditionDeleteFieldInput = {
  where?: InputMaybe<ConditionGroupConditionsConditionConnectionWhere>;
};

export type ConditionGroupConditionsConditionDisconnectFieldInput = {
  where?: InputMaybe<ConditionGroupConditionsConditionConnectionWhere>;
};

export type ConditionGroupConditionsConditionFieldInput = {
  connect?: InputMaybe<Array<ConditionGroupConditionsConditionConnectFieldInput>>;
  create?: InputMaybe<Array<ConditionGroupConditionsConditionCreateFieldInput>>;
};

export type ConditionGroupConditionsConditionGroupConnectFieldInput = {
  connect?: InputMaybe<Array<ConditionGroupConnectInput>>;
  where?: InputMaybe<ConditionGroupConnectWhere>;
};

export type ConditionGroupConditionsConditionGroupConnectionWhere = {
  AND?: InputMaybe<Array<ConditionGroupConditionsConditionGroupConnectionWhere>>;
  NOT?: InputMaybe<ConditionGroupConditionsConditionGroupConnectionWhere>;
  OR?: InputMaybe<Array<ConditionGroupConditionsConditionGroupConnectionWhere>>;
  node?: InputMaybe<ConditionGroupWhere>;
};

export type ConditionGroupConditionsConditionGroupCreateFieldInput = {
  node: ConditionGroupCreateInput;
};

export type ConditionGroupConditionsConditionGroupDeleteFieldInput = {
  delete?: InputMaybe<ConditionGroupDeleteInput>;
  where?: InputMaybe<ConditionGroupConditionsConditionGroupConnectionWhere>;
};

export type ConditionGroupConditionsConditionGroupDisconnectFieldInput = {
  disconnect?: InputMaybe<ConditionGroupDisconnectInput>;
  where?: InputMaybe<ConditionGroupConditionsConditionGroupConnectionWhere>;
};

export type ConditionGroupConditionsConditionGroupFieldInput = {
  connect?: InputMaybe<Array<ConditionGroupConditionsConditionGroupConnectFieldInput>>;
  create?: InputMaybe<Array<ConditionGroupConditionsConditionGroupCreateFieldInput>>;
};

export type ConditionGroupConditionsConditionGroupUpdateConnectionInput = {
  node?: InputMaybe<ConditionGroupUpdateInput>;
};

export type ConditionGroupConditionsConditionGroupUpdateFieldInput = {
  connect?: InputMaybe<Array<ConditionGroupConditionsConditionGroupConnectFieldInput>>;
  create?: InputMaybe<Array<ConditionGroupConditionsConditionGroupCreateFieldInput>>;
  delete?: InputMaybe<Array<ConditionGroupConditionsConditionGroupDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<ConditionGroupConditionsConditionGroupDisconnectFieldInput>>;
  update?: InputMaybe<ConditionGroupConditionsConditionGroupUpdateConnectionInput>;
  where?: InputMaybe<ConditionGroupConditionsConditionGroupConnectionWhere>;
};

export type ConditionGroupConditionsConditionUpdateConnectionInput = {
  node?: InputMaybe<ConditionUpdateInput>;
};

export type ConditionGroupConditionsConditionUpdateFieldInput = {
  connect?: InputMaybe<Array<ConditionGroupConditionsConditionConnectFieldInput>>;
  create?: InputMaybe<Array<ConditionGroupConditionsConditionCreateFieldInput>>;
  delete?: InputMaybe<Array<ConditionGroupConditionsConditionDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<ConditionGroupConditionsConditionDisconnectFieldInput>>;
  update?: InputMaybe<ConditionGroupConditionsConditionUpdateConnectionInput>;
  where?: InputMaybe<ConditionGroupConditionsConditionConnectionWhere>;
};

export type ConditionGroupConditionsConnectInput = {
  Condition?: InputMaybe<Array<ConditionGroupConditionsConditionConnectFieldInput>>;
  ConditionGroup?: InputMaybe<Array<ConditionGroupConditionsConditionGroupConnectFieldInput>>;
};

export type ConditionGroupConditionsConnection = {
  __typename?: 'ConditionGroupConditionsConnection';
  edges: Array<ConditionGroupConditionsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type ConditionGroupConditionsConnectionWhere = {
  Condition?: InputMaybe<ConditionGroupConditionsConditionConnectionWhere>;
  ConditionGroup?: InputMaybe<ConditionGroupConditionsConditionGroupConnectionWhere>;
};

export type ConditionGroupConditionsCreateFieldInput = {
  Condition?: InputMaybe<Array<ConditionGroupConditionsConditionCreateFieldInput>>;
  ConditionGroup?: InputMaybe<Array<ConditionGroupConditionsConditionGroupCreateFieldInput>>;
};

export type ConditionGroupConditionsCreateInput = {
  Condition?: InputMaybe<ConditionGroupConditionsConditionFieldInput>;
  ConditionGroup?: InputMaybe<ConditionGroupConditionsConditionGroupFieldInput>;
};

export type ConditionGroupConditionsDeleteInput = {
  Condition?: InputMaybe<Array<ConditionGroupConditionsConditionDeleteFieldInput>>;
  ConditionGroup?: InputMaybe<Array<ConditionGroupConditionsConditionGroupDeleteFieldInput>>;
};

export type ConditionGroupConditionsDisconnectInput = {
  Condition?: InputMaybe<Array<ConditionGroupConditionsConditionDisconnectFieldInput>>;
  ConditionGroup?: InputMaybe<Array<ConditionGroupConditionsConditionGroupDisconnectFieldInput>>;
};

export type ConditionGroupConditionsRelationship = {
  __typename?: 'ConditionGroupConditionsRelationship';
  cursor: Scalars['String']['output'];
  node: Conditions;
};

export type ConditionGroupConditionsUpdateInput = {
  Condition?: InputMaybe<Array<ConditionGroupConditionsConditionUpdateFieldInput>>;
  ConditionGroup?: InputMaybe<Array<ConditionGroupConditionsConditionGroupUpdateFieldInput>>;
};

export type ConditionGroupConnectInput = {
  conditions?: InputMaybe<ConditionGroupConditionsConnectInput>;
};

export type ConditionGroupConnectWhere = {
  node: ConditionGroupWhere;
};

export type ConditionGroupCreateInput = {
  conditions?: InputMaybe<ConditionGroupConditionsCreateInput>;
  label?: InputMaybe<Scalars['String']['input']>;
  order: ConditionLogic;
};

export type ConditionGroupDeleteInput = {
  conditions?: InputMaybe<ConditionGroupConditionsDeleteInput>;
};

export type ConditionGroupDisconnectInput = {
  conditions?: InputMaybe<ConditionGroupConditionsDisconnectInput>;
};

export type ConditionGroupEdge = {
  __typename?: 'ConditionGroupEdge';
  cursor: Scalars['String']['output'];
  node: ConditionGroup;
};

export type ConditionGroupInput = {
  conditions: Array<ConditionsInput>;
  label?: InputMaybe<Scalars['String']['input']>;
  order: ConditionLogic;
};

export type ConditionGroupOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more ConditionGroupSort objects to sort ConditionGroups by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ConditionGroupSort>>;
};

export type ConditionGroupRelationInput = {
  conditions?: InputMaybe<ConditionGroupConditionsCreateFieldInput>;
};

/** Fields to sort ConditionGroups by. The order in which sorts are applied is not guaranteed when specifying many fields in one ConditionGroupSort object. */
export type ConditionGroupSort = {
  label?: InputMaybe<SortDirection>;
  order?: InputMaybe<SortDirection>;
};

export type ConditionGroupUpdateInput = {
  conditions?: InputMaybe<ConditionGroupConditionsUpdateInput>;
  label?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<ConditionLogic>;
};

export type ConditionGroupWhere = {
  AND?: InputMaybe<Array<ConditionGroupWhere>>;
  NOT?: InputMaybe<ConditionGroupWhere>;
  OR?: InputMaybe<Array<ConditionGroupWhere>>;
  /** Return ConditionGroups where all of the related ConditionGroupConditionsConnections match this filter */
  conditionsConnection_ALL?: InputMaybe<ConditionGroupConditionsConnectionWhere>;
  /** Return ConditionGroups where none of the related ConditionGroupConditionsConnections match this filter */
  conditionsConnection_NONE?: InputMaybe<ConditionGroupConditionsConnectionWhere>;
  /** Return ConditionGroups where one of the related ConditionGroupConditionsConnections match this filter */
  conditionsConnection_SINGLE?: InputMaybe<ConditionGroupConditionsConnectionWhere>;
  /** Return ConditionGroups where some of the related ConditionGroupConditionsConnections match this filter */
  conditionsConnection_SOME?: InputMaybe<ConditionGroupConditionsConnectionWhere>;
  /** Return ConditionGroups where all of the related Conditions match this filter */
  conditions_ALL?: InputMaybe<ConditionsWhere>;
  /** Return ConditionGroups where none of the related Conditions match this filter */
  conditions_NONE?: InputMaybe<ConditionsWhere>;
  /** Return ConditionGroups where one of the related Conditions match this filter */
  conditions_SINGLE?: InputMaybe<ConditionsWhere>;
  /** Return ConditionGroups where some of the related Conditions match this filter */
  conditions_SOME?: InputMaybe<ConditionsWhere>;
  label?: InputMaybe<Scalars['String']['input']>;
  label_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  label_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  label_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  label_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<ConditionLogic>;
  order_IN?: InputMaybe<Array<ConditionLogic>>;
};

export type ConditionGroupsConnection = {
  __typename?: 'ConditionGroupsConnection';
  edges: Array<ConditionGroupEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type ConditionInput = {
  comparator: ConditionComparison;
  value: Scalars['String']['input'];
  var: Scalars['String']['input'];
};

export enum ConditionLogic {
  And = 'And',
  Or = 'Or'
}

export type ConditionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more ConditionSort objects to sort Conditions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ConditionSort>>;
};

/** Fields to sort Conditions by. The order in which sorts are applied is not guaranteed when specifying many fields in one ConditionSort object. */
export type ConditionSort = {
  comparator?: InputMaybe<SortDirection>;
  value?: InputMaybe<SortDirection>;
  var?: InputMaybe<SortDirection>;
};

export type ConditionUpdateInput = {
  comparator?: InputMaybe<ConditionComparison>;
  value?: InputMaybe<Scalars['String']['input']>;
  var?: InputMaybe<Scalars['String']['input']>;
};

export type ConditionWhere = {
  AND?: InputMaybe<Array<ConditionWhere>>;
  NOT?: InputMaybe<ConditionWhere>;
  OR?: InputMaybe<Array<ConditionWhere>>;
  comparator?: InputMaybe<ConditionComparison>;
  comparator_IN?: InputMaybe<Array<ConditionComparison>>;
  value?: InputMaybe<Scalars['String']['input']>;
  value_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  value_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  value_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  value_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  var?: InputMaybe<Scalars['String']['input']>;
  var_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  var_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  var_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  var_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type Conditions = Condition | ConditionGroup;

export type ConditionsConnection = {
  __typename?: 'ConditionsConnection';
  edges: Array<ConditionEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type ConditionsInput = {
  condition?: InputMaybe<ConditionInput>;
  group?: InputMaybe<ConditionGroupInput>;
  type: ConditionsInputType;
};

export enum ConditionsInputType {
  Condition = 'Condition',
  Group = 'Group'
}

export type ConditionsWhere = {
  Condition?: InputMaybe<ConditionWhere>;
  ConditionGroup?: InputMaybe<ConditionGroupWhere>;
};

export type Configuration = {
  __typename?: 'Configuration';
  dashboardLayout?: Maybe<Scalars['String']['output']>;
  doctor: Doctor;
  doctorAggregate?: Maybe<ConfigurationDoctorDoctorAggregationSelection>;
  doctorConnection: ConfigurationDoctorConnection;
  id: Scalars['ID']['output'];
  institution: Institution;
  institutionAggregate?: Maybe<ConfigurationInstitutionInstitutionAggregationSelection>;
  institutionConnection: ConfigurationInstitutionConnection;
};


export type ConfigurationDoctorArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<DoctorOptions>;
  where?: InputMaybe<DoctorWhere>;
};


export type ConfigurationDoctorAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<DoctorWhere>;
};


export type ConfigurationDoctorConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<ConfigurationDoctorConnectionSort>>;
  where?: InputMaybe<ConfigurationDoctorConnectionWhere>;
};


export type ConfigurationInstitutionArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<InstitutionOptions>;
  where?: InputMaybe<InstitutionWhere>;
};


export type ConfigurationInstitutionAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<InstitutionWhere>;
};


export type ConfigurationInstitutionConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<ConfigurationInstitutionConnectionSort>>;
  where?: InputMaybe<ConfigurationInstitutionConnectionWhere>;
};

export type ConfigurationAggregateSelection = {
  __typename?: 'ConfigurationAggregateSelection';
  count: Scalars['Int']['output'];
  dashboardLayout: StringAggregateSelection;
  id: IdAggregateSelection;
};

export type ConfigurationConnectInput = {
  doctor?: InputMaybe<ConfigurationDoctorConnectFieldInput>;
  institution?: InputMaybe<ConfigurationInstitutionConnectFieldInput>;
};

export type ConfigurationConnectOrCreateInput = {
  doctor?: InputMaybe<ConfigurationDoctorConnectOrCreateFieldInput>;
  institution?: InputMaybe<ConfigurationInstitutionConnectOrCreateFieldInput>;
};

export type ConfigurationConnectOrCreateWhere = {
  node: ConfigurationUniqueWhere;
};

export type ConfigurationConnectWhere = {
  node: ConfigurationWhere;
};

export type ConfigurationCreateInput = {
  dashboardLayout?: InputMaybe<Scalars['String']['input']>;
  doctor?: InputMaybe<ConfigurationDoctorFieldInput>;
  institution?: InputMaybe<ConfigurationInstitutionFieldInput>;
};

export type ConfigurationDeleteInput = {
  doctor?: InputMaybe<ConfigurationDoctorDeleteFieldInput>;
  institution?: InputMaybe<ConfigurationInstitutionDeleteFieldInput>;
};

export type ConfigurationDisconnectInput = {
  doctor?: InputMaybe<ConfigurationDoctorDisconnectFieldInput>;
  institution?: InputMaybe<ConfigurationInstitutionDisconnectFieldInput>;
};

export type ConfigurationDoctorAggregateInput = {
  AND?: InputMaybe<Array<ConfigurationDoctorAggregateInput>>;
  NOT?: InputMaybe<ConfigurationDoctorAggregateInput>;
  OR?: InputMaybe<Array<ConfigurationDoctorAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<ConfigurationDoctorNodeAggregationWhereInput>;
};

export type ConfigurationDoctorConnectFieldInput = {
  connect?: InputMaybe<DoctorConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<DoctorConnectWhere>;
};

export type ConfigurationDoctorConnectOrCreateFieldInput = {
  onCreate: ConfigurationDoctorConnectOrCreateFieldInputOnCreate;
  where: DoctorConnectOrCreateWhere;
};

export type ConfigurationDoctorConnectOrCreateFieldInputOnCreate = {
  node: DoctorOnCreateInput;
};

export type ConfigurationDoctorConnection = {
  __typename?: 'ConfigurationDoctorConnection';
  edges: Array<ConfigurationDoctorRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type ConfigurationDoctorConnectionSort = {
  node?: InputMaybe<DoctorSort>;
};

export type ConfigurationDoctorConnectionWhere = {
  AND?: InputMaybe<Array<ConfigurationDoctorConnectionWhere>>;
  NOT?: InputMaybe<ConfigurationDoctorConnectionWhere>;
  OR?: InputMaybe<Array<ConfigurationDoctorConnectionWhere>>;
  node?: InputMaybe<DoctorWhere>;
};

export type ConfigurationDoctorCreateFieldInput = {
  node: DoctorCreateInput;
};

export type ConfigurationDoctorDeleteFieldInput = {
  delete?: InputMaybe<DoctorDeleteInput>;
  where?: InputMaybe<ConfigurationDoctorConnectionWhere>;
};

export type ConfigurationDoctorDisconnectFieldInput = {
  disconnect?: InputMaybe<DoctorDisconnectInput>;
  where?: InputMaybe<ConfigurationDoctorConnectionWhere>;
};

export type ConfigurationDoctorDoctorAggregationSelection = {
  __typename?: 'ConfigurationDoctorDoctorAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<ConfigurationDoctorDoctorNodeAggregateSelection>;
};

export type ConfigurationDoctorDoctorNodeAggregateSelection = {
  __typename?: 'ConfigurationDoctorDoctorNodeAggregateSelection';
  email: StringAggregateSelection;
  firstName: StringAggregateSelection;
  firstNameNormalized: StringAggregateSelection;
  id: IdAggregateSelection;
  lastName: StringAggregateSelection;
  lastNameNormalized: StringAggregateSelection;
  phone: StringAggregateSelection;
  rpps: StringAggregateSelection;
};

export type ConfigurationDoctorFieldInput = {
  connect?: InputMaybe<ConfigurationDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<ConfigurationDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<ConfigurationDoctorCreateFieldInput>;
};

export type ConfigurationDoctorNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ConfigurationDoctorNodeAggregationWhereInput>>;
  NOT?: InputMaybe<ConfigurationDoctorNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<ConfigurationDoctorNodeAggregationWhereInput>>;
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  phone_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  rpps_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type ConfigurationDoctorRelationship = {
  __typename?: 'ConfigurationDoctorRelationship';
  cursor: Scalars['String']['output'];
  node: Doctor;
};

export type ConfigurationDoctorUpdateConnectionInput = {
  node?: InputMaybe<DoctorUpdateInput>;
};

export type ConfigurationDoctorUpdateFieldInput = {
  connect?: InputMaybe<ConfigurationDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<ConfigurationDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<ConfigurationDoctorCreateFieldInput>;
  delete?: InputMaybe<ConfigurationDoctorDeleteFieldInput>;
  disconnect?: InputMaybe<ConfigurationDoctorDisconnectFieldInput>;
  update?: InputMaybe<ConfigurationDoctorUpdateConnectionInput>;
  where?: InputMaybe<ConfigurationDoctorConnectionWhere>;
};

export type ConfigurationEdge = {
  __typename?: 'ConfigurationEdge';
  cursor: Scalars['String']['output'];
  node: Configuration;
};

export type ConfigurationInstitutionAggregateInput = {
  AND?: InputMaybe<Array<ConfigurationInstitutionAggregateInput>>;
  NOT?: InputMaybe<ConfigurationInstitutionAggregateInput>;
  OR?: InputMaybe<Array<ConfigurationInstitutionAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<ConfigurationInstitutionNodeAggregationWhereInput>;
};

export type ConfigurationInstitutionConnectFieldInput = {
  connect?: InputMaybe<InstitutionConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<InstitutionConnectWhere>;
};

export type ConfigurationInstitutionConnectOrCreateFieldInput = {
  onCreate: ConfigurationInstitutionConnectOrCreateFieldInputOnCreate;
  where: InstitutionConnectOrCreateWhere;
};

export type ConfigurationInstitutionConnectOrCreateFieldInputOnCreate = {
  node: InstitutionOnCreateInput;
};

export type ConfigurationInstitutionConnection = {
  __typename?: 'ConfigurationInstitutionConnection';
  edges: Array<ConfigurationInstitutionRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type ConfigurationInstitutionConnectionSort = {
  node?: InputMaybe<InstitutionSort>;
};

export type ConfigurationInstitutionConnectionWhere = {
  AND?: InputMaybe<Array<ConfigurationInstitutionConnectionWhere>>;
  NOT?: InputMaybe<ConfigurationInstitutionConnectionWhere>;
  OR?: InputMaybe<Array<ConfigurationInstitutionConnectionWhere>>;
  node?: InputMaybe<InstitutionWhere>;
};

export type ConfigurationInstitutionCreateFieldInput = {
  node: InstitutionCreateInput;
};

export type ConfigurationInstitutionDeleteFieldInput = {
  delete?: InputMaybe<InstitutionDeleteInput>;
  where?: InputMaybe<ConfigurationInstitutionConnectionWhere>;
};

export type ConfigurationInstitutionDisconnectFieldInput = {
  disconnect?: InputMaybe<InstitutionDisconnectInput>;
  where?: InputMaybe<ConfigurationInstitutionConnectionWhere>;
};

export type ConfigurationInstitutionFieldInput = {
  connect?: InputMaybe<ConfigurationInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<ConfigurationInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<ConfigurationInstitutionCreateFieldInput>;
};

export type ConfigurationInstitutionInstitutionAggregationSelection = {
  __typename?: 'ConfigurationInstitutionInstitutionAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<ConfigurationInstitutionInstitutionNodeAggregateSelection>;
};

export type ConfigurationInstitutionInstitutionNodeAggregateSelection = {
  __typename?: 'ConfigurationInstitutionInstitutionNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type ConfigurationInstitutionNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ConfigurationInstitutionNodeAggregationWhereInput>>;
  NOT?: InputMaybe<ConfigurationInstitutionNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<ConfigurationInstitutionNodeAggregationWhereInput>>;
  nameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type ConfigurationInstitutionRelationship = {
  __typename?: 'ConfigurationInstitutionRelationship';
  cursor: Scalars['String']['output'];
  node: Institution;
};

export type ConfigurationInstitutionUpdateConnectionInput = {
  node?: InputMaybe<InstitutionUpdateInput>;
};

export type ConfigurationInstitutionUpdateFieldInput = {
  connect?: InputMaybe<ConfigurationInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<ConfigurationInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<ConfigurationInstitutionCreateFieldInput>;
  delete?: InputMaybe<ConfigurationInstitutionDeleteFieldInput>;
  disconnect?: InputMaybe<ConfigurationInstitutionDisconnectFieldInput>;
  update?: InputMaybe<ConfigurationInstitutionUpdateConnectionInput>;
  where?: InputMaybe<ConfigurationInstitutionConnectionWhere>;
};

export type ConfigurationOnCreateInput = {
  dashboardLayout?: InputMaybe<Scalars['String']['input']>;
};

export type ConfigurationOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more ConfigurationSort objects to sort Configurations by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ConfigurationSort>>;
};

export type ConfigurationRelationInput = {
  doctor?: InputMaybe<ConfigurationDoctorCreateFieldInput>;
  institution?: InputMaybe<ConfigurationInstitutionCreateFieldInput>;
};

/** Fields to sort Configurations by. The order in which sorts are applied is not guaranteed when specifying many fields in one ConfigurationSort object. */
export type ConfigurationSort = {
  dashboardLayout?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
};

export type ConfigurationUniqueWhere = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type ConfigurationUpdateInput = {
  dashboardLayout?: InputMaybe<Scalars['String']['input']>;
  doctor?: InputMaybe<ConfigurationDoctorUpdateFieldInput>;
  institution?: InputMaybe<ConfigurationInstitutionUpdateFieldInput>;
};

export type ConfigurationWhere = {
  AND?: InputMaybe<Array<ConfigurationWhere>>;
  NOT?: InputMaybe<ConfigurationWhere>;
  OR?: InputMaybe<Array<ConfigurationWhere>>;
  dashboardLayout?: InputMaybe<Scalars['String']['input']>;
  dashboardLayout_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  dashboardLayout_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  dashboardLayout_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dashboardLayout_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  doctor?: InputMaybe<DoctorWhere>;
  doctorAggregate?: InputMaybe<ConfigurationDoctorAggregateInput>;
  doctorConnection?: InputMaybe<ConfigurationDoctorConnectionWhere>;
  doctorConnection_NOT?: InputMaybe<ConfigurationDoctorConnectionWhere>;
  doctor_NOT?: InputMaybe<DoctorWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  institution?: InputMaybe<InstitutionWhere>;
  institutionAggregate?: InputMaybe<ConfigurationInstitutionAggregateInput>;
  institutionConnection?: InputMaybe<ConfigurationInstitutionConnectionWhere>;
  institutionConnection_NOT?: InputMaybe<ConfigurationInstitutionConnectionWhere>;
  institution_NOT?: InputMaybe<InstitutionWhere>;
};

export type ConfigurationsConnection = {
  __typename?: 'ConfigurationsConnection';
  edges: Array<ConfigurationEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Cooldown = {
  __typename?: 'Cooldown';
  duration: CooldownDuration;
  value: Scalars['Int']['output'];
};

export type CooldownAggregateSelection = {
  __typename?: 'CooldownAggregateSelection';
  count: Scalars['Int']['output'];
  value: IntAggregateSelection;
};

export type CooldownConnectWhere = {
  node: CooldownWhere;
};

export type CooldownCreateInput = {
  duration: CooldownDuration;
  value: Scalars['Int']['input'];
};

export enum CooldownDuration {
  Day = 'Day',
  Month = 'Month',
  Week = 'Week',
  Year = 'Year'
}

export type CooldownEdge = {
  __typename?: 'CooldownEdge';
  cursor: Scalars['String']['output'];
  node: Cooldown;
};

export type CooldownInput = {
  duration: CooldownDuration;
  value: Scalars['Int']['input'];
};

export type CooldownOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more CooldownSort objects to sort Cooldowns by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<CooldownSort>>;
};

/** Fields to sort Cooldowns by. The order in which sorts are applied is not guaranteed when specifying many fields in one CooldownSort object. */
export type CooldownSort = {
  duration?: InputMaybe<SortDirection>;
  value?: InputMaybe<SortDirection>;
};

export type CooldownUpdateInput = {
  duration?: InputMaybe<CooldownDuration>;
  value?: InputMaybe<Scalars['Int']['input']>;
  value_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  value_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
};

export type CooldownWhere = {
  AND?: InputMaybe<Array<CooldownWhere>>;
  NOT?: InputMaybe<CooldownWhere>;
  OR?: InputMaybe<Array<CooldownWhere>>;
  duration?: InputMaybe<CooldownDuration>;
  duration_IN?: InputMaybe<Array<CooldownDuration>>;
  value?: InputMaybe<Scalars['Int']['input']>;
  value_GT?: InputMaybe<Scalars['Int']['input']>;
  value_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_IN?: InputMaybe<Array<Scalars['Int']['input']>>;
  value_LT?: InputMaybe<Scalars['Int']['input']>;
  value_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type CooldownsConnection = {
  __typename?: 'CooldownsConnection';
  edges: Array<CooldownEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export enum CountryCode {
  Ad = 'AD',
  Ae = 'AE',
  Af = 'AF',
  Ag = 'AG',
  Ai = 'AI',
  Al = 'AL',
  Am = 'AM',
  An = 'AN',
  Ao = 'AO',
  Aq = 'AQ',
  Ar = 'AR',
  As = 'AS',
  At = 'AT',
  Au = 'AU',
  Aw = 'AW',
  Az = 'AZ',
  Ba = 'BA',
  Bb = 'BB',
  Bd = 'BD',
  Be = 'BE',
  Bf = 'BF',
  Bg = 'BG',
  Bh = 'BH',
  Bi = 'BI',
  Bj = 'BJ',
  Bm = 'BM',
  Bn = 'BN',
  Bo = 'BO',
  Br = 'BR',
  Bs = 'BS',
  Bt = 'BT',
  Bv = 'BV',
  Bw = 'BW',
  By = 'BY',
  Bz = 'BZ',
  Ca = 'CA',
  Cc = 'CC',
  Cd = 'CD',
  Cf = 'CF',
  Cg = 'CG',
  Ch = 'CH',
  Ci = 'CI',
  Ck = 'CK',
  Cl = 'CL',
  Cm = 'CM',
  Cn = 'CN',
  Co = 'CO',
  Cr = 'CR',
  Cu = 'CU',
  Cv = 'CV',
  Cx = 'CX',
  Cy = 'CY',
  Cz = 'CZ',
  De = 'DE',
  Dj = 'DJ',
  Dk = 'DK',
  Dm = 'DM',
  Do = 'DO',
  Dz = 'DZ',
  Ec = 'EC',
  Ee = 'EE',
  Eg = 'EG',
  Eh = 'EH',
  Er = 'ER',
  Es = 'ES',
  Et = 'ET',
  Fi = 'FI',
  Fj = 'FJ',
  Fk = 'FK',
  Fm = 'FM',
  Fo = 'FO',
  Fr = 'FR',
  Ga = 'GA',
  Gb = 'GB',
  Gd = 'GD',
  Ge = 'GE',
  Gf = 'GF',
  Gg = 'GG',
  Gh = 'GH',
  Gi = 'GI',
  Gl = 'GL',
  Gm = 'GM',
  Gn = 'GN',
  Gp = 'GP',
  Gq = 'GQ',
  Gr = 'GR',
  Gs = 'GS',
  Gt = 'GT',
  Gu = 'GU',
  Gw = 'GW',
  Gy = 'GY',
  Hk = 'HK',
  Hm = 'HM',
  Hn = 'HN',
  Hr = 'HR',
  Ht = 'HT',
  Hu = 'HU',
  Id = 'ID',
  Ie = 'IE',
  Il = 'IL',
  Im = 'IM',
  In = 'IN',
  Io = 'IO',
  Iq = 'IQ',
  Ir = 'IR',
  Is = 'IS',
  It = 'IT',
  Je = 'JE',
  Jm = 'JM',
  Jo = 'JO',
  Jp = 'JP',
  Ke = 'KE',
  Kg = 'KG',
  Kh = 'KH',
  Ki = 'KI',
  Km = 'KM',
  Kn = 'KN',
  Kp = 'KP',
  Kr = 'KR',
  Kw = 'KW',
  Ky = 'KY',
  Kz = 'KZ',
  La = 'LA',
  Lb = 'LB',
  Lc = 'LC',
  Li = 'LI',
  Lk = 'LK',
  Lr = 'LR',
  Ls = 'LS',
  Lt = 'LT',
  Lu = 'LU',
  Lv = 'LV',
  Ly = 'LY',
  Ma = 'MA',
  Mc = 'MC',
  Md = 'MD',
  Me = 'ME',
  Mg = 'MG',
  Mh = 'MH',
  Mk = 'MK',
  Ml = 'ML',
  Mm = 'MM',
  Mn = 'MN',
  Mo = 'MO',
  Mp = 'MP',
  Mq = 'MQ',
  Mr = 'MR',
  Ms = 'MS',
  Mt = 'MT',
  Mu = 'MU',
  Mv = 'MV',
  Mw = 'MW',
  Mx = 'MX',
  My = 'MY',
  Mz = 'MZ',
  Na = 'NA',
  Nc = 'NC',
  Ne = 'NE',
  Nf = 'NF',
  Ng = 'NG',
  Ni = 'NI',
  Nl = 'NL',
  No = 'NO',
  Np = 'NP',
  Nr = 'NR',
  Nu = 'NU',
  Nz = 'NZ',
  Om = 'OM',
  Pa = 'PA',
  Pe = 'PE',
  Pf = 'PF',
  Pg = 'PG',
  Ph = 'PH',
  Pk = 'PK',
  Pl = 'PL',
  Pm = 'PM',
  Pn = 'PN',
  Pr = 'PR',
  Ps = 'PS',
  Pt = 'PT',
  Pw = 'PW',
  Py = 'PY',
  Qa = 'QA',
  Re = 'RE',
  Ro = 'RO',
  Rs = 'RS',
  Ru = 'RU',
  Rw = 'RW',
  Sa = 'SA',
  Sb = 'SB',
  Sc = 'SC',
  Sd = 'SD',
  Se = 'SE',
  Sg = 'SG',
  Sh = 'SH',
  Si = 'SI',
  Sj = 'SJ',
  Sk = 'SK',
  Sl = 'SL',
  Sm = 'SM',
  Sn = 'SN',
  So = 'SO',
  Sr = 'SR',
  St = 'ST',
  Sv = 'SV',
  Sy = 'SY',
  Sz = 'SZ',
  Tc = 'TC',
  Td = 'TD',
  Tf = 'TF',
  Tg = 'TG',
  Th = 'TH',
  Tj = 'TJ',
  Tk = 'TK',
  Tl = 'TL',
  Tm = 'TM',
  Tn = 'TN',
  To = 'TO',
  Tr = 'TR',
  Tt = 'TT',
  Tv = 'TV',
  Tw = 'TW',
  Tz = 'TZ',
  Ua = 'UA',
  Ug = 'UG',
  Um = 'UM',
  Us = 'US',
  Uy = 'UY',
  Uz = 'UZ',
  Va = 'VA',
  Vc = 'VC',
  Ve = 'VE',
  Vg = 'VG',
  Vi = 'VI',
  Vn = 'VN',
  Vu = 'VU',
  Wf = 'WF',
  Ws = 'WS',
  Ye = 'YE',
  Yt = 'YT',
  Za = 'ZA',
  Zm = 'ZM',
  Zw = 'ZW'
}

export type CreateAiResponsesMutationResponse = {
  __typename?: 'CreateAiResponsesMutationResponse';
  aiResponses: Array<AiResponse>;
  info: CreateInfo;
};

export type CreateAlertGroupsMutationResponse = {
  __typename?: 'CreateAlertGroupsMutationResponse';
  alertGroups: Array<AlertGroup>;
  info: CreateInfo;
};

export type CreateAlertsMutationResponse = {
  __typename?: 'CreateAlertsMutationResponse';
  alerts: Array<Alert>;
  info: CreateInfo;
};

export type CreateAnswersMutationResponse = {
  __typename?: 'CreateAnswersMutationResponse';
  answers: Array<Answer>;
  info: CreateInfo;
};

export type CreateCheckboxQuestionsMutationResponse = {
  __typename?: 'CreateCheckboxQuestionsMutationResponse';
  checkboxQuestions: Array<CheckboxQuestion>;
  info: CreateInfo;
};

export type CreateConditionGroupsMutationResponse = {
  __typename?: 'CreateConditionGroupsMutationResponse';
  conditionGroups: Array<ConditionGroup>;
  info: CreateInfo;
};

export type CreateConditionsMutationResponse = {
  __typename?: 'CreateConditionsMutationResponse';
  conditions: Array<Condition>;
  info: CreateInfo;
};

export type CreateConfigurationsMutationResponse = {
  __typename?: 'CreateConfigurationsMutationResponse';
  configurations: Array<Configuration>;
  info: CreateInfo;
};

export type CreateCooldownsMutationResponse = {
  __typename?: 'CreateCooldownsMutationResponse';
  cooldowns: Array<Cooldown>;
  info: CreateInfo;
};

export type CreateDateQuestionsMutationResponse = {
  __typename?: 'CreateDateQuestionsMutationResponse';
  dateQuestions: Array<DateQuestion>;
  info: CreateInfo;
};

export type CreateDeleteInfosMutationResponse = {
  __typename?: 'CreateDeleteInfosMutationResponse';
  deleteInfos: Array<DeleteInfo>;
  info: CreateInfo;
};

export type CreateDevicesMutationResponse = {
  __typename?: 'CreateDevicesMutationResponse';
  devices: Array<Device>;
  info: CreateInfo;
};

export type CreateDocumentsMutationResponse = {
  __typename?: 'CreateDocumentsMutationResponse';
  documents: Array<Document>;
  info: CreateInfo;
};

/** Information about the number of nodes and relationships created during a create mutation */
export type CreateInfo = {
  __typename?: 'CreateInfo';
  nodesCreated: Scalars['Int']['output'];
  relationshipsCreated: Scalars['Int']['output'];
};

export type CreateInstitutionsMutationResponse = {
  __typename?: 'CreateInstitutionsMutationResponse';
  info: CreateInfo;
  institutions: Array<Institution>;
};

export type CreateInterviewsMutationResponse = {
  __typename?: 'CreateInterviewsMutationResponse';
  info: CreateInfo;
  interviews: Array<Interview>;
};

export type CreateInvoicesMutationResponse = {
  __typename?: 'CreateInvoicesMutationResponse';
  info: CreateInfo;
  invoices: Array<Invoice>;
};

export type CreatePatientsMutationResponse = {
  __typename?: 'CreatePatientsMutationResponse';
  info: CreateInfo;
  patients: Array<Patient>;
};

export type CreatePdfDocumentsMutationResponse = {
  __typename?: 'CreatePdfDocumentsMutationResponse';
  info: CreateInfo;
  pdfDocuments: Array<PdfDocument>;
};

export type CreatePostalAddressesMutationResponse = {
  __typename?: 'CreatePostalAddressesMutationResponse';
  info: CreateInfo;
  postalAddresses: Array<PostalAddress>;
};

export type CreateQuestionItemsMutationResponse = {
  __typename?: 'CreateQuestionItemsMutationResponse';
  info: CreateInfo;
  questionItems: Array<QuestionItem>;
};

export type CreateQuestionnaireAisMutationResponse = {
  __typename?: 'CreateQuestionnaireAisMutationResponse';
  info: CreateInfo;
  questionnaireAis: Array<QuestionnaireAi>;
};

export type CreateQuestionnaireAlertsMutationResponse = {
  __typename?: 'CreateQuestionnaireAlertsMutationResponse';
  info: CreateInfo;
  questionnaireAlerts: Array<QuestionnaireAlerts>;
};

export type CreateQuestionnaireAppointmentDatesMutationResponse = {
  __typename?: 'CreateQuestionnaireAppointmentDatesMutationResponse';
  info: CreateInfo;
  questionnaireAppointmentDates: Array<QuestionnaireAppointmentDate>;
};

export type CreateQuestionnaireConditionsMutationResponse = {
  __typename?: 'CreateQuestionnaireConditionsMutationResponse';
  info: CreateInfo;
  questionnaireConditions: Array<QuestionnaireCondition>;
};

export type CreateQuestionnaireDocumentFillersMutationResponse = {
  __typename?: 'CreateQuestionnaireDocumentFillersMutationResponse';
  info: CreateInfo;
  questionnaireDocumentFillers: Array<QuestionnaireDocumentFiller>;
};

export type CreateQuestionnaireDocumentsMutationResponse = {
  __typename?: 'CreateQuestionnaireDocumentsMutationResponse';
  info: CreateInfo;
  questionnaireDocuments: Array<QuestionnaireDocument>;
};

export type CreateQuestionnaireIdentitiesMutationResponse = {
  __typename?: 'CreateQuestionnaireIdentitiesMutationResponse';
  info: CreateInfo;
  questionnaireIdentities: Array<QuestionnaireIdentity>;
};

export type CreateQuestionnaireInfoStepsMutationResponse = {
  __typename?: 'CreateQuestionnaireInfoStepsMutationResponse';
  info: CreateInfo;
  questionnaireInfoSteps: Array<QuestionnaireInfoStep>;
};

export type CreateQuestionnaireInterviewsMutationResponse = {
  __typename?: 'CreateQuestionnaireInterviewsMutationResponse';
  info: CreateInfo;
  questionnaireInterviews: Array<QuestionnaireInterview>;
};

export type CreateQuestionnaireMenuEntriesMutationResponse = {
  __typename?: 'CreateQuestionnaireMenuEntriesMutationResponse';
  info: CreateInfo;
  questionnaireMenuEntries: Array<QuestionnaireMenuEntry>;
};

export type CreateQuestionnaireMenuItemsMutationResponse = {
  __typename?: 'CreateQuestionnaireMenuItemsMutationResponse';
  info: CreateInfo;
  questionnaireMenuItems: Array<QuestionnaireMenuItem>;
};

export type CreateQuestionnaireMenusMutationResponse = {
  __typename?: 'CreateQuestionnaireMenusMutationResponse';
  info: CreateInfo;
  questionnaireMenus: Array<QuestionnaireMenu>;
};

export type CreateQuestionnaireRoutersMutationResponse = {
  __typename?: 'CreateQuestionnaireRoutersMutationResponse';
  info: CreateInfo;
  questionnaireRouters: Array<QuestionnaireRouter>;
};

export type CreateQuestionnaireSelectMenusMutationResponse = {
  __typename?: 'CreateQuestionnaireSelectMenusMutationResponse';
  info: CreateInfo;
  questionnaireSelectMenus: Array<QuestionnaireSelectMenu>;
};

export type CreateQuestionnaireSetPropertiesMutationResponse = {
  __typename?: 'CreateQuestionnaireSetPropertiesMutationResponse';
  info: CreateInfo;
  questionnaireSetProperties: Array<QuestionnaireSetProperty>;
};

export type CreateQuestionnaireSurveysMutationResponse = {
  __typename?: 'CreateQuestionnaireSurveysMutationResponse';
  info: CreateInfo;
  questionnaireSurveys: Array<QuestionnaireSurvey>;
};

export type CreateQuestionnaireThirdPartiesMutationResponse = {
  __typename?: 'CreateQuestionnaireThirdPartiesMutationResponse';
  info: CreateInfo;
  questionnaireThirdParties: Array<QuestionnaireThirdParty>;
};

export type CreateQuestionnaireWelcomeStepsMutationResponse = {
  __typename?: 'CreateQuestionnaireWelcomeStepsMutationResponse';
  info: CreateInfo;
  questionnaireWelcomeSteps: Array<QuestionnaireWelcomeStep>;
};

export type CreateQuestionnairesMutationResponse = {
  __typename?: 'CreateQuestionnairesMutationResponse';
  info: CreateInfo;
  questionnaires: Array<Questionnaire>;
};

export type CreateQuotingsMutationResponse = {
  __typename?: 'CreateQuotingsMutationResponse';
  info: CreateInfo;
  quotings: Array<Quoting>;
};

export type CreateRadioQuestionsMutationResponse = {
  __typename?: 'CreateRadioQuestionsMutationResponse';
  info: CreateInfo;
  radioQuestions: Array<RadioQuestion>;
};

export type CreateRangeQuestionsMutationResponse = {
  __typename?: 'CreateRangeQuestionsMutationResponse';
  info: CreateInfo;
  rangeQuestions: Array<RangeQuestion>;
};

export type CreateSearchQuestionResultsMutationResponse = {
  __typename?: 'CreateSearchQuestionResultsMutationResponse';
  info: CreateInfo;
  searchQuestionResults: Array<SearchQuestionResult>;
};

export type CreateSelectQuestionsMutationResponse = {
  __typename?: 'CreateSelectQuestionsMutationResponse';
  info: CreateInfo;
  selectQuestions: Array<SelectQuestion>;
};

export type CreateSerializationNodesMutationResponse = {
  __typename?: 'CreateSerializationNodesMutationResponse';
  info: CreateInfo;
  serializationNodes: Array<SerializationNode>;
};

export type CreateSerializationSocketsMutationResponse = {
  __typename?: 'CreateSerializationSocketsMutationResponse';
  info: CreateInfo;
  serializationSockets: Array<SerializationSocket>;
};

export type CreateSpecialitiesMutationResponse = {
  __typename?: 'CreateSpecialitiesMutationResponse';
  info: CreateInfo;
  specialities: Array<Speciality>;
};

export type CreateTextQuestionsMutationResponse = {
  __typename?: 'CreateTextQuestionsMutationResponse';
  info: CreateInfo;
  textQuestions: Array<TextQuestion>;
};

export type CreateUnserializationResponsesMutationResponse = {
  __typename?: 'CreateUnserializationResponsesMutationResponse';
  info: CreateInfo;
  unserializationResponses: Array<UnserializationResponse>;
};

export type CreateVersionnedGraphsMutationResponse = {
  __typename?: 'CreateVersionnedGraphsMutationResponse';
  info: CreateInfo;
  versionnedGraphs: Array<VersionnedGraph>;
};

export type CreateWorkflowLinksMutationResponse = {
  __typename?: 'CreateWorkflowLinksMutationResponse';
  info: CreateInfo;
  workflowLinks: Array<WorkflowLink>;
};

export type CreateWorkflowsMutationResponse = {
  __typename?: 'CreateWorkflowsMutationResponse';
  info: CreateInfo;
  workflows: Array<Workflow>;
};

export enum DateFormatType {
  DateAndHour = 'DateAndHour',
  DateOnly = 'DateOnly',
  HourOnly = 'HourOnly'
}

export type DateQuestion = Question & QuestionnaireStep & {
  __typename?: 'DateQuestion';
  alerts?: Maybe<AlertGroup>;
  alertsAggregate?: Maybe<DateQuestionAlertGroupAlertsAggregationSelection>;
  alertsConnection: QuestionAlertsConnection;
  answers: Array<Answer>;
  answersAggregate?: Maybe<DateQuestionAnswerAnswersAggregationSelection>;
  answersConnection: QuestionAnswersConnection;
  cooldown?: Maybe<Cooldown>;
  cooldownAggregate?: Maybe<DateQuestionCooldownCooldownAggregationSelection>;
  cooldownConnection: DateQuestionCooldownConnection;
  dateType?: Maybe<DateFormatType>;
  field?: Maybe<Scalars['String']['output']>;
  graph: VersionnedGraph;
  graphAggregate?: Maybe<DateQuestionVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  hint?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<DateQuestionQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<DateQuestionQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type DateQuestionAlertsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AlertGroupOptions>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type DateQuestionAlertsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type DateQuestionAlertsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};


export type DateQuestionAnswersArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AnswerOptions>;
  where?: InputMaybe<AnswerWhere>;
};


export type DateQuestionAnswersAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AnswerWhere>;
};


export type DateQuestionAnswersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionAnswersConnectionSort>>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};


export type DateQuestionCooldownArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<CooldownOptions>;
  where?: InputMaybe<CooldownWhere>;
};


export type DateQuestionCooldownAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<CooldownWhere>;
};


export type DateQuestionCooldownConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<DateQuestionCooldownConnectionSort>>;
  where?: InputMaybe<DateQuestionCooldownConnectionWhere>;
};


export type DateQuestionGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type DateQuestionGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type DateQuestionGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type DateQuestionNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type DateQuestionNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type DateQuestionNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type DateQuestionPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type DateQuestionPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type DateQuestionPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type DateQuestionAggregateSelection = {
  __typename?: 'DateQuestionAggregateSelection';
  count: Scalars['Int']['output'];
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  id: IdAggregateSelection;
  image: StringAggregateSelection;
  name: StringAggregateSelection;
};

export type DateQuestionAlertGroupAlertsAggregationSelection = {
  __typename?: 'DateQuestionAlertGroupAlertsAggregationSelection';
  count: Scalars['Int']['output'];
};

export type DateQuestionAlertsAggregateInput = {
  AND?: InputMaybe<Array<DateQuestionAlertsAggregateInput>>;
  NOT?: InputMaybe<DateQuestionAlertsAggregateInput>;
  OR?: InputMaybe<Array<DateQuestionAlertsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DateQuestionAlertsConnectFieldInput = {
  connect?: InputMaybe<AlertGroupConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AlertGroupConnectWhere>;
};

export type DateQuestionAlertsCreateFieldInput = {
  node: AlertGroupCreateInput;
};

export type DateQuestionAlertsFieldInput = {
  connect?: InputMaybe<DateQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<DateQuestionAlertsCreateFieldInput>;
};

export type DateQuestionAlertsUpdateConnectionInput = {
  node?: InputMaybe<AlertGroupUpdateInput>;
};

export type DateQuestionAlertsUpdateFieldInput = {
  connect?: InputMaybe<DateQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<DateQuestionAlertsCreateFieldInput>;
  delete?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  update?: InputMaybe<DateQuestionAlertsUpdateConnectionInput>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};

export type DateQuestionAnswerAnswersAggregationSelection = {
  __typename?: 'DateQuestionAnswerAnswersAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<DateQuestionAnswerAnswersNodeAggregateSelection>;
};

export type DateQuestionAnswerAnswersNodeAggregateSelection = {
  __typename?: 'DateQuestionAnswerAnswersNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type DateQuestionAnswersAggregateInput = {
  AND?: InputMaybe<Array<DateQuestionAnswersAggregateInput>>;
  NOT?: InputMaybe<DateQuestionAnswersAggregateInput>;
  OR?: InputMaybe<Array<DateQuestionAnswersAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<DateQuestionAnswersNodeAggregationWhereInput>;
};

export type DateQuestionAnswersConnectFieldInput = {
  connect?: InputMaybe<Array<AnswerConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AnswerConnectWhere>;
};

export type DateQuestionAnswersCreateFieldInput = {
  node: AnswerCreateInput;
};

export type DateQuestionAnswersFieldInput = {
  connect?: InputMaybe<Array<DateQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<DateQuestionAnswersCreateFieldInput>>;
};

export type DateQuestionAnswersNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DateQuestionAnswersNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DateQuestionAnswersNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DateQuestionAnswersNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  field_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  field_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  hint_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DateQuestionAnswersUpdateConnectionInput = {
  node?: InputMaybe<AnswerUpdateInput>;
};

export type DateQuestionAnswersUpdateFieldInput = {
  connect?: InputMaybe<Array<DateQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<DateQuestionAnswersCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  update?: InputMaybe<DateQuestionAnswersUpdateConnectionInput>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};

export type DateQuestionConnectInput = {
  alerts?: InputMaybe<DateQuestionAlertsConnectFieldInput>;
  answers?: InputMaybe<Array<DateQuestionAnswersConnectFieldInput>>;
  cooldown?: InputMaybe<DateQuestionCooldownConnectFieldInput>;
  graph?: InputMaybe<DateQuestionGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<DateQuestionNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<DateQuestionPrevsConnectFieldInput>>;
};

export type DateQuestionCooldownAggregateInput = {
  AND?: InputMaybe<Array<DateQuestionCooldownAggregateInput>>;
  NOT?: InputMaybe<DateQuestionCooldownAggregateInput>;
  OR?: InputMaybe<Array<DateQuestionCooldownAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<DateQuestionCooldownNodeAggregationWhereInput>;
};

export type DateQuestionCooldownConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<CooldownConnectWhere>;
};

export type DateQuestionCooldownConnection = {
  __typename?: 'DateQuestionCooldownConnection';
  edges: Array<DateQuestionCooldownRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type DateQuestionCooldownConnectionSort = {
  node?: InputMaybe<CooldownSort>;
};

export type DateQuestionCooldownConnectionWhere = {
  AND?: InputMaybe<Array<DateQuestionCooldownConnectionWhere>>;
  NOT?: InputMaybe<DateQuestionCooldownConnectionWhere>;
  OR?: InputMaybe<Array<DateQuestionCooldownConnectionWhere>>;
  node?: InputMaybe<CooldownWhere>;
};

export type DateQuestionCooldownCooldownAggregationSelection = {
  __typename?: 'DateQuestionCooldownCooldownAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<DateQuestionCooldownCooldownNodeAggregateSelection>;
};

export type DateQuestionCooldownCooldownNodeAggregateSelection = {
  __typename?: 'DateQuestionCooldownCooldownNodeAggregateSelection';
  value: IntAggregateSelection;
};

export type DateQuestionCooldownCreateFieldInput = {
  node: CooldownCreateInput;
};

export type DateQuestionCooldownDeleteFieldInput = {
  where?: InputMaybe<DateQuestionCooldownConnectionWhere>;
};

export type DateQuestionCooldownDisconnectFieldInput = {
  where?: InputMaybe<DateQuestionCooldownConnectionWhere>;
};

export type DateQuestionCooldownFieldInput = {
  connect?: InputMaybe<DateQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<DateQuestionCooldownCreateFieldInput>;
};

export type DateQuestionCooldownNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DateQuestionCooldownNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DateQuestionCooldownNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DateQuestionCooldownNodeAggregationWhereInput>>;
  value_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  value_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DateQuestionCooldownRelationship = {
  __typename?: 'DateQuestionCooldownRelationship';
  cursor: Scalars['String']['output'];
  node: Cooldown;
};

export type DateQuestionCooldownUpdateConnectionInput = {
  node?: InputMaybe<CooldownUpdateInput>;
};

export type DateQuestionCooldownUpdateFieldInput = {
  connect?: InputMaybe<DateQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<DateQuestionCooldownCreateFieldInput>;
  delete?: InputMaybe<DateQuestionCooldownDeleteFieldInput>;
  disconnect?: InputMaybe<DateQuestionCooldownDisconnectFieldInput>;
  update?: InputMaybe<DateQuestionCooldownUpdateConnectionInput>;
  where?: InputMaybe<DateQuestionCooldownConnectionWhere>;
};

export type DateQuestionCreateInput = {
  alerts?: InputMaybe<DateQuestionAlertsFieldInput>;
  answers?: InputMaybe<DateQuestionAnswersFieldInput>;
  cooldown?: InputMaybe<DateQuestionCooldownFieldInput>;
  dateType?: InputMaybe<DateFormatType>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<DateQuestionGraphFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  nexts?: InputMaybe<DateQuestionNextsFieldInput>;
  prevs?: InputMaybe<DateQuestionPrevsFieldInput>;
};

export type DateQuestionDeleteInput = {
  alerts?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  cooldown?: InputMaybe<DateQuestionCooldownDeleteFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<DateQuestionNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<DateQuestionPrevsDeleteFieldInput>>;
};

export type DateQuestionDisconnectInput = {
  alerts?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  cooldown?: InputMaybe<DateQuestionCooldownDisconnectFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<DateQuestionNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<DateQuestionPrevsDisconnectFieldInput>>;
};

export type DateQuestionEdge = {
  __typename?: 'DateQuestionEdge';
  cursor: Scalars['String']['output'];
  node: DateQuestion;
};

export type DateQuestionGraphAggregateInput = {
  AND?: InputMaybe<Array<DateQuestionGraphAggregateInput>>;
  NOT?: InputMaybe<DateQuestionGraphAggregateInput>;
  OR?: InputMaybe<Array<DateQuestionGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<DateQuestionGraphNodeAggregationWhereInput>;
};

export type DateQuestionGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type DateQuestionGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type DateQuestionGraphFieldInput = {
  connect?: InputMaybe<DateQuestionGraphConnectFieldInput>;
  create?: InputMaybe<DateQuestionGraphCreateFieldInput>;
};

export type DateQuestionGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DateQuestionGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DateQuestionGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DateQuestionGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type DateQuestionGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type DateQuestionGraphUpdateFieldInput = {
  connect?: InputMaybe<DateQuestionGraphConnectFieldInput>;
  create?: InputMaybe<DateQuestionGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<DateQuestionGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type DateQuestionNextsAggregateInput = {
  AND?: InputMaybe<Array<DateQuestionNextsAggregateInput>>;
  NOT?: InputMaybe<DateQuestionNextsAggregateInput>;
  OR?: InputMaybe<Array<DateQuestionNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<DateQuestionNextsNodeAggregationWhereInput>;
};

export type DateQuestionNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type DateQuestionNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type DateQuestionNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type DateQuestionNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type DateQuestionNextsFieldInput = {
  connect?: InputMaybe<Array<DateQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<DateQuestionNextsCreateFieldInput>>;
};

export type DateQuestionNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DateQuestionNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DateQuestionNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DateQuestionNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DateQuestionNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type DateQuestionNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<DateQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<DateQuestionNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<DateQuestionNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<DateQuestionNextsDisconnectFieldInput>>;
  update?: InputMaybe<DateQuestionNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type DateQuestionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more DateQuestionSort objects to sort DateQuestions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<DateQuestionSort>>;
};

export type DateQuestionPrevsAggregateInput = {
  AND?: InputMaybe<Array<DateQuestionPrevsAggregateInput>>;
  NOT?: InputMaybe<DateQuestionPrevsAggregateInput>;
  OR?: InputMaybe<Array<DateQuestionPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<DateQuestionPrevsNodeAggregationWhereInput>;
};

export type DateQuestionPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type DateQuestionPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type DateQuestionPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type DateQuestionPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type DateQuestionPrevsFieldInput = {
  connect?: InputMaybe<Array<DateQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<DateQuestionPrevsCreateFieldInput>>;
};

export type DateQuestionPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DateQuestionPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DateQuestionPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DateQuestionPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DateQuestionPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type DateQuestionPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<DateQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<DateQuestionPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<DateQuestionPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<DateQuestionPrevsDisconnectFieldInput>>;
  update?: InputMaybe<DateQuestionPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type DateQuestionQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'DateQuestionQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<DateQuestionQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<DateQuestionQuestionnaireStepNextsNodeAggregateSelection>;
};

export type DateQuestionQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'DateQuestionQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type DateQuestionQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'DateQuestionQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type DateQuestionQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'DateQuestionQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<DateQuestionQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<DateQuestionQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type DateQuestionQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'DateQuestionQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type DateQuestionQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'DateQuestionQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type DateQuestionRelationInput = {
  alerts?: InputMaybe<DateQuestionAlertsCreateFieldInput>;
  answers?: InputMaybe<Array<DateQuestionAnswersCreateFieldInput>>;
  cooldown?: InputMaybe<DateQuestionCooldownCreateFieldInput>;
  graph?: InputMaybe<DateQuestionGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<DateQuestionNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<DateQuestionPrevsCreateFieldInput>>;
};

/** Fields to sort DateQuestions by. The order in which sorts are applied is not guaranteed when specifying many fields in one DateQuestionSort object. */
export type DateQuestionSort = {
  dateType?: InputMaybe<SortDirection>;
  field?: InputMaybe<SortDirection>;
  hint?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  image?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type DateQuestionUpdateInput = {
  alerts?: InputMaybe<DateQuestionAlertsUpdateFieldInput>;
  answers?: InputMaybe<Array<DateQuestionAnswersUpdateFieldInput>>;
  cooldown?: InputMaybe<DateQuestionCooldownUpdateFieldInput>;
  dateType?: InputMaybe<DateFormatType>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<DateQuestionGraphUpdateFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<DateQuestionNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<DateQuestionPrevsUpdateFieldInput>>;
};

export type DateQuestionVersionnedGraphGraphAggregationSelection = {
  __typename?: 'DateQuestionVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<DateQuestionVersionnedGraphGraphNodeAggregateSelection>;
};

export type DateQuestionVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'DateQuestionVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type DateQuestionWhere = {
  AND?: InputMaybe<Array<DateQuestionWhere>>;
  NOT?: InputMaybe<DateQuestionWhere>;
  OR?: InputMaybe<Array<DateQuestionWhere>>;
  alerts?: InputMaybe<AlertGroupWhere>;
  alertsAggregate?: InputMaybe<DateQuestionAlertsAggregateInput>;
  alertsConnection?: InputMaybe<QuestionAlertsConnectionWhere>;
  alertsConnection_NOT?: InputMaybe<QuestionAlertsConnectionWhere>;
  alerts_NOT?: InputMaybe<AlertGroupWhere>;
  answersAggregate?: InputMaybe<DateQuestionAnswersAggregateInput>;
  /** Return DateQuestions where all of the related QuestionAnswersConnections match this filter */
  answersConnection_ALL?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return DateQuestions where none of the related QuestionAnswersConnections match this filter */
  answersConnection_NONE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return DateQuestions where one of the related QuestionAnswersConnections match this filter */
  answersConnection_SINGLE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return DateQuestions where some of the related QuestionAnswersConnections match this filter */
  answersConnection_SOME?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return DateQuestions where all of the related Answers match this filter */
  answers_ALL?: InputMaybe<AnswerWhere>;
  /** Return DateQuestions where none of the related Answers match this filter */
  answers_NONE?: InputMaybe<AnswerWhere>;
  /** Return DateQuestions where one of the related Answers match this filter */
  answers_SINGLE?: InputMaybe<AnswerWhere>;
  /** Return DateQuestions where some of the related Answers match this filter */
  answers_SOME?: InputMaybe<AnswerWhere>;
  cooldown?: InputMaybe<CooldownWhere>;
  cooldownAggregate?: InputMaybe<DateQuestionCooldownAggregateInput>;
  cooldownConnection?: InputMaybe<DateQuestionCooldownConnectionWhere>;
  cooldownConnection_NOT?: InputMaybe<DateQuestionCooldownConnectionWhere>;
  cooldown_NOT?: InputMaybe<CooldownWhere>;
  dateType?: InputMaybe<DateFormatType>;
  dateType_IN?: InputMaybe<Array<InputMaybe<DateFormatType>>>;
  field?: InputMaybe<Scalars['String']['input']>;
  field_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  field_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  field_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  field_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<DateQuestionGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  hint?: InputMaybe<Scalars['String']['input']>;
  hint_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  hint_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hint_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  image_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  image_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  image_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  image_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<DateQuestionNextsAggregateInput>;
  /** Return DateQuestions where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return DateQuestions where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return DateQuestions where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return DateQuestions where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return DateQuestions where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return DateQuestions where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return DateQuestions where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return DateQuestions where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<DateQuestionPrevsAggregateInput>;
  /** Return DateQuestions where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return DateQuestions where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return DateQuestions where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return DateQuestions where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return DateQuestions where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return DateQuestions where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return DateQuestions where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return DateQuestions where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type DateQuestionsConnection = {
  __typename?: 'DateQuestionsConnection';
  edges: Array<DateQuestionEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type DateTimeAggregateSelection = {
  __typename?: 'DateTimeAggregateSelection';
  max?: Maybe<Scalars['DateTime']['output']>;
  min?: Maybe<Scalars['DateTime']['output']>;
};

export type DeleteInfo = {
  __typename?: 'DeleteInfo';
  nodesDeleted?: Maybe<Scalars['Int']['output']>;
};

export type DeleteInfoAggregateSelection = {
  __typename?: 'DeleteInfoAggregateSelection';
  count: Scalars['Int']['output'];
  nodesDeleted: IntAggregateSelection;
};

export type DeleteInfoCreateInput = {
  nodesDeleted?: InputMaybe<Scalars['Int']['input']>;
};

export type DeleteInfoEdge = {
  __typename?: 'DeleteInfoEdge';
  cursor: Scalars['String']['output'];
  node: DeleteInfo;
};

export type DeleteInfoOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more DeleteInfoSort objects to sort DeleteInfos by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<DeleteInfoSort>>;
};

/** Fields to sort DeleteInfos by. The order in which sorts are applied is not guaranteed when specifying many fields in one DeleteInfoSort object. */
export type DeleteInfoSort = {
  nodesDeleted?: InputMaybe<SortDirection>;
};

export type DeleteInfoUpdateInput = {
  nodesDeleted?: InputMaybe<Scalars['Int']['input']>;
  nodesDeleted_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  nodesDeleted_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
};

export type DeleteInfoWhere = {
  AND?: InputMaybe<Array<DeleteInfoWhere>>;
  NOT?: InputMaybe<DeleteInfoWhere>;
  OR?: InputMaybe<Array<DeleteInfoWhere>>;
  nodesDeleted?: InputMaybe<Scalars['Int']['input']>;
  nodesDeleted_GT?: InputMaybe<Scalars['Int']['input']>;
  nodesDeleted_GTE?: InputMaybe<Scalars['Int']['input']>;
  nodesDeleted_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  nodesDeleted_LT?: InputMaybe<Scalars['Int']['input']>;
  nodesDeleted_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DeleteInfosConnection = {
  __typename?: 'DeleteInfosConnection';
  edges: Array<DeleteInfoEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Device = {
  __typename?: 'Device';
  deleted: Scalars['Boolean']['output'];
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  doctors: Array<Doctor>;
  doctorsAggregate?: Maybe<DeviceDoctorDoctorsAggregationSelection>;
  doctorsConnection: DeviceDoctorsConnection;
  institution: Institution;
  institutionAggregate?: Maybe<DeviceInstitutionInstitutionAggregationSelection>;
  institutionConnection: DeviceInstitutionConnection;
  name?: Maybe<Scalars['String']['output']>;
  serial: Scalars['String']['output'];
  workflow: Workflow;
  workflowAggregate?: Maybe<DeviceWorkflowWorkflowAggregationSelection>;
  workflowConnection: DeviceWorkflowConnection;
};


export type DeviceDoctorsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<DoctorOptions>;
  where?: InputMaybe<DoctorWhere>;
};


export type DeviceDoctorsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<DoctorWhere>;
};


export type DeviceDoctorsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<DeviceDoctorsConnectionSort>>;
  where?: InputMaybe<DeviceDoctorsConnectionWhere>;
};


export type DeviceInstitutionArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<InstitutionOptions>;
  where?: InputMaybe<InstitutionWhere>;
};


export type DeviceInstitutionAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<InstitutionWhere>;
};


export type DeviceInstitutionConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<DeviceInstitutionConnectionSort>>;
  where?: InputMaybe<DeviceInstitutionConnectionWhere>;
};


export type DeviceWorkflowArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<WorkflowOptions>;
  where?: InputMaybe<WorkflowWhere>;
};


export type DeviceWorkflowAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<WorkflowWhere>;
};


export type DeviceWorkflowConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<DeviceWorkflowConnectionSort>>;
  where?: InputMaybe<DeviceWorkflowConnectionWhere>;
};

export type DeviceAggregateSelection = {
  __typename?: 'DeviceAggregateSelection';
  count: Scalars['Int']['output'];
  deletedAt: DateTimeAggregateSelection;
  name: StringAggregateSelection;
  serial: StringAggregateSelection;
};

export type DeviceConnectInput = {
  doctors?: InputMaybe<Array<DeviceDoctorsConnectFieldInput>>;
  institution?: InputMaybe<DeviceInstitutionConnectFieldInput>;
  workflow?: InputMaybe<DeviceWorkflowConnectFieldInput>;
};

export type DeviceConnectOrCreateInput = {
  doctors?: InputMaybe<Array<DeviceDoctorsConnectOrCreateFieldInput>>;
  institution?: InputMaybe<DeviceInstitutionConnectOrCreateFieldInput>;
  workflow?: InputMaybe<DeviceWorkflowConnectOrCreateFieldInput>;
};

export type DeviceConnectOrCreateWhere = {
  node: DeviceUniqueWhere;
};

export type DeviceConnectWhere = {
  node: DeviceWhere;
};

export type DeviceCreateInput = {
  deleted?: Scalars['Boolean']['input'];
  doctors?: InputMaybe<DeviceDoctorsFieldInput>;
  institution?: InputMaybe<DeviceInstitutionFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  serial: Scalars['String']['input'];
  workflow?: InputMaybe<DeviceWorkflowFieldInput>;
};

export type DeviceDeleteInput = {
  doctors?: InputMaybe<Array<DeviceDoctorsDeleteFieldInput>>;
  institution?: InputMaybe<DeviceInstitutionDeleteFieldInput>;
  workflow?: InputMaybe<DeviceWorkflowDeleteFieldInput>;
};

export type DeviceDisconnectInput = {
  doctors?: InputMaybe<Array<DeviceDoctorsDisconnectFieldInput>>;
  institution?: InputMaybe<DeviceInstitutionDisconnectFieldInput>;
  workflow?: InputMaybe<DeviceWorkflowDisconnectFieldInput>;
};

export type DeviceDoctorDoctorsAggregationSelection = {
  __typename?: 'DeviceDoctorDoctorsAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<DeviceDoctorDoctorsNodeAggregateSelection>;
};

export type DeviceDoctorDoctorsNodeAggregateSelection = {
  __typename?: 'DeviceDoctorDoctorsNodeAggregateSelection';
  email: StringAggregateSelection;
  firstName: StringAggregateSelection;
  firstNameNormalized: StringAggregateSelection;
  id: IdAggregateSelection;
  lastName: StringAggregateSelection;
  lastNameNormalized: StringAggregateSelection;
  phone: StringAggregateSelection;
  rpps: StringAggregateSelection;
};

export type DeviceDoctorsAggregateInput = {
  AND?: InputMaybe<Array<DeviceDoctorsAggregateInput>>;
  NOT?: InputMaybe<DeviceDoctorsAggregateInput>;
  OR?: InputMaybe<Array<DeviceDoctorsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<DeviceDoctorsNodeAggregationWhereInput>;
};

export type DeviceDoctorsConnectFieldInput = {
  connect?: InputMaybe<Array<DoctorConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<DoctorConnectWhere>;
};

export type DeviceDoctorsConnectOrCreateFieldInput = {
  onCreate: DeviceDoctorsConnectOrCreateFieldInputOnCreate;
  where: DoctorConnectOrCreateWhere;
};

export type DeviceDoctorsConnectOrCreateFieldInputOnCreate = {
  node: DoctorOnCreateInput;
};

export type DeviceDoctorsConnection = {
  __typename?: 'DeviceDoctorsConnection';
  edges: Array<DeviceDoctorsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type DeviceDoctorsConnectionSort = {
  node?: InputMaybe<DoctorSort>;
};

export type DeviceDoctorsConnectionWhere = {
  AND?: InputMaybe<Array<DeviceDoctorsConnectionWhere>>;
  NOT?: InputMaybe<DeviceDoctorsConnectionWhere>;
  OR?: InputMaybe<Array<DeviceDoctorsConnectionWhere>>;
  node?: InputMaybe<DoctorWhere>;
};

export type DeviceDoctorsCreateFieldInput = {
  node: DoctorCreateInput;
};

export type DeviceDoctorsDeleteFieldInput = {
  delete?: InputMaybe<DoctorDeleteInput>;
  where?: InputMaybe<DeviceDoctorsConnectionWhere>;
};

export type DeviceDoctorsDisconnectFieldInput = {
  disconnect?: InputMaybe<DoctorDisconnectInput>;
  where?: InputMaybe<DeviceDoctorsConnectionWhere>;
};

export type DeviceDoctorsFieldInput = {
  connect?: InputMaybe<Array<DeviceDoctorsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<DeviceDoctorsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<DeviceDoctorsCreateFieldInput>>;
};

export type DeviceDoctorsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DeviceDoctorsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DeviceDoctorsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DeviceDoctorsNodeAggregationWhereInput>>;
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  phone_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  rpps_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DeviceDoctorsRelationship = {
  __typename?: 'DeviceDoctorsRelationship';
  cursor: Scalars['String']['output'];
  node: Doctor;
};

export type DeviceDoctorsUpdateConnectionInput = {
  node?: InputMaybe<DoctorUpdateInput>;
};

export type DeviceDoctorsUpdateFieldInput = {
  connect?: InputMaybe<Array<DeviceDoctorsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<DeviceDoctorsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<DeviceDoctorsCreateFieldInput>>;
  delete?: InputMaybe<Array<DeviceDoctorsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<DeviceDoctorsDisconnectFieldInput>>;
  update?: InputMaybe<DeviceDoctorsUpdateConnectionInput>;
  where?: InputMaybe<DeviceDoctorsConnectionWhere>;
};

export type DeviceEdge = {
  __typename?: 'DeviceEdge';
  cursor: Scalars['String']['output'];
  node: Device;
};

export type DeviceInstitutionAggregateInput = {
  AND?: InputMaybe<Array<DeviceInstitutionAggregateInput>>;
  NOT?: InputMaybe<DeviceInstitutionAggregateInput>;
  OR?: InputMaybe<Array<DeviceInstitutionAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<DeviceInstitutionNodeAggregationWhereInput>;
};

export type DeviceInstitutionConnectFieldInput = {
  connect?: InputMaybe<InstitutionConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<InstitutionConnectWhere>;
};

export type DeviceInstitutionConnectOrCreateFieldInput = {
  onCreate: DeviceInstitutionConnectOrCreateFieldInputOnCreate;
  where: InstitutionConnectOrCreateWhere;
};

export type DeviceInstitutionConnectOrCreateFieldInputOnCreate = {
  node: InstitutionOnCreateInput;
};

export type DeviceInstitutionConnection = {
  __typename?: 'DeviceInstitutionConnection';
  edges: Array<DeviceInstitutionRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type DeviceInstitutionConnectionSort = {
  node?: InputMaybe<InstitutionSort>;
};

export type DeviceInstitutionConnectionWhere = {
  AND?: InputMaybe<Array<DeviceInstitutionConnectionWhere>>;
  NOT?: InputMaybe<DeviceInstitutionConnectionWhere>;
  OR?: InputMaybe<Array<DeviceInstitutionConnectionWhere>>;
  node?: InputMaybe<InstitutionWhere>;
};

export type DeviceInstitutionCreateFieldInput = {
  node: InstitutionCreateInput;
};

export type DeviceInstitutionDeleteFieldInput = {
  delete?: InputMaybe<InstitutionDeleteInput>;
  where?: InputMaybe<DeviceInstitutionConnectionWhere>;
};

export type DeviceInstitutionDisconnectFieldInput = {
  disconnect?: InputMaybe<InstitutionDisconnectInput>;
  where?: InputMaybe<DeviceInstitutionConnectionWhere>;
};

export type DeviceInstitutionFieldInput = {
  connect?: InputMaybe<DeviceInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<DeviceInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<DeviceInstitutionCreateFieldInput>;
};

export type DeviceInstitutionInstitutionAggregationSelection = {
  __typename?: 'DeviceInstitutionInstitutionAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<DeviceInstitutionInstitutionNodeAggregateSelection>;
};

export type DeviceInstitutionInstitutionNodeAggregateSelection = {
  __typename?: 'DeviceInstitutionInstitutionNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type DeviceInstitutionNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DeviceInstitutionNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DeviceInstitutionNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DeviceInstitutionNodeAggregationWhereInput>>;
  nameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DeviceInstitutionRelationship = {
  __typename?: 'DeviceInstitutionRelationship';
  cursor: Scalars['String']['output'];
  node: Institution;
};

export type DeviceInstitutionUpdateConnectionInput = {
  node?: InputMaybe<InstitutionUpdateInput>;
};

export type DeviceInstitutionUpdateFieldInput = {
  connect?: InputMaybe<DeviceInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<DeviceInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<DeviceInstitutionCreateFieldInput>;
  delete?: InputMaybe<DeviceInstitutionDeleteFieldInput>;
  disconnect?: InputMaybe<DeviceInstitutionDisconnectFieldInput>;
  update?: InputMaybe<DeviceInstitutionUpdateConnectionInput>;
  where?: InputMaybe<DeviceInstitutionConnectionWhere>;
};

export type DeviceOnCreateInput = {
  deleted?: Scalars['Boolean']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  serial: Scalars['String']['input'];
};

export type DeviceOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more DeviceSort objects to sort Devices by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<DeviceSort>>;
};

export type DeviceRelationInput = {
  doctors?: InputMaybe<Array<DeviceDoctorsCreateFieldInput>>;
  institution?: InputMaybe<DeviceInstitutionCreateFieldInput>;
  workflow?: InputMaybe<DeviceWorkflowCreateFieldInput>;
};

/** Fields to sort Devices by. The order in which sorts are applied is not guaranteed when specifying many fields in one DeviceSort object. */
export type DeviceSort = {
  deleted?: InputMaybe<SortDirection>;
  deletedAt?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  serial?: InputMaybe<SortDirection>;
};

export type DeviceUniqueWhere = {
  serial?: InputMaybe<Scalars['String']['input']>;
};

export type DeviceUpdateInput = {
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  doctors?: InputMaybe<Array<DeviceDoctorsUpdateFieldInput>>;
  institution?: InputMaybe<DeviceInstitutionUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  serial?: InputMaybe<Scalars['String']['input']>;
  workflow?: InputMaybe<DeviceWorkflowUpdateFieldInput>;
};

export type DeviceWhere = {
  AND?: InputMaybe<Array<DeviceWhere>>;
  NOT?: InputMaybe<DeviceWhere>;
  OR?: InputMaybe<Array<DeviceWhere>>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAt?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_GT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_IN?: InputMaybe<Array<InputMaybe<Scalars['DateTime']['input']>>>;
  deletedAt_LT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  doctorsAggregate?: InputMaybe<DeviceDoctorsAggregateInput>;
  /** Return Devices where all of the related DeviceDoctorsConnections match this filter */
  doctorsConnection_ALL?: InputMaybe<DeviceDoctorsConnectionWhere>;
  /** Return Devices where none of the related DeviceDoctorsConnections match this filter */
  doctorsConnection_NONE?: InputMaybe<DeviceDoctorsConnectionWhere>;
  /** Return Devices where one of the related DeviceDoctorsConnections match this filter */
  doctorsConnection_SINGLE?: InputMaybe<DeviceDoctorsConnectionWhere>;
  /** Return Devices where some of the related DeviceDoctorsConnections match this filter */
  doctorsConnection_SOME?: InputMaybe<DeviceDoctorsConnectionWhere>;
  /** Return Devices where all of the related Doctors match this filter */
  doctors_ALL?: InputMaybe<DoctorWhere>;
  /** Return Devices where none of the related Doctors match this filter */
  doctors_NONE?: InputMaybe<DoctorWhere>;
  /** Return Devices where one of the related Doctors match this filter */
  doctors_SINGLE?: InputMaybe<DoctorWhere>;
  /** Return Devices where some of the related Doctors match this filter */
  doctors_SOME?: InputMaybe<DoctorWhere>;
  institution?: InputMaybe<InstitutionWhere>;
  institutionAggregate?: InputMaybe<DeviceInstitutionAggregateInput>;
  institutionConnection?: InputMaybe<DeviceInstitutionConnectionWhere>;
  institutionConnection_NOT?: InputMaybe<DeviceInstitutionConnectionWhere>;
  institution_NOT?: InputMaybe<InstitutionWhere>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  serial?: InputMaybe<Scalars['String']['input']>;
  serial_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  serial_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  serial_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  serial_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  workflow?: InputMaybe<WorkflowWhere>;
  workflowAggregate?: InputMaybe<DeviceWorkflowAggregateInput>;
  workflowConnection?: InputMaybe<DeviceWorkflowConnectionWhere>;
  workflowConnection_NOT?: InputMaybe<DeviceWorkflowConnectionWhere>;
  workflow_NOT?: InputMaybe<WorkflowWhere>;
};

export type DeviceWorkflowAggregateInput = {
  AND?: InputMaybe<Array<DeviceWorkflowAggregateInput>>;
  NOT?: InputMaybe<DeviceWorkflowAggregateInput>;
  OR?: InputMaybe<Array<DeviceWorkflowAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<DeviceWorkflowNodeAggregationWhereInput>;
};

export type DeviceWorkflowConnectFieldInput = {
  connect?: InputMaybe<WorkflowConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<WorkflowConnectWhere>;
};

export type DeviceWorkflowConnectOrCreateFieldInput = {
  onCreate: DeviceWorkflowConnectOrCreateFieldInputOnCreate;
  where: WorkflowConnectOrCreateWhere;
};

export type DeviceWorkflowConnectOrCreateFieldInputOnCreate = {
  node: WorkflowOnCreateInput;
};

export type DeviceWorkflowConnection = {
  __typename?: 'DeviceWorkflowConnection';
  edges: Array<DeviceWorkflowRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type DeviceWorkflowConnectionSort = {
  node?: InputMaybe<WorkflowSort>;
};

export type DeviceWorkflowConnectionWhere = {
  AND?: InputMaybe<Array<DeviceWorkflowConnectionWhere>>;
  NOT?: InputMaybe<DeviceWorkflowConnectionWhere>;
  OR?: InputMaybe<Array<DeviceWorkflowConnectionWhere>>;
  node?: InputMaybe<WorkflowWhere>;
};

export type DeviceWorkflowCreateFieldInput = {
  node: WorkflowCreateInput;
};

export type DeviceWorkflowDeleteFieldInput = {
  delete?: InputMaybe<WorkflowDeleteInput>;
  where?: InputMaybe<DeviceWorkflowConnectionWhere>;
};

export type DeviceWorkflowDisconnectFieldInput = {
  disconnect?: InputMaybe<WorkflowDisconnectInput>;
  where?: InputMaybe<DeviceWorkflowConnectionWhere>;
};

export type DeviceWorkflowFieldInput = {
  connect?: InputMaybe<DeviceWorkflowConnectFieldInput>;
  connectOrCreate?: InputMaybe<DeviceWorkflowConnectOrCreateFieldInput>;
  create?: InputMaybe<DeviceWorkflowCreateFieldInput>;
};

export type DeviceWorkflowNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DeviceWorkflowNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DeviceWorkflowNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DeviceWorkflowNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DeviceWorkflowRelationship = {
  __typename?: 'DeviceWorkflowRelationship';
  cursor: Scalars['String']['output'];
  node: Workflow;
};

export type DeviceWorkflowUpdateConnectionInput = {
  node?: InputMaybe<WorkflowUpdateInput>;
};

export type DeviceWorkflowUpdateFieldInput = {
  connect?: InputMaybe<DeviceWorkflowConnectFieldInput>;
  connectOrCreate?: InputMaybe<DeviceWorkflowConnectOrCreateFieldInput>;
  create?: InputMaybe<DeviceWorkflowCreateFieldInput>;
  delete?: InputMaybe<DeviceWorkflowDeleteFieldInput>;
  disconnect?: InputMaybe<DeviceWorkflowDisconnectFieldInput>;
  update?: InputMaybe<DeviceWorkflowUpdateConnectionInput>;
  where?: InputMaybe<DeviceWorkflowConnectionWhere>;
};

export type DeviceWorkflowWorkflowAggregationSelection = {
  __typename?: 'DeviceWorkflowWorkflowAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<DeviceWorkflowWorkflowNodeAggregateSelection>;
};

export type DeviceWorkflowWorkflowNodeAggregateSelection = {
  __typename?: 'DeviceWorkflowWorkflowNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type DevicesConnection = {
  __typename?: 'DevicesConnection';
  edges: Array<DeviceEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Doctor = User & {
  __typename?: 'Doctor';
  address?: Maybe<PostalAddress>;
  addressAggregate?: Maybe<DoctorPostalAddressAddressAggregationSelection>;
  addressConnection: DoctorAddressConnection;
  betatester?: Maybe<Scalars['Boolean']['output']>;
  configurations: Array<Configuration>;
  configurationsAggregate?: Maybe<DoctorConfigurationConfigurationsAggregationSelection>;
  configurationsConnection: DoctorConfigurationsConnection;
  email: Scalars['String']['output'];
  fakeEmail?: Maybe<Scalars['Boolean']['output']>;
  firstName: Scalars['String']['output'];
  firstNameNormalized?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  institutions: Array<Institution>;
  institutionsAggregate?: Maybe<DoctorInstitutionInstitutionsAggregationSelection>;
  institutionsConnection: DoctorInstitutionsConnection;
  lastName: Scalars['String']['output'];
  lastNameNormalized?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  picture?: Maybe<Document>;
  rpps: Scalars['String']['output'];
  speciality?: Maybe<Speciality>;
  specialityAggregate?: Maybe<DoctorSpecialitySpecialityAggregationSelection>;
  specialityConnection: DoctorSpecialityConnection;
};


export type DoctorAddressArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<PostalAddressOptions>;
  where?: InputMaybe<PostalAddressWhere>;
};


export type DoctorAddressAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<PostalAddressWhere>;
};


export type DoctorAddressConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<DoctorAddressConnectionSort>>;
  where?: InputMaybe<DoctorAddressConnectionWhere>;
};


export type DoctorConfigurationsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<ConfigurationOptions>;
  where?: InputMaybe<ConfigurationWhere>;
};


export type DoctorConfigurationsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<ConfigurationWhere>;
};


export type DoctorConfigurationsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<DoctorConfigurationsConnectionSort>>;
  where?: InputMaybe<DoctorConfigurationsConnectionWhere>;
};


export type DoctorInstitutionsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<InstitutionOptions>;
  where?: InputMaybe<InstitutionWhere>;
};


export type DoctorInstitutionsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<InstitutionWhere>;
};


export type DoctorInstitutionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<DoctorInstitutionsConnectionSort>>;
  where?: InputMaybe<DoctorInstitutionsConnectionWhere>;
};


export type DoctorSpecialityArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<SpecialityOptions>;
  where?: InputMaybe<SpecialityWhere>;
};


export type DoctorSpecialityAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<SpecialityWhere>;
};


export type DoctorSpecialityConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<DoctorSpecialityConnectionSort>>;
  where?: InputMaybe<DoctorSpecialityConnectionWhere>;
};

export type DoctorAddressAggregateInput = {
  AND?: InputMaybe<Array<DoctorAddressAggregateInput>>;
  NOT?: InputMaybe<DoctorAddressAggregateInput>;
  OR?: InputMaybe<Array<DoctorAddressAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<DoctorAddressNodeAggregationWhereInput>;
};

export type DoctorAddressConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<PostalAddressConnectWhere>;
};

export type DoctorAddressConnection = {
  __typename?: 'DoctorAddressConnection';
  edges: Array<DoctorAddressRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type DoctorAddressConnectionSort = {
  node?: InputMaybe<PostalAddressSort>;
};

export type DoctorAddressConnectionWhere = {
  AND?: InputMaybe<Array<DoctorAddressConnectionWhere>>;
  NOT?: InputMaybe<DoctorAddressConnectionWhere>;
  OR?: InputMaybe<Array<DoctorAddressConnectionWhere>>;
  node?: InputMaybe<PostalAddressWhere>;
};

export type DoctorAddressCreateFieldInput = {
  node: PostalAddressCreateInput;
};

export type DoctorAddressDeleteFieldInput = {
  where?: InputMaybe<DoctorAddressConnectionWhere>;
};

export type DoctorAddressDisconnectFieldInput = {
  where?: InputMaybe<DoctorAddressConnectionWhere>;
};

export type DoctorAddressFieldInput = {
  connect?: InputMaybe<DoctorAddressConnectFieldInput>;
  create?: InputMaybe<DoctorAddressCreateFieldInput>;
};

export type DoctorAddressNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DoctorAddressNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DoctorAddressNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DoctorAddressNodeAggregationWhereInput>>;
  city_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  city_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  postalCode_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  street_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  street_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  street_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  street_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  street_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  street_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  street_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  street_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  street_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  street_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  street_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  street_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  street_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  street_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  street_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DoctorAddressRelationship = {
  __typename?: 'DoctorAddressRelationship';
  cursor: Scalars['String']['output'];
  node: PostalAddress;
};

export type DoctorAddressUpdateConnectionInput = {
  node?: InputMaybe<PostalAddressUpdateInput>;
};

export type DoctorAddressUpdateFieldInput = {
  connect?: InputMaybe<DoctorAddressConnectFieldInput>;
  create?: InputMaybe<DoctorAddressCreateFieldInput>;
  delete?: InputMaybe<DoctorAddressDeleteFieldInput>;
  disconnect?: InputMaybe<DoctorAddressDisconnectFieldInput>;
  update?: InputMaybe<DoctorAddressUpdateConnectionInput>;
  where?: InputMaybe<DoctorAddressConnectionWhere>;
};

export type DoctorAggregateSelection = {
  __typename?: 'DoctorAggregateSelection';
  count: Scalars['Int']['output'];
  email: StringAggregateSelection;
  firstName: StringAggregateSelection;
  firstNameNormalized: StringAggregateSelection;
  id: IdAggregateSelection;
  lastName: StringAggregateSelection;
  lastNameNormalized: StringAggregateSelection;
  phone: StringAggregateSelection;
  rpps: StringAggregateSelection;
};

export type DoctorConfigurationConfigurationsAggregationSelection = {
  __typename?: 'DoctorConfigurationConfigurationsAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<DoctorConfigurationConfigurationsNodeAggregateSelection>;
};

export type DoctorConfigurationConfigurationsNodeAggregateSelection = {
  __typename?: 'DoctorConfigurationConfigurationsNodeAggregateSelection';
  dashboardLayout: StringAggregateSelection;
  id: IdAggregateSelection;
};

export type DoctorConfigurationsAggregateInput = {
  AND?: InputMaybe<Array<DoctorConfigurationsAggregateInput>>;
  NOT?: InputMaybe<DoctorConfigurationsAggregateInput>;
  OR?: InputMaybe<Array<DoctorConfigurationsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<DoctorConfigurationsNodeAggregationWhereInput>;
};

export type DoctorConfigurationsConnectFieldInput = {
  connect?: InputMaybe<Array<ConfigurationConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<ConfigurationConnectWhere>;
};

export type DoctorConfigurationsConnectOrCreateFieldInput = {
  onCreate: DoctorConfigurationsConnectOrCreateFieldInputOnCreate;
  where: ConfigurationConnectOrCreateWhere;
};

export type DoctorConfigurationsConnectOrCreateFieldInputOnCreate = {
  node: ConfigurationOnCreateInput;
};

export type DoctorConfigurationsConnection = {
  __typename?: 'DoctorConfigurationsConnection';
  edges: Array<DoctorConfigurationsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type DoctorConfigurationsConnectionSort = {
  node?: InputMaybe<ConfigurationSort>;
};

export type DoctorConfigurationsConnectionWhere = {
  AND?: InputMaybe<Array<DoctorConfigurationsConnectionWhere>>;
  NOT?: InputMaybe<DoctorConfigurationsConnectionWhere>;
  OR?: InputMaybe<Array<DoctorConfigurationsConnectionWhere>>;
  node?: InputMaybe<ConfigurationWhere>;
};

export type DoctorConfigurationsCreateFieldInput = {
  node: ConfigurationCreateInput;
};

export type DoctorConfigurationsDeleteFieldInput = {
  delete?: InputMaybe<ConfigurationDeleteInput>;
  where?: InputMaybe<DoctorConfigurationsConnectionWhere>;
};

export type DoctorConfigurationsDisconnectFieldInput = {
  disconnect?: InputMaybe<ConfigurationDisconnectInput>;
  where?: InputMaybe<DoctorConfigurationsConnectionWhere>;
};

export type DoctorConfigurationsFieldInput = {
  connect?: InputMaybe<Array<DoctorConfigurationsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<DoctorConfigurationsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<DoctorConfigurationsCreateFieldInput>>;
};

export type DoctorConfigurationsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DoctorConfigurationsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DoctorConfigurationsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DoctorConfigurationsNodeAggregationWhereInput>>;
  dashboardLayout_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  dashboardLayout_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  dashboardLayout_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  dashboardLayout_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  dashboardLayout_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  dashboardLayout_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DoctorConfigurationsRelationship = {
  __typename?: 'DoctorConfigurationsRelationship';
  cursor: Scalars['String']['output'];
  node: Configuration;
};

export type DoctorConfigurationsUpdateConnectionInput = {
  node?: InputMaybe<ConfigurationUpdateInput>;
};

export type DoctorConfigurationsUpdateFieldInput = {
  connect?: InputMaybe<Array<DoctorConfigurationsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<DoctorConfigurationsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<DoctorConfigurationsCreateFieldInput>>;
  delete?: InputMaybe<Array<DoctorConfigurationsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<DoctorConfigurationsDisconnectFieldInput>>;
  update?: InputMaybe<DoctorConfigurationsUpdateConnectionInput>;
  where?: InputMaybe<DoctorConfigurationsConnectionWhere>;
};

export type DoctorConnectInput = {
  address?: InputMaybe<DoctorAddressConnectFieldInput>;
  configurations?: InputMaybe<Array<DoctorConfigurationsConnectFieldInput>>;
  institutions?: InputMaybe<Array<DoctorInstitutionsConnectFieldInput>>;
  speciality?: InputMaybe<DoctorSpecialityConnectFieldInput>;
};

export type DoctorConnectOrCreateInput = {
  configurations?: InputMaybe<Array<DoctorConfigurationsConnectOrCreateFieldInput>>;
  institutions?: InputMaybe<Array<DoctorInstitutionsConnectOrCreateFieldInput>>;
  speciality?: InputMaybe<DoctorSpecialityConnectOrCreateFieldInput>;
};

export type DoctorConnectOrCreateWhere = {
  node: DoctorUniqueWhere;
};

export type DoctorConnectWhere = {
  node: DoctorWhere;
};

export type DoctorCreateInput = {
  address?: InputMaybe<DoctorAddressFieldInput>;
  betatester?: InputMaybe<Scalars['Boolean']['input']>;
  configurations?: InputMaybe<DoctorConfigurationsFieldInput>;
  email: Scalars['String']['input'];
  fakeEmail?: InputMaybe<Scalars['Boolean']['input']>;
  firstName: Scalars['String']['input'];
  institutions?: InputMaybe<DoctorInstitutionsFieldInput>;
  lastName: Scalars['String']['input'];
  phone?: InputMaybe<Scalars['String']['input']>;
  rpps: Scalars['String']['input'];
  speciality?: InputMaybe<DoctorSpecialityFieldInput>;
};

export type DoctorDeleteInput = {
  address?: InputMaybe<DoctorAddressDeleteFieldInput>;
  configurations?: InputMaybe<Array<DoctorConfigurationsDeleteFieldInput>>;
  institutions?: InputMaybe<Array<DoctorInstitutionsDeleteFieldInput>>;
  speciality?: InputMaybe<DoctorSpecialityDeleteFieldInput>;
};

export type DoctorDisconnectInput = {
  address?: InputMaybe<DoctorAddressDisconnectFieldInput>;
  configurations?: InputMaybe<Array<DoctorConfigurationsDisconnectFieldInput>>;
  institutions?: InputMaybe<Array<DoctorInstitutionsDisconnectFieldInput>>;
  speciality?: InputMaybe<DoctorSpecialityDisconnectFieldInput>;
};

export type DoctorDoctorAutocompleteFulltext = {
  phrase: Scalars['String']['input'];
};

export type DoctorEdge = {
  __typename?: 'DoctorEdge';
  cursor: Scalars['String']['output'];
  node: Doctor;
};

export type DoctorFulltext = {
  DoctorAutocomplete?: InputMaybe<DoctorDoctorAutocompleteFulltext>;
};

/** The result of a fulltext search on an index of Doctor */
export type DoctorFulltextResult = {
  __typename?: 'DoctorFulltextResult';
  doctor: Doctor;
  score: Scalars['Float']['output'];
};

/** The input for sorting a fulltext query on an index of Doctor */
export type DoctorFulltextSort = {
  doctor?: InputMaybe<DoctorSort>;
  score?: InputMaybe<SortDirection>;
};

/** The input for filtering a fulltext query on an index of Doctor */
export type DoctorFulltextWhere = {
  doctor?: InputMaybe<DoctorWhere>;
  score?: InputMaybe<FloatWhere>;
};

export type DoctorInstitutionInstitutionsAggregationSelection = {
  __typename?: 'DoctorInstitutionInstitutionsAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<DoctorInstitutionInstitutionsNodeAggregateSelection>;
};

export type DoctorInstitutionInstitutionsNodeAggregateSelection = {
  __typename?: 'DoctorInstitutionInstitutionsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type DoctorInstitutionsAggregateInput = {
  AND?: InputMaybe<Array<DoctorInstitutionsAggregateInput>>;
  NOT?: InputMaybe<DoctorInstitutionsAggregateInput>;
  OR?: InputMaybe<Array<DoctorInstitutionsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<DoctorInstitutionsNodeAggregationWhereInput>;
};

export type DoctorInstitutionsConnectFieldInput = {
  connect?: InputMaybe<Array<InstitutionConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<InstitutionConnectWhere>;
};

export type DoctorInstitutionsConnectOrCreateFieldInput = {
  onCreate: DoctorInstitutionsConnectOrCreateFieldInputOnCreate;
  where: InstitutionConnectOrCreateWhere;
};

export type DoctorInstitutionsConnectOrCreateFieldInputOnCreate = {
  node: InstitutionOnCreateInput;
};

export type DoctorInstitutionsConnection = {
  __typename?: 'DoctorInstitutionsConnection';
  edges: Array<DoctorInstitutionsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type DoctorInstitutionsConnectionSort = {
  node?: InputMaybe<InstitutionSort>;
};

export type DoctorInstitutionsConnectionWhere = {
  AND?: InputMaybe<Array<DoctorInstitutionsConnectionWhere>>;
  NOT?: InputMaybe<DoctorInstitutionsConnectionWhere>;
  OR?: InputMaybe<Array<DoctorInstitutionsConnectionWhere>>;
  node?: InputMaybe<InstitutionWhere>;
};

export type DoctorInstitutionsCreateFieldInput = {
  node: InstitutionCreateInput;
};

export type DoctorInstitutionsDeleteFieldInput = {
  delete?: InputMaybe<InstitutionDeleteInput>;
  where?: InputMaybe<DoctorInstitutionsConnectionWhere>;
};

export type DoctorInstitutionsDisconnectFieldInput = {
  disconnect?: InputMaybe<InstitutionDisconnectInput>;
  where?: InputMaybe<DoctorInstitutionsConnectionWhere>;
};

export type DoctorInstitutionsFieldInput = {
  connect?: InputMaybe<Array<DoctorInstitutionsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<DoctorInstitutionsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<DoctorInstitutionsCreateFieldInput>>;
};

export type DoctorInstitutionsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DoctorInstitutionsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DoctorInstitutionsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DoctorInstitutionsNodeAggregationWhereInput>>;
  nameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DoctorInstitutionsRelationship = {
  __typename?: 'DoctorInstitutionsRelationship';
  cursor: Scalars['String']['output'];
  node: Institution;
};

export type DoctorInstitutionsUpdateConnectionInput = {
  node?: InputMaybe<InstitutionUpdateInput>;
};

export type DoctorInstitutionsUpdateFieldInput = {
  connect?: InputMaybe<Array<DoctorInstitutionsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<DoctorInstitutionsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<DoctorInstitutionsCreateFieldInput>>;
  delete?: InputMaybe<Array<DoctorInstitutionsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<DoctorInstitutionsDisconnectFieldInput>>;
  update?: InputMaybe<DoctorInstitutionsUpdateConnectionInput>;
  where?: InputMaybe<DoctorInstitutionsConnectionWhere>;
};

export type DoctorOnCreateInput = {
  betatester?: InputMaybe<Scalars['Boolean']['input']>;
  email: Scalars['String']['input'];
  fakeEmail?: InputMaybe<Scalars['Boolean']['input']>;
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  phone?: InputMaybe<Scalars['String']['input']>;
  rpps: Scalars['String']['input'];
};

export type DoctorOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more DoctorSort objects to sort Doctors by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<DoctorSort>>;
};

export type DoctorPostalAddressAddressAggregationSelection = {
  __typename?: 'DoctorPostalAddressAddressAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<DoctorPostalAddressAddressNodeAggregateSelection>;
};

export type DoctorPostalAddressAddressNodeAggregateSelection = {
  __typename?: 'DoctorPostalAddressAddressNodeAggregateSelection';
  city: StringAggregateSelection;
  postalCode: StringAggregateSelection;
  street: StringAggregateSelection;
};

export type DoctorRelationInput = {
  address?: InputMaybe<DoctorAddressCreateFieldInput>;
  configurations?: InputMaybe<Array<DoctorConfigurationsCreateFieldInput>>;
  institutions?: InputMaybe<Array<DoctorInstitutionsCreateFieldInput>>;
  speciality?: InputMaybe<DoctorSpecialityCreateFieldInput>;
};

/** Fields to sort Doctors by. The order in which sorts are applied is not guaranteed when specifying many fields in one DoctorSort object. */
export type DoctorSort = {
  betatester?: InputMaybe<SortDirection>;
  email?: InputMaybe<SortDirection>;
  fakeEmail?: InputMaybe<SortDirection>;
  firstName?: InputMaybe<SortDirection>;
  firstNameNormalized?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  lastName?: InputMaybe<SortDirection>;
  lastNameNormalized?: InputMaybe<SortDirection>;
  phone?: InputMaybe<SortDirection>;
  rpps?: InputMaybe<SortDirection>;
};

export type DoctorSpecialityAggregateInput = {
  AND?: InputMaybe<Array<DoctorSpecialityAggregateInput>>;
  NOT?: InputMaybe<DoctorSpecialityAggregateInput>;
  OR?: InputMaybe<Array<DoctorSpecialityAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<DoctorSpecialityNodeAggregationWhereInput>;
};

export type DoctorSpecialityConnectFieldInput = {
  connect?: InputMaybe<SpecialityConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<SpecialityConnectWhere>;
};

export type DoctorSpecialityConnectOrCreateFieldInput = {
  onCreate: DoctorSpecialityConnectOrCreateFieldInputOnCreate;
  where: SpecialityConnectOrCreateWhere;
};

export type DoctorSpecialityConnectOrCreateFieldInputOnCreate = {
  node: SpecialityOnCreateInput;
};

export type DoctorSpecialityConnection = {
  __typename?: 'DoctorSpecialityConnection';
  edges: Array<DoctorSpecialityRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type DoctorSpecialityConnectionSort = {
  node?: InputMaybe<SpecialitySort>;
};

export type DoctorSpecialityConnectionWhere = {
  AND?: InputMaybe<Array<DoctorSpecialityConnectionWhere>>;
  NOT?: InputMaybe<DoctorSpecialityConnectionWhere>;
  OR?: InputMaybe<Array<DoctorSpecialityConnectionWhere>>;
  node?: InputMaybe<SpecialityWhere>;
};

export type DoctorSpecialityCreateFieldInput = {
  node: SpecialityCreateInput;
};

export type DoctorSpecialityDeleteFieldInput = {
  delete?: InputMaybe<SpecialityDeleteInput>;
  where?: InputMaybe<DoctorSpecialityConnectionWhere>;
};

export type DoctorSpecialityDisconnectFieldInput = {
  disconnect?: InputMaybe<SpecialityDisconnectInput>;
  where?: InputMaybe<DoctorSpecialityConnectionWhere>;
};

export type DoctorSpecialityFieldInput = {
  connect?: InputMaybe<DoctorSpecialityConnectFieldInput>;
  connectOrCreate?: InputMaybe<DoctorSpecialityConnectOrCreateFieldInput>;
  create?: InputMaybe<DoctorSpecialityCreateFieldInput>;
};

export type DoctorSpecialityNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DoctorSpecialityNodeAggregationWhereInput>>;
  NOT?: InputMaybe<DoctorSpecialityNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<DoctorSpecialityNodeAggregationWhereInput>>;
  nameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type DoctorSpecialityRelationship = {
  __typename?: 'DoctorSpecialityRelationship';
  cursor: Scalars['String']['output'];
  node: Speciality;
};

export type DoctorSpecialitySpecialityAggregationSelection = {
  __typename?: 'DoctorSpecialitySpecialityAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<DoctorSpecialitySpecialityNodeAggregateSelection>;
};

export type DoctorSpecialitySpecialityNodeAggregateSelection = {
  __typename?: 'DoctorSpecialitySpecialityNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type DoctorSpecialityUpdateConnectionInput = {
  node?: InputMaybe<SpecialityUpdateInput>;
};

export type DoctorSpecialityUpdateFieldInput = {
  connect?: InputMaybe<DoctorSpecialityConnectFieldInput>;
  connectOrCreate?: InputMaybe<DoctorSpecialityConnectOrCreateFieldInput>;
  create?: InputMaybe<DoctorSpecialityCreateFieldInput>;
  delete?: InputMaybe<DoctorSpecialityDeleteFieldInput>;
  disconnect?: InputMaybe<DoctorSpecialityDisconnectFieldInput>;
  update?: InputMaybe<DoctorSpecialityUpdateConnectionInput>;
  where?: InputMaybe<DoctorSpecialityConnectionWhere>;
};

export type DoctorUniqueWhere = {
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  rpps?: InputMaybe<Scalars['String']['input']>;
};

export type DoctorUpdateInput = {
  address?: InputMaybe<DoctorAddressUpdateFieldInput>;
  betatester?: InputMaybe<Scalars['Boolean']['input']>;
  configurations?: InputMaybe<Array<DoctorConfigurationsUpdateFieldInput>>;
  email?: InputMaybe<Scalars['String']['input']>;
  fakeEmail?: InputMaybe<Scalars['Boolean']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  institutions?: InputMaybe<Array<DoctorInstitutionsUpdateFieldInput>>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  rpps?: InputMaybe<Scalars['String']['input']>;
  speciality?: InputMaybe<DoctorSpecialityUpdateFieldInput>;
};

export type DoctorWhere = {
  AND?: InputMaybe<Array<DoctorWhere>>;
  NOT?: InputMaybe<DoctorWhere>;
  OR?: InputMaybe<Array<DoctorWhere>>;
  address?: InputMaybe<PostalAddressWhere>;
  addressAggregate?: InputMaybe<DoctorAddressAggregateInput>;
  addressConnection?: InputMaybe<DoctorAddressConnectionWhere>;
  addressConnection_NOT?: InputMaybe<DoctorAddressConnectionWhere>;
  address_NOT?: InputMaybe<PostalAddressWhere>;
  betatester?: InputMaybe<Scalars['Boolean']['input']>;
  configurationsAggregate?: InputMaybe<DoctorConfigurationsAggregateInput>;
  /** Return Doctors where all of the related DoctorConfigurationsConnections match this filter */
  configurationsConnection_ALL?: InputMaybe<DoctorConfigurationsConnectionWhere>;
  /** Return Doctors where none of the related DoctorConfigurationsConnections match this filter */
  configurationsConnection_NONE?: InputMaybe<DoctorConfigurationsConnectionWhere>;
  /** Return Doctors where one of the related DoctorConfigurationsConnections match this filter */
  configurationsConnection_SINGLE?: InputMaybe<DoctorConfigurationsConnectionWhere>;
  /** Return Doctors where some of the related DoctorConfigurationsConnections match this filter */
  configurationsConnection_SOME?: InputMaybe<DoctorConfigurationsConnectionWhere>;
  /** Return Doctors where all of the related Configurations match this filter */
  configurations_ALL?: InputMaybe<ConfigurationWhere>;
  /** Return Doctors where none of the related Configurations match this filter */
  configurations_NONE?: InputMaybe<ConfigurationWhere>;
  /** Return Doctors where one of the related Configurations match this filter */
  configurations_SINGLE?: InputMaybe<ConfigurationWhere>;
  /** Return Doctors where some of the related Configurations match this filter */
  configurations_SOME?: InputMaybe<ConfigurationWhere>;
  email?: InputMaybe<Scalars['String']['input']>;
  email_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  email_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  email_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  email_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  fakeEmail?: InputMaybe<Scalars['Boolean']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  firstNameNormalized?: InputMaybe<Scalars['String']['input']>;
  firstNameNormalized_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  firstNameNormalized_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  firstNameNormalized_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  firstNameNormalized_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  firstName_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  firstName_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  firstName_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  firstName_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  institutionsAggregate?: InputMaybe<DoctorInstitutionsAggregateInput>;
  /** Return Doctors where all of the related DoctorInstitutionsConnections match this filter */
  institutionsConnection_ALL?: InputMaybe<DoctorInstitutionsConnectionWhere>;
  /** Return Doctors where none of the related DoctorInstitutionsConnections match this filter */
  institutionsConnection_NONE?: InputMaybe<DoctorInstitutionsConnectionWhere>;
  /** Return Doctors where one of the related DoctorInstitutionsConnections match this filter */
  institutionsConnection_SINGLE?: InputMaybe<DoctorInstitutionsConnectionWhere>;
  /** Return Doctors where some of the related DoctorInstitutionsConnections match this filter */
  institutionsConnection_SOME?: InputMaybe<DoctorInstitutionsConnectionWhere>;
  /** Return Doctors where all of the related Institutions match this filter */
  institutions_ALL?: InputMaybe<InstitutionWhere>;
  /** Return Doctors where none of the related Institutions match this filter */
  institutions_NONE?: InputMaybe<InstitutionWhere>;
  /** Return Doctors where one of the related Institutions match this filter */
  institutions_SINGLE?: InputMaybe<InstitutionWhere>;
  /** Return Doctors where some of the related Institutions match this filter */
  institutions_SOME?: InputMaybe<InstitutionWhere>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastNameNormalized?: InputMaybe<Scalars['String']['input']>;
  lastNameNormalized_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  lastNameNormalized_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  lastNameNormalized_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  lastNameNormalized_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  lastName_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  lastName_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  lastName_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  lastName_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phone_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  phone_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  phone_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  phone_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  rpps?: InputMaybe<Scalars['String']['input']>;
  rpps_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  rpps_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  rpps_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  rpps_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  speciality?: InputMaybe<SpecialityWhere>;
  specialityAggregate?: InputMaybe<DoctorSpecialityAggregateInput>;
  specialityConnection?: InputMaybe<DoctorSpecialityConnectionWhere>;
  specialityConnection_NOT?: InputMaybe<DoctorSpecialityConnectionWhere>;
  speciality_NOT?: InputMaybe<SpecialityWhere>;
};

export type DoctorsConnection = {
  __typename?: 'DoctorsConnection';
  edges: Array<DoctorEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Document = {
  __typename?: 'Document';
  uploadUrl?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

export type DocumentAggregateSelection = {
  __typename?: 'DocumentAggregateSelection';
  count: Scalars['Int']['output'];
  uploadUrl: StringAggregateSelection;
  url: StringAggregateSelection;
};

export type DocumentCreateInput = {
  uploadUrl?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type DocumentEdge = {
  __typename?: 'DocumentEdge';
  cursor: Scalars['String']['output'];
  node: Document;
};

export type DocumentOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more DocumentSort objects to sort Documents by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<DocumentSort>>;
};

/** Fields to sort Documents by. The order in which sorts are applied is not guaranteed when specifying many fields in one DocumentSort object. */
export type DocumentSort = {
  uploadUrl?: InputMaybe<SortDirection>;
  url?: InputMaybe<SortDirection>;
};

export type DocumentUpdateInput = {
  uploadUrl?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type DocumentWhere = {
  AND?: InputMaybe<Array<DocumentWhere>>;
  NOT?: InputMaybe<DocumentWhere>;
  OR?: InputMaybe<Array<DocumentWhere>>;
  uploadUrl?: InputMaybe<Scalars['String']['input']>;
  uploadUrl_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  uploadUrl_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  uploadUrl_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  uploadUrl_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  url_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  url_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  url_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  url_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type DocumentsConnection = {
  __typename?: 'DocumentsConnection';
  edges: Array<DocumentEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Editor = Doctor | Institution | Manager;

export type EditorWhere = {
  Doctor?: InputMaybe<DoctorWhere>;
  Institution?: InputMaybe<InstitutionWhere>;
  Manager?: InputMaybe<ManagerWhere>;
};

export type ExportAnswersByWorkflow = {
  __typename?: 'ExportAnswersByWorkflow';
  xValues?: Maybe<Array<Scalars['String']['output']>>;
  yValues?: Maybe<Array<Scalars['String']['output']>>;
};

export type ExportColumn = {
  __typename?: 'ExportColumn';
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type ExportCriterion = {
  questionName: Scalars['String']['input'];
  questionnaireId: Scalars['ID']['input'];
};

export type ExportFilter = {
  comparator: ConditionComparison;
  criterion: ExportCriterion;
  isIdentity?: InputMaybe<Scalars['Boolean']['input']>;
  value: Scalars['String']['input'];
};

export type ExportFilterGroup = {
  filters: Array<ExportFilter>;
};

export type ExportInterviewsByWorkflow = {
  __typename?: 'ExportInterviewsByWorkflow';
  interviewsByWorkflow: Array<InterviewsByWorkflow>;
  periodType: Scalars['String']['output'];
};

export type ExportParams = {
  anonymous?: InputMaybe<Scalars['Boolean']['input']>;
  criteria: Array<ExportCriterion>;
  filterByDoctor: Scalars['Boolean']['input'];
  filters: Array<ExportFilterGroup>;
  from: Scalars['Date']['input'];
  hasContact: Scalars['Boolean']['input'];
  institutionId: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  to: Scalars['Date']['input'];
  workflowId?: InputMaybe<Scalars['String']['input']>;
};

export type ExportRow = {
  __typename?: 'ExportRow';
  columns: Array<ExportColumn>;
};

export type ExportTable = {
  __typename?: 'ExportTable';
  csvLink: Scalars['String']['output'];
  labels: Array<Scalars['String']['output']>;
  rows: Array<ExportRow>;
  total: Scalars['Int']['output'];
};

export type FieldInput = {
  boolValue?: InputMaybe<Scalars['Boolean']['input']>;
  intValue?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  stringValue?: InputMaybe<Scalars['String']['input']>;
};

export type FloatAggregateSelection = {
  __typename?: 'FloatAggregateSelection';
  average?: Maybe<Scalars['Float']['output']>;
  max?: Maybe<Scalars['Float']['output']>;
  min?: Maybe<Scalars['Float']['output']>;
  sum?: Maybe<Scalars['Float']['output']>;
};

/** The input for filtering a float */
export type FloatWhere = {
  max?: InputMaybe<Scalars['Float']['input']>;
  min?: InputMaybe<Scalars['Float']['input']>;
};

export type IdAggregateSelection = {
  __typename?: 'IDAggregateSelection';
  longest?: Maybe<Scalars['ID']['output']>;
  shortest?: Maybe<Scalars['ID']['output']>;
};

export enum IdentityField {
  AdditionalAddressInfo = 'AdditionalAddressInfo',
  BirthName = 'BirthName',
  Birthdate = 'Birthdate',
  City = 'City',
  ContactEmail = 'ContactEmail',
  FirstName = 'FirstName',
  Gender = 'Gender',
  LastName = 'LastName',
  Phone = 'Phone',
  PostalCode = 'PostalCode'
}

export type Institution = {
  __typename?: 'Institution';
  address?: Maybe<PostalAddress>;
  addressAggregate?: Maybe<InstitutionPostalAddressAddressAggregationSelection>;
  addressConnection: InstitutionAddressConnection;
  configurations: Array<Configuration>;
  configurationsAggregate?: Maybe<InstitutionConfigurationConfigurationsAggregationSelection>;
  configurationsConnection: InstitutionConfigurationsConnection;
  devices: Array<Device>;
  devicesAggregate?: Maybe<InstitutionDeviceDevicesAggregationSelection>;
  devicesConnection: InstitutionDevicesConnection;
  doctors: Array<Doctor>;
  doctorsAggregate?: Maybe<InstitutionDoctorDoctorsAggregationSelection>;
  doctorsConnection: InstitutionDoctorsConnection;
  id: Scalars['ID']['output'];
  links: Array<WorkflowLink>;
  linksAggregate?: Maybe<InstitutionWorkflowLinkLinksAggregationSelection>;
  linksConnection: InstitutionLinksConnection;
  name: Scalars['String']['output'];
  nameNormalized: Scalars['String']['output'];
  operatingMode: OperatingMode;
  subscriptionPlan: SubscriptionPlan;
};


export type InstitutionAddressArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<PostalAddressOptions>;
  where?: InputMaybe<PostalAddressWhere>;
};


export type InstitutionAddressAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<PostalAddressWhere>;
};


export type InstitutionAddressConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InstitutionAddressConnectionSort>>;
  where?: InputMaybe<InstitutionAddressConnectionWhere>;
};


export type InstitutionConfigurationsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<ConfigurationOptions>;
  where?: InputMaybe<ConfigurationWhere>;
};


export type InstitutionConfigurationsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<ConfigurationWhere>;
};


export type InstitutionConfigurationsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InstitutionConfigurationsConnectionSort>>;
  where?: InputMaybe<InstitutionConfigurationsConnectionWhere>;
};


export type InstitutionDevicesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<DeviceOptions>;
  where?: InputMaybe<DeviceWhere>;
};


export type InstitutionDevicesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<DeviceWhere>;
};


export type InstitutionDevicesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InstitutionDevicesConnectionSort>>;
  where?: InputMaybe<InstitutionDevicesConnectionWhere>;
};


export type InstitutionDoctorsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<DoctorOptions>;
  where?: InputMaybe<DoctorWhere>;
};


export type InstitutionDoctorsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<DoctorWhere>;
};


export type InstitutionDoctorsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InstitutionDoctorsConnectionSort>>;
  where?: InputMaybe<InstitutionDoctorsConnectionWhere>;
};


export type InstitutionLinksArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<WorkflowLinkOptions>;
  where?: InputMaybe<WorkflowLinkWhere>;
};


export type InstitutionLinksAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<WorkflowLinkWhere>;
};


export type InstitutionLinksConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InstitutionLinksConnectionSort>>;
  where?: InputMaybe<InstitutionLinksConnectionWhere>;
};

export type InstitutionAddressAggregateInput = {
  AND?: InputMaybe<Array<InstitutionAddressAggregateInput>>;
  NOT?: InputMaybe<InstitutionAddressAggregateInput>;
  OR?: InputMaybe<Array<InstitutionAddressAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<InstitutionAddressNodeAggregationWhereInput>;
};

export type InstitutionAddressConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<PostalAddressConnectWhere>;
};

export type InstitutionAddressConnection = {
  __typename?: 'InstitutionAddressConnection';
  edges: Array<InstitutionAddressRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type InstitutionAddressConnectionSort = {
  node?: InputMaybe<PostalAddressSort>;
};

export type InstitutionAddressConnectionWhere = {
  AND?: InputMaybe<Array<InstitutionAddressConnectionWhere>>;
  NOT?: InputMaybe<InstitutionAddressConnectionWhere>;
  OR?: InputMaybe<Array<InstitutionAddressConnectionWhere>>;
  node?: InputMaybe<PostalAddressWhere>;
};

export type InstitutionAddressCreateFieldInput = {
  node: PostalAddressCreateInput;
};

export type InstitutionAddressDeleteFieldInput = {
  where?: InputMaybe<InstitutionAddressConnectionWhere>;
};

export type InstitutionAddressDisconnectFieldInput = {
  where?: InputMaybe<InstitutionAddressConnectionWhere>;
};

export type InstitutionAddressFieldInput = {
  connect?: InputMaybe<InstitutionAddressConnectFieldInput>;
  create?: InputMaybe<InstitutionAddressCreateFieldInput>;
};

export type InstitutionAddressNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InstitutionAddressNodeAggregationWhereInput>>;
  NOT?: InputMaybe<InstitutionAddressNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<InstitutionAddressNodeAggregationWhereInput>>;
  city_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  city_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  postalCode_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  street_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  street_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  street_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  street_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  street_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  street_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  street_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  street_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  street_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  street_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  street_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  street_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  street_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  street_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  street_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type InstitutionAddressRelationship = {
  __typename?: 'InstitutionAddressRelationship';
  cursor: Scalars['String']['output'];
  node: PostalAddress;
};

export type InstitutionAddressUpdateConnectionInput = {
  node?: InputMaybe<PostalAddressUpdateInput>;
};

export type InstitutionAddressUpdateFieldInput = {
  connect?: InputMaybe<InstitutionAddressConnectFieldInput>;
  create?: InputMaybe<InstitutionAddressCreateFieldInput>;
  delete?: InputMaybe<InstitutionAddressDeleteFieldInput>;
  disconnect?: InputMaybe<InstitutionAddressDisconnectFieldInput>;
  update?: InputMaybe<InstitutionAddressUpdateConnectionInput>;
  where?: InputMaybe<InstitutionAddressConnectionWhere>;
};

export type InstitutionAggregateSelection = {
  __typename?: 'InstitutionAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type InstitutionConfigurationConfigurationsAggregationSelection = {
  __typename?: 'InstitutionConfigurationConfigurationsAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<InstitutionConfigurationConfigurationsNodeAggregateSelection>;
};

export type InstitutionConfigurationConfigurationsNodeAggregateSelection = {
  __typename?: 'InstitutionConfigurationConfigurationsNodeAggregateSelection';
  dashboardLayout: StringAggregateSelection;
  id: IdAggregateSelection;
};

export type InstitutionConfigurationsAggregateInput = {
  AND?: InputMaybe<Array<InstitutionConfigurationsAggregateInput>>;
  NOT?: InputMaybe<InstitutionConfigurationsAggregateInput>;
  OR?: InputMaybe<Array<InstitutionConfigurationsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<InstitutionConfigurationsNodeAggregationWhereInput>;
};

export type InstitutionConfigurationsConnectFieldInput = {
  connect?: InputMaybe<Array<ConfigurationConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<ConfigurationConnectWhere>;
};

export type InstitutionConfigurationsConnectOrCreateFieldInput = {
  onCreate: InstitutionConfigurationsConnectOrCreateFieldInputOnCreate;
  where: ConfigurationConnectOrCreateWhere;
};

export type InstitutionConfigurationsConnectOrCreateFieldInputOnCreate = {
  node: ConfigurationOnCreateInput;
};

export type InstitutionConfigurationsConnection = {
  __typename?: 'InstitutionConfigurationsConnection';
  edges: Array<InstitutionConfigurationsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type InstitutionConfigurationsConnectionSort = {
  node?: InputMaybe<ConfigurationSort>;
};

export type InstitutionConfigurationsConnectionWhere = {
  AND?: InputMaybe<Array<InstitutionConfigurationsConnectionWhere>>;
  NOT?: InputMaybe<InstitutionConfigurationsConnectionWhere>;
  OR?: InputMaybe<Array<InstitutionConfigurationsConnectionWhere>>;
  node?: InputMaybe<ConfigurationWhere>;
};

export type InstitutionConfigurationsCreateFieldInput = {
  node: ConfigurationCreateInput;
};

export type InstitutionConfigurationsDeleteFieldInput = {
  delete?: InputMaybe<ConfigurationDeleteInput>;
  where?: InputMaybe<InstitutionConfigurationsConnectionWhere>;
};

export type InstitutionConfigurationsDisconnectFieldInput = {
  disconnect?: InputMaybe<ConfigurationDisconnectInput>;
  where?: InputMaybe<InstitutionConfigurationsConnectionWhere>;
};

export type InstitutionConfigurationsFieldInput = {
  connect?: InputMaybe<Array<InstitutionConfigurationsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<InstitutionConfigurationsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<InstitutionConfigurationsCreateFieldInput>>;
};

export type InstitutionConfigurationsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InstitutionConfigurationsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<InstitutionConfigurationsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<InstitutionConfigurationsNodeAggregationWhereInput>>;
  dashboardLayout_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  dashboardLayout_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  dashboardLayout_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  dashboardLayout_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  dashboardLayout_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  dashboardLayout_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  dashboardLayout_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type InstitutionConfigurationsRelationship = {
  __typename?: 'InstitutionConfigurationsRelationship';
  cursor: Scalars['String']['output'];
  node: Configuration;
};

export type InstitutionConfigurationsUpdateConnectionInput = {
  node?: InputMaybe<ConfigurationUpdateInput>;
};

export type InstitutionConfigurationsUpdateFieldInput = {
  connect?: InputMaybe<Array<InstitutionConfigurationsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<InstitutionConfigurationsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<InstitutionConfigurationsCreateFieldInput>>;
  delete?: InputMaybe<Array<InstitutionConfigurationsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<InstitutionConfigurationsDisconnectFieldInput>>;
  update?: InputMaybe<InstitutionConfigurationsUpdateConnectionInput>;
  where?: InputMaybe<InstitutionConfigurationsConnectionWhere>;
};

export type InstitutionConnectInput = {
  address?: InputMaybe<InstitutionAddressConnectFieldInput>;
  configurations?: InputMaybe<Array<InstitutionConfigurationsConnectFieldInput>>;
  devices?: InputMaybe<Array<InstitutionDevicesConnectFieldInput>>;
  doctors?: InputMaybe<Array<InstitutionDoctorsConnectFieldInput>>;
  links?: InputMaybe<Array<InstitutionLinksConnectFieldInput>>;
};

export type InstitutionConnectOrCreateInput = {
  configurations?: InputMaybe<Array<InstitutionConfigurationsConnectOrCreateFieldInput>>;
  devices?: InputMaybe<Array<InstitutionDevicesConnectOrCreateFieldInput>>;
  doctors?: InputMaybe<Array<InstitutionDoctorsConnectOrCreateFieldInput>>;
  links?: InputMaybe<Array<InstitutionLinksConnectOrCreateFieldInput>>;
};

export type InstitutionConnectOrCreateWhere = {
  node: InstitutionUniqueWhere;
};

export type InstitutionConnectWhere = {
  node: InstitutionWhere;
};

export type InstitutionCreateInput = {
  address?: InputMaybe<InstitutionAddressFieldInput>;
  configurations?: InputMaybe<InstitutionConfigurationsFieldInput>;
  devices?: InputMaybe<InstitutionDevicesFieldInput>;
  doctors?: InputMaybe<InstitutionDoctorsFieldInput>;
  links?: InputMaybe<InstitutionLinksFieldInput>;
  name: Scalars['String']['input'];
  operatingMode: OperatingMode;
  subscriptionPlan: SubscriptionPlan;
};

export type InstitutionDeleteInput = {
  address?: InputMaybe<InstitutionAddressDeleteFieldInput>;
  configurations?: InputMaybe<Array<InstitutionConfigurationsDeleteFieldInput>>;
  devices?: InputMaybe<Array<InstitutionDevicesDeleteFieldInput>>;
  doctors?: InputMaybe<Array<InstitutionDoctorsDeleteFieldInput>>;
  links?: InputMaybe<Array<InstitutionLinksDeleteFieldInput>>;
};

export type InstitutionDeviceDevicesAggregationSelection = {
  __typename?: 'InstitutionDeviceDevicesAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<InstitutionDeviceDevicesNodeAggregateSelection>;
};

export type InstitutionDeviceDevicesNodeAggregateSelection = {
  __typename?: 'InstitutionDeviceDevicesNodeAggregateSelection';
  deletedAt: DateTimeAggregateSelection;
  name: StringAggregateSelection;
  serial: StringAggregateSelection;
};

export type InstitutionDevicesAggregateInput = {
  AND?: InputMaybe<Array<InstitutionDevicesAggregateInput>>;
  NOT?: InputMaybe<InstitutionDevicesAggregateInput>;
  OR?: InputMaybe<Array<InstitutionDevicesAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<InstitutionDevicesNodeAggregationWhereInput>;
};

export type InstitutionDevicesConnectFieldInput = {
  connect?: InputMaybe<Array<DeviceConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<DeviceConnectWhere>;
};

export type InstitutionDevicesConnectOrCreateFieldInput = {
  onCreate: InstitutionDevicesConnectOrCreateFieldInputOnCreate;
  where: DeviceConnectOrCreateWhere;
};

export type InstitutionDevicesConnectOrCreateFieldInputOnCreate = {
  node: DeviceOnCreateInput;
};

export type InstitutionDevicesConnection = {
  __typename?: 'InstitutionDevicesConnection';
  edges: Array<InstitutionDevicesRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type InstitutionDevicesConnectionSort = {
  node?: InputMaybe<DeviceSort>;
};

export type InstitutionDevicesConnectionWhere = {
  AND?: InputMaybe<Array<InstitutionDevicesConnectionWhere>>;
  NOT?: InputMaybe<InstitutionDevicesConnectionWhere>;
  OR?: InputMaybe<Array<InstitutionDevicesConnectionWhere>>;
  node?: InputMaybe<DeviceWhere>;
};

export type InstitutionDevicesCreateFieldInput = {
  node: DeviceCreateInput;
};

export type InstitutionDevicesDeleteFieldInput = {
  delete?: InputMaybe<DeviceDeleteInput>;
  where?: InputMaybe<InstitutionDevicesConnectionWhere>;
};

export type InstitutionDevicesDisconnectFieldInput = {
  disconnect?: InputMaybe<DeviceDisconnectInput>;
  where?: InputMaybe<InstitutionDevicesConnectionWhere>;
};

export type InstitutionDevicesFieldInput = {
  connect?: InputMaybe<Array<InstitutionDevicesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<InstitutionDevicesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<InstitutionDevicesCreateFieldInput>>;
};

export type InstitutionDevicesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InstitutionDevicesNodeAggregationWhereInput>>;
  NOT?: InputMaybe<InstitutionDevicesNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<InstitutionDevicesNodeAggregationWhereInput>>;
  deletedAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  serial_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  serial_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  serial_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  serial_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  serial_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  serial_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  serial_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  serial_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  serial_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  serial_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  serial_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  serial_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  serial_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  serial_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  serial_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type InstitutionDevicesRelationship = {
  __typename?: 'InstitutionDevicesRelationship';
  cursor: Scalars['String']['output'];
  node: Device;
};

export type InstitutionDevicesUpdateConnectionInput = {
  node?: InputMaybe<DeviceUpdateInput>;
};

export type InstitutionDevicesUpdateFieldInput = {
  connect?: InputMaybe<Array<InstitutionDevicesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<InstitutionDevicesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<InstitutionDevicesCreateFieldInput>>;
  delete?: InputMaybe<Array<InstitutionDevicesDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<InstitutionDevicesDisconnectFieldInput>>;
  update?: InputMaybe<InstitutionDevicesUpdateConnectionInput>;
  where?: InputMaybe<InstitutionDevicesConnectionWhere>;
};

export type InstitutionDisconnectInput = {
  address?: InputMaybe<InstitutionAddressDisconnectFieldInput>;
  configurations?: InputMaybe<Array<InstitutionConfigurationsDisconnectFieldInput>>;
  devices?: InputMaybe<Array<InstitutionDevicesDisconnectFieldInput>>;
  doctors?: InputMaybe<Array<InstitutionDoctorsDisconnectFieldInput>>;
  links?: InputMaybe<Array<InstitutionLinksDisconnectFieldInput>>;
};

export type InstitutionDoctorDoctorsAggregationSelection = {
  __typename?: 'InstitutionDoctorDoctorsAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<InstitutionDoctorDoctorsNodeAggregateSelection>;
};

export type InstitutionDoctorDoctorsNodeAggregateSelection = {
  __typename?: 'InstitutionDoctorDoctorsNodeAggregateSelection';
  email: StringAggregateSelection;
  firstName: StringAggregateSelection;
  firstNameNormalized: StringAggregateSelection;
  id: IdAggregateSelection;
  lastName: StringAggregateSelection;
  lastNameNormalized: StringAggregateSelection;
  phone: StringAggregateSelection;
  rpps: StringAggregateSelection;
};

export type InstitutionDoctorsAggregateInput = {
  AND?: InputMaybe<Array<InstitutionDoctorsAggregateInput>>;
  NOT?: InputMaybe<InstitutionDoctorsAggregateInput>;
  OR?: InputMaybe<Array<InstitutionDoctorsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<InstitutionDoctorsNodeAggregationWhereInput>;
};

export type InstitutionDoctorsConnectFieldInput = {
  connect?: InputMaybe<Array<DoctorConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<DoctorConnectWhere>;
};

export type InstitutionDoctorsConnectOrCreateFieldInput = {
  onCreate: InstitutionDoctorsConnectOrCreateFieldInputOnCreate;
  where: DoctorConnectOrCreateWhere;
};

export type InstitutionDoctorsConnectOrCreateFieldInputOnCreate = {
  node: DoctorOnCreateInput;
};

export type InstitutionDoctorsConnection = {
  __typename?: 'InstitutionDoctorsConnection';
  edges: Array<InstitutionDoctorsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type InstitutionDoctorsConnectionSort = {
  node?: InputMaybe<DoctorSort>;
};

export type InstitutionDoctorsConnectionWhere = {
  AND?: InputMaybe<Array<InstitutionDoctorsConnectionWhere>>;
  NOT?: InputMaybe<InstitutionDoctorsConnectionWhere>;
  OR?: InputMaybe<Array<InstitutionDoctorsConnectionWhere>>;
  node?: InputMaybe<DoctorWhere>;
};

export type InstitutionDoctorsCreateFieldInput = {
  node: DoctorCreateInput;
};

export type InstitutionDoctorsDeleteFieldInput = {
  delete?: InputMaybe<DoctorDeleteInput>;
  where?: InputMaybe<InstitutionDoctorsConnectionWhere>;
};

export type InstitutionDoctorsDisconnectFieldInput = {
  disconnect?: InputMaybe<DoctorDisconnectInput>;
  where?: InputMaybe<InstitutionDoctorsConnectionWhere>;
};

export type InstitutionDoctorsFieldInput = {
  connect?: InputMaybe<Array<InstitutionDoctorsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<InstitutionDoctorsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<InstitutionDoctorsCreateFieldInput>>;
};

export type InstitutionDoctorsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InstitutionDoctorsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<InstitutionDoctorsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<InstitutionDoctorsNodeAggregationWhereInput>>;
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  phone_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  rpps_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type InstitutionDoctorsRelationship = {
  __typename?: 'InstitutionDoctorsRelationship';
  cursor: Scalars['String']['output'];
  node: Doctor;
};

export type InstitutionDoctorsUpdateConnectionInput = {
  node?: InputMaybe<DoctorUpdateInput>;
};

export type InstitutionDoctorsUpdateFieldInput = {
  connect?: InputMaybe<Array<InstitutionDoctorsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<InstitutionDoctorsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<InstitutionDoctorsCreateFieldInput>>;
  delete?: InputMaybe<Array<InstitutionDoctorsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<InstitutionDoctorsDisconnectFieldInput>>;
  update?: InputMaybe<InstitutionDoctorsUpdateConnectionInput>;
  where?: InputMaybe<InstitutionDoctorsConnectionWhere>;
};

export type InstitutionEdge = {
  __typename?: 'InstitutionEdge';
  cursor: Scalars['String']['output'];
  node: Institution;
};

export type InstitutionFulltext = {
  InstitutionAutocomplete?: InputMaybe<InstitutionInstitutionAutocompleteFulltext>;
};

/** The result of a fulltext search on an index of Institution */
export type InstitutionFulltextResult = {
  __typename?: 'InstitutionFulltextResult';
  institution: Institution;
  score: Scalars['Float']['output'];
};

/** The input for sorting a fulltext query on an index of Institution */
export type InstitutionFulltextSort = {
  institution?: InputMaybe<InstitutionSort>;
  score?: InputMaybe<SortDirection>;
};

/** The input for filtering a fulltext query on an index of Institution */
export type InstitutionFulltextWhere = {
  institution?: InputMaybe<InstitutionWhere>;
  score?: InputMaybe<FloatWhere>;
};

export type InstitutionInstitutionAutocompleteFulltext = {
  phrase: Scalars['String']['input'];
};

export type InstitutionLinksAggregateInput = {
  AND?: InputMaybe<Array<InstitutionLinksAggregateInput>>;
  NOT?: InputMaybe<InstitutionLinksAggregateInput>;
  OR?: InputMaybe<Array<InstitutionLinksAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<InstitutionLinksNodeAggregationWhereInput>;
};

export type InstitutionLinksConnectFieldInput = {
  connect?: InputMaybe<Array<WorkflowLinkConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<WorkflowLinkConnectWhere>;
};

export type InstitutionLinksConnectOrCreateFieldInput = {
  onCreate: InstitutionLinksConnectOrCreateFieldInputOnCreate;
  where: WorkflowLinkConnectOrCreateWhere;
};

export type InstitutionLinksConnectOrCreateFieldInputOnCreate = {
  node: WorkflowLinkOnCreateInput;
};

export type InstitutionLinksConnection = {
  __typename?: 'InstitutionLinksConnection';
  edges: Array<InstitutionLinksRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type InstitutionLinksConnectionSort = {
  node?: InputMaybe<WorkflowLinkSort>;
};

export type InstitutionLinksConnectionWhere = {
  AND?: InputMaybe<Array<InstitutionLinksConnectionWhere>>;
  NOT?: InputMaybe<InstitutionLinksConnectionWhere>;
  OR?: InputMaybe<Array<InstitutionLinksConnectionWhere>>;
  node?: InputMaybe<WorkflowLinkWhere>;
};

export type InstitutionLinksCreateFieldInput = {
  node: WorkflowLinkCreateInput;
};

export type InstitutionLinksDeleteFieldInput = {
  delete?: InputMaybe<WorkflowLinkDeleteInput>;
  where?: InputMaybe<InstitutionLinksConnectionWhere>;
};

export type InstitutionLinksDisconnectFieldInput = {
  disconnect?: InputMaybe<WorkflowLinkDisconnectInput>;
  where?: InputMaybe<InstitutionLinksConnectionWhere>;
};

export type InstitutionLinksFieldInput = {
  connect?: InputMaybe<Array<InstitutionLinksConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<InstitutionLinksConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<InstitutionLinksCreateFieldInput>>;
};

export type InstitutionLinksNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InstitutionLinksNodeAggregationWhereInput>>;
  NOT?: InputMaybe<InstitutionLinksNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<InstitutionLinksNodeAggregationWhereInput>>;
  deletedAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type InstitutionLinksRelationship = {
  __typename?: 'InstitutionLinksRelationship';
  cursor: Scalars['String']['output'];
  node: WorkflowLink;
};

export type InstitutionLinksUpdateConnectionInput = {
  node?: InputMaybe<WorkflowLinkUpdateInput>;
};

export type InstitutionLinksUpdateFieldInput = {
  connect?: InputMaybe<Array<InstitutionLinksConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<InstitutionLinksConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<InstitutionLinksCreateFieldInput>>;
  delete?: InputMaybe<Array<InstitutionLinksDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<InstitutionLinksDisconnectFieldInput>>;
  update?: InputMaybe<InstitutionLinksUpdateConnectionInput>;
  where?: InputMaybe<InstitutionLinksConnectionWhere>;
};

export type InstitutionOnCreateInput = {
  name: Scalars['String']['input'];
  operatingMode: OperatingMode;
  subscriptionPlan: SubscriptionPlan;
};

export type InstitutionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more InstitutionSort objects to sort Institutions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<InstitutionSort>>;
};

export type InstitutionPostalAddressAddressAggregationSelection = {
  __typename?: 'InstitutionPostalAddressAddressAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<InstitutionPostalAddressAddressNodeAggregateSelection>;
};

export type InstitutionPostalAddressAddressNodeAggregateSelection = {
  __typename?: 'InstitutionPostalAddressAddressNodeAggregateSelection';
  city: StringAggregateSelection;
  postalCode: StringAggregateSelection;
  street: StringAggregateSelection;
};

export type InstitutionRelationInput = {
  address?: InputMaybe<InstitutionAddressCreateFieldInput>;
  configurations?: InputMaybe<Array<InstitutionConfigurationsCreateFieldInput>>;
  devices?: InputMaybe<Array<InstitutionDevicesCreateFieldInput>>;
  doctors?: InputMaybe<Array<InstitutionDoctorsCreateFieldInput>>;
  links?: InputMaybe<Array<InstitutionLinksCreateFieldInput>>;
};

/** Fields to sort Institutions by. The order in which sorts are applied is not guaranteed when specifying many fields in one InstitutionSort object. */
export type InstitutionSort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  nameNormalized?: InputMaybe<SortDirection>;
  operatingMode?: InputMaybe<SortDirection>;
  subscriptionPlan?: InputMaybe<SortDirection>;
};

export type InstitutionUniqueWhere = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type InstitutionUpdateInput = {
  address?: InputMaybe<InstitutionAddressUpdateFieldInput>;
  configurations?: InputMaybe<Array<InstitutionConfigurationsUpdateFieldInput>>;
  devices?: InputMaybe<Array<InstitutionDevicesUpdateFieldInput>>;
  doctors?: InputMaybe<Array<InstitutionDoctorsUpdateFieldInput>>;
  links?: InputMaybe<Array<InstitutionLinksUpdateFieldInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
  operatingMode?: InputMaybe<OperatingMode>;
  subscriptionPlan?: InputMaybe<SubscriptionPlan>;
};

export type InstitutionWhere = {
  AND?: InputMaybe<Array<InstitutionWhere>>;
  NOT?: InputMaybe<InstitutionWhere>;
  OR?: InputMaybe<Array<InstitutionWhere>>;
  address?: InputMaybe<PostalAddressWhere>;
  addressAggregate?: InputMaybe<InstitutionAddressAggregateInput>;
  addressConnection?: InputMaybe<InstitutionAddressConnectionWhere>;
  addressConnection_NOT?: InputMaybe<InstitutionAddressConnectionWhere>;
  address_NOT?: InputMaybe<PostalAddressWhere>;
  configurationsAggregate?: InputMaybe<InstitutionConfigurationsAggregateInput>;
  /** Return Institutions where all of the related InstitutionConfigurationsConnections match this filter */
  configurationsConnection_ALL?: InputMaybe<InstitutionConfigurationsConnectionWhere>;
  /** Return Institutions where none of the related InstitutionConfigurationsConnections match this filter */
  configurationsConnection_NONE?: InputMaybe<InstitutionConfigurationsConnectionWhere>;
  /** Return Institutions where one of the related InstitutionConfigurationsConnections match this filter */
  configurationsConnection_SINGLE?: InputMaybe<InstitutionConfigurationsConnectionWhere>;
  /** Return Institutions where some of the related InstitutionConfigurationsConnections match this filter */
  configurationsConnection_SOME?: InputMaybe<InstitutionConfigurationsConnectionWhere>;
  /** Return Institutions where all of the related Configurations match this filter */
  configurations_ALL?: InputMaybe<ConfigurationWhere>;
  /** Return Institutions where none of the related Configurations match this filter */
  configurations_NONE?: InputMaybe<ConfigurationWhere>;
  /** Return Institutions where one of the related Configurations match this filter */
  configurations_SINGLE?: InputMaybe<ConfigurationWhere>;
  /** Return Institutions where some of the related Configurations match this filter */
  configurations_SOME?: InputMaybe<ConfigurationWhere>;
  devicesAggregate?: InputMaybe<InstitutionDevicesAggregateInput>;
  /** Return Institutions where all of the related InstitutionDevicesConnections match this filter */
  devicesConnection_ALL?: InputMaybe<InstitutionDevicesConnectionWhere>;
  /** Return Institutions where none of the related InstitutionDevicesConnections match this filter */
  devicesConnection_NONE?: InputMaybe<InstitutionDevicesConnectionWhere>;
  /** Return Institutions where one of the related InstitutionDevicesConnections match this filter */
  devicesConnection_SINGLE?: InputMaybe<InstitutionDevicesConnectionWhere>;
  /** Return Institutions where some of the related InstitutionDevicesConnections match this filter */
  devicesConnection_SOME?: InputMaybe<InstitutionDevicesConnectionWhere>;
  /** Return Institutions where all of the related Devices match this filter */
  devices_ALL?: InputMaybe<DeviceWhere>;
  /** Return Institutions where none of the related Devices match this filter */
  devices_NONE?: InputMaybe<DeviceWhere>;
  /** Return Institutions where one of the related Devices match this filter */
  devices_SINGLE?: InputMaybe<DeviceWhere>;
  /** Return Institutions where some of the related Devices match this filter */
  devices_SOME?: InputMaybe<DeviceWhere>;
  doctorsAggregate?: InputMaybe<InstitutionDoctorsAggregateInput>;
  /** Return Institutions where all of the related InstitutionDoctorsConnections match this filter */
  doctorsConnection_ALL?: InputMaybe<InstitutionDoctorsConnectionWhere>;
  /** Return Institutions where none of the related InstitutionDoctorsConnections match this filter */
  doctorsConnection_NONE?: InputMaybe<InstitutionDoctorsConnectionWhere>;
  /** Return Institutions where one of the related InstitutionDoctorsConnections match this filter */
  doctorsConnection_SINGLE?: InputMaybe<InstitutionDoctorsConnectionWhere>;
  /** Return Institutions where some of the related InstitutionDoctorsConnections match this filter */
  doctorsConnection_SOME?: InputMaybe<InstitutionDoctorsConnectionWhere>;
  /** Return Institutions where all of the related Doctors match this filter */
  doctors_ALL?: InputMaybe<DoctorWhere>;
  /** Return Institutions where none of the related Doctors match this filter */
  doctors_NONE?: InputMaybe<DoctorWhere>;
  /** Return Institutions where one of the related Doctors match this filter */
  doctors_SINGLE?: InputMaybe<DoctorWhere>;
  /** Return Institutions where some of the related Doctors match this filter */
  doctors_SOME?: InputMaybe<DoctorWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  linksAggregate?: InputMaybe<InstitutionLinksAggregateInput>;
  /** Return Institutions where all of the related InstitutionLinksConnections match this filter */
  linksConnection_ALL?: InputMaybe<InstitutionLinksConnectionWhere>;
  /** Return Institutions where none of the related InstitutionLinksConnections match this filter */
  linksConnection_NONE?: InputMaybe<InstitutionLinksConnectionWhere>;
  /** Return Institutions where one of the related InstitutionLinksConnections match this filter */
  linksConnection_SINGLE?: InputMaybe<InstitutionLinksConnectionWhere>;
  /** Return Institutions where some of the related InstitutionLinksConnections match this filter */
  linksConnection_SOME?: InputMaybe<InstitutionLinksConnectionWhere>;
  /** Return Institutions where all of the related WorkflowLinks match this filter */
  links_ALL?: InputMaybe<WorkflowLinkWhere>;
  /** Return Institutions where none of the related WorkflowLinks match this filter */
  links_NONE?: InputMaybe<WorkflowLinkWhere>;
  /** Return Institutions where one of the related WorkflowLinks match this filter */
  links_SINGLE?: InputMaybe<WorkflowLinkWhere>;
  /** Return Institutions where some of the related WorkflowLinks match this filter */
  links_SOME?: InputMaybe<WorkflowLinkWhere>;
  name?: InputMaybe<Scalars['String']['input']>;
  nameNormalized?: InputMaybe<Scalars['String']['input']>;
  nameNormalized_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  nameNormalized_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  nameNormalized_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  nameNormalized_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  operatingMode?: InputMaybe<OperatingMode>;
  operatingMode_IN?: InputMaybe<Array<OperatingMode>>;
  subscriptionPlan?: InputMaybe<SubscriptionPlan>;
  subscriptionPlan_IN?: InputMaybe<Array<SubscriptionPlan>>;
};

export type InstitutionWorkflowLinkLinksAggregationSelection = {
  __typename?: 'InstitutionWorkflowLinkLinksAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<InstitutionWorkflowLinkLinksNodeAggregateSelection>;
};

export type InstitutionWorkflowLinkLinksNodeAggregateSelection = {
  __typename?: 'InstitutionWorkflowLinkLinksNodeAggregateSelection';
  deletedAt: DateTimeAggregateSelection;
  id: StringAggregateSelection;
  name: StringAggregateSelection;
};

export type InstitutionsConnection = {
  __typename?: 'InstitutionsConnection';
  edges: Array<InstitutionEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type IntAggregateSelection = {
  __typename?: 'IntAggregateSelection';
  average?: Maybe<Scalars['Float']['output']>;
  max?: Maybe<Scalars['Int']['output']>;
  min?: Maybe<Scalars['Int']['output']>;
  sum?: Maybe<Scalars['Int']['output']>;
};

export type Interview = {
  __typename?: 'Interview';
  alert: AlertLevel;
  alerts: Array<Maybe<QuestionnaireAlerts>>;
  answers: Array<Answer>;
  answersAggregate?: Maybe<InterviewAnswerAnswersAggregationSelection>;
  answersConnection: InterviewAnswersConnection;
  completed?: Maybe<Scalars['Boolean']['output']>;
  createdAt: Scalars['DateTime']['output'];
  doctor?: Maybe<Doctor>;
  doctorAggregate?: Maybe<InterviewDoctorDoctorAggregationSelection>;
  doctorConnection: InterviewDoctorConnection;
  graphs: Array<VersionnedGraph>;
  id: Scalars['ID']['output'];
  link: Link;
  linkConnection: InterviewLinkConnection;
  opened?: Maybe<Scalars['Boolean']['output']>;
  patient?: Maybe<Patient>;
  patientAggregate?: Maybe<InterviewPatientPatientAggregationSelection>;
  patientConnection: InterviewPatientConnection;
  scored: Array<VersionnedGraph>;
  scoredAggregate?: Maybe<InterviewVersionnedGraphScoredAggregationSelection>;
  scoredConnection: InterviewScoredConnection;
  thirdParty?: Maybe<Scalars['Boolean']['output']>;
};


export type InterviewAnswersArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AnswerOptions>;
  where?: InputMaybe<AnswerWhere>;
};


export type InterviewAnswersAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AnswerWhere>;
};


export type InterviewAnswersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InterviewAnswersConnectionSort>>;
  where?: InputMaybe<InterviewAnswersConnectionWhere>;
};


export type InterviewDoctorArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<DoctorOptions>;
  where?: InputMaybe<DoctorWhere>;
};


export type InterviewDoctorAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<DoctorWhere>;
};


export type InterviewDoctorConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InterviewDoctorConnectionSort>>;
  where?: InputMaybe<InterviewDoctorConnectionWhere>;
};


export type InterviewLinkArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QueryOptions>;
  where?: InputMaybe<LinkWhere>;
};


export type InterviewLinkConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<InterviewLinkConnectionWhere>;
};


export type InterviewPatientArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<PatientOptions>;
  where?: InputMaybe<PatientWhere>;
};


export type InterviewPatientAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<PatientWhere>;
};


export type InterviewPatientConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InterviewPatientConnectionSort>>;
  where?: InputMaybe<InterviewPatientConnectionWhere>;
};


export type InterviewScoredArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type InterviewScoredAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type InterviewScoredConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InterviewScoredConnectionSort>>;
  where?: InputMaybe<InterviewScoredConnectionWhere>;
};

export type InterviewAggregateSelection = {
  __typename?: 'InterviewAggregateSelection';
  count: Scalars['Int']['output'];
  createdAt: DateTimeAggregateSelection;
  id: IdAggregateSelection;
};

export type InterviewAnswerAnswersAggregationSelection = {
  __typename?: 'InterviewAnswerAnswersAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<InterviewAnswerAnswersNodeAggregateSelection>;
};

export type InterviewAnswerAnswersNodeAggregateSelection = {
  __typename?: 'InterviewAnswerAnswersNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type InterviewAnswersAggregateInput = {
  AND?: InputMaybe<Array<InterviewAnswersAggregateInput>>;
  NOT?: InputMaybe<InterviewAnswersAggregateInput>;
  OR?: InputMaybe<Array<InterviewAnswersAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<InterviewAnswersNodeAggregationWhereInput>;
};

export type InterviewAnswersConnectFieldInput = {
  connect?: InputMaybe<Array<AnswerConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AnswerConnectWhere>;
};

export type InterviewAnswersConnection = {
  __typename?: 'InterviewAnswersConnection';
  edges: Array<InterviewAnswersRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type InterviewAnswersConnectionSort = {
  node?: InputMaybe<AnswerSort>;
};

export type InterviewAnswersConnectionWhere = {
  AND?: InputMaybe<Array<InterviewAnswersConnectionWhere>>;
  NOT?: InputMaybe<InterviewAnswersConnectionWhere>;
  OR?: InputMaybe<Array<InterviewAnswersConnectionWhere>>;
  node?: InputMaybe<AnswerWhere>;
};

export type InterviewAnswersCreateFieldInput = {
  node: AnswerCreateInput;
};

export type InterviewAnswersDeleteFieldInput = {
  delete?: InputMaybe<AnswerDeleteInput>;
  where?: InputMaybe<InterviewAnswersConnectionWhere>;
};

export type InterviewAnswersDisconnectFieldInput = {
  disconnect?: InputMaybe<AnswerDisconnectInput>;
  where?: InputMaybe<InterviewAnswersConnectionWhere>;
};

export type InterviewAnswersFieldInput = {
  connect?: InputMaybe<Array<InterviewAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<InterviewAnswersCreateFieldInput>>;
};

export type InterviewAnswersNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InterviewAnswersNodeAggregationWhereInput>>;
  NOT?: InputMaybe<InterviewAnswersNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<InterviewAnswersNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  field_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  field_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  hint_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type InterviewAnswersRelationship = {
  __typename?: 'InterviewAnswersRelationship';
  cursor: Scalars['String']['output'];
  node: Answer;
};

export type InterviewAnswersUpdateConnectionInput = {
  node?: InputMaybe<AnswerUpdateInput>;
};

export type InterviewAnswersUpdateFieldInput = {
  connect?: InputMaybe<Array<InterviewAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<InterviewAnswersCreateFieldInput>>;
  delete?: InputMaybe<Array<InterviewAnswersDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<InterviewAnswersDisconnectFieldInput>>;
  update?: InputMaybe<InterviewAnswersUpdateConnectionInput>;
  where?: InputMaybe<InterviewAnswersConnectionWhere>;
};

export type InterviewConnectInput = {
  answers?: InputMaybe<Array<InterviewAnswersConnectFieldInput>>;
  doctor?: InputMaybe<InterviewDoctorConnectFieldInput>;
  link?: InputMaybe<InterviewLinkConnectInput>;
  patient?: InputMaybe<InterviewPatientConnectFieldInput>;
  scored?: InputMaybe<Array<InterviewScoredConnectFieldInput>>;
};

export type InterviewConnectOrCreateInput = {
  doctor?: InputMaybe<InterviewDoctorConnectOrCreateFieldInput>;
  link?: InputMaybe<InterviewLinkConnectOrCreateInput>;
  patient?: InputMaybe<InterviewPatientConnectOrCreateFieldInput>;
};

export type InterviewConnectOrCreateWhere = {
  node: InterviewUniqueWhere;
};

export type InterviewConnectWhere = {
  node: InterviewWhere;
};

export type InterviewCreateInput = {
  answers?: InputMaybe<InterviewAnswersFieldInput>;
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  doctor?: InputMaybe<InterviewDoctorFieldInput>;
  link?: InputMaybe<InterviewLinkCreateInput>;
  opened?: InputMaybe<Scalars['Boolean']['input']>;
  patient?: InputMaybe<InterviewPatientFieldInput>;
  scored?: InputMaybe<InterviewScoredFieldInput>;
};

export type InterviewDeleteInput = {
  answers?: InputMaybe<Array<InterviewAnswersDeleteFieldInput>>;
  doctor?: InputMaybe<InterviewDoctorDeleteFieldInput>;
  link?: InputMaybe<InterviewLinkDeleteInput>;
  patient?: InputMaybe<InterviewPatientDeleteFieldInput>;
  scored?: InputMaybe<Array<InterviewScoredDeleteFieldInput>>;
};

export type InterviewDisconnectInput = {
  answers?: InputMaybe<Array<InterviewAnswersDisconnectFieldInput>>;
  doctor?: InputMaybe<InterviewDoctorDisconnectFieldInput>;
  link?: InputMaybe<InterviewLinkDisconnectInput>;
  patient?: InputMaybe<InterviewPatientDisconnectFieldInput>;
  scored?: InputMaybe<Array<InterviewScoredDisconnectFieldInput>>;
};

export type InterviewDoctorAggregateInput = {
  AND?: InputMaybe<Array<InterviewDoctorAggregateInput>>;
  NOT?: InputMaybe<InterviewDoctorAggregateInput>;
  OR?: InputMaybe<Array<InterviewDoctorAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<InterviewDoctorNodeAggregationWhereInput>;
};

export type InterviewDoctorConnectFieldInput = {
  connect?: InputMaybe<DoctorConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<DoctorConnectWhere>;
};

export type InterviewDoctorConnectOrCreateFieldInput = {
  onCreate: InterviewDoctorConnectOrCreateFieldInputOnCreate;
  where: DoctorConnectOrCreateWhere;
};

export type InterviewDoctorConnectOrCreateFieldInputOnCreate = {
  node: DoctorOnCreateInput;
};

export type InterviewDoctorConnection = {
  __typename?: 'InterviewDoctorConnection';
  edges: Array<InterviewDoctorRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type InterviewDoctorConnectionSort = {
  node?: InputMaybe<DoctorSort>;
};

export type InterviewDoctorConnectionWhere = {
  AND?: InputMaybe<Array<InterviewDoctorConnectionWhere>>;
  NOT?: InputMaybe<InterviewDoctorConnectionWhere>;
  OR?: InputMaybe<Array<InterviewDoctorConnectionWhere>>;
  node?: InputMaybe<DoctorWhere>;
};

export type InterviewDoctorCreateFieldInput = {
  node: DoctorCreateInput;
};

export type InterviewDoctorDeleteFieldInput = {
  delete?: InputMaybe<DoctorDeleteInput>;
  where?: InputMaybe<InterviewDoctorConnectionWhere>;
};

export type InterviewDoctorDisconnectFieldInput = {
  disconnect?: InputMaybe<DoctorDisconnectInput>;
  where?: InputMaybe<InterviewDoctorConnectionWhere>;
};

export type InterviewDoctorDoctorAggregationSelection = {
  __typename?: 'InterviewDoctorDoctorAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<InterviewDoctorDoctorNodeAggregateSelection>;
};

export type InterviewDoctorDoctorNodeAggregateSelection = {
  __typename?: 'InterviewDoctorDoctorNodeAggregateSelection';
  email: StringAggregateSelection;
  firstName: StringAggregateSelection;
  firstNameNormalized: StringAggregateSelection;
  id: IdAggregateSelection;
  lastName: StringAggregateSelection;
  lastNameNormalized: StringAggregateSelection;
  phone: StringAggregateSelection;
  rpps: StringAggregateSelection;
};

export type InterviewDoctorFieldInput = {
  connect?: InputMaybe<InterviewDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<InterviewDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<InterviewDoctorCreateFieldInput>;
};

export type InterviewDoctorNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InterviewDoctorNodeAggregationWhereInput>>;
  NOT?: InputMaybe<InterviewDoctorNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<InterviewDoctorNodeAggregationWhereInput>>;
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  phone_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  rpps_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type InterviewDoctorRelationship = {
  __typename?: 'InterviewDoctorRelationship';
  cursor: Scalars['String']['output'];
  node: Doctor;
};

export type InterviewDoctorUpdateConnectionInput = {
  node?: InputMaybe<DoctorUpdateInput>;
};

export type InterviewDoctorUpdateFieldInput = {
  connect?: InputMaybe<InterviewDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<InterviewDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<InterviewDoctorCreateFieldInput>;
  delete?: InputMaybe<InterviewDoctorDeleteFieldInput>;
  disconnect?: InputMaybe<InterviewDoctorDisconnectFieldInput>;
  update?: InputMaybe<InterviewDoctorUpdateConnectionInput>;
  where?: InputMaybe<InterviewDoctorConnectionWhere>;
};

export type InterviewEdge = {
  __typename?: 'InterviewEdge';
  cursor: Scalars['String']['output'];
  node: Interview;
};

export type InterviewLinkConnectInput = {
  Device?: InputMaybe<InterviewLinkDeviceConnectFieldInput>;
  WorkflowLink?: InputMaybe<InterviewLinkWorkflowLinkConnectFieldInput>;
};

export type InterviewLinkConnectOrCreateInput = {
  Device?: InputMaybe<InterviewLinkDeviceConnectOrCreateFieldInput>;
  WorkflowLink?: InputMaybe<InterviewLinkWorkflowLinkConnectOrCreateFieldInput>;
};

export type InterviewLinkConnection = {
  __typename?: 'InterviewLinkConnection';
  edges: Array<InterviewLinkRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type InterviewLinkConnectionWhere = {
  Device?: InputMaybe<InterviewLinkDeviceConnectionWhere>;
  WorkflowLink?: InputMaybe<InterviewLinkWorkflowLinkConnectionWhere>;
};

export type InterviewLinkCreateFieldInput = {
  Device?: InputMaybe<InterviewLinkDeviceCreateFieldInput>;
  WorkflowLink?: InputMaybe<InterviewLinkWorkflowLinkCreateFieldInput>;
};

export type InterviewLinkCreateInput = {
  Device?: InputMaybe<InterviewLinkDeviceFieldInput>;
  WorkflowLink?: InputMaybe<InterviewLinkWorkflowLinkFieldInput>;
};

export type InterviewLinkDeleteInput = {
  Device?: InputMaybe<InterviewLinkDeviceDeleteFieldInput>;
  WorkflowLink?: InputMaybe<InterviewLinkWorkflowLinkDeleteFieldInput>;
};

export type InterviewLinkDeviceConnectFieldInput = {
  connect?: InputMaybe<DeviceConnectInput>;
  where?: InputMaybe<DeviceConnectWhere>;
};

export type InterviewLinkDeviceConnectOrCreateFieldInput = {
  onCreate: InterviewLinkDeviceConnectOrCreateFieldInputOnCreate;
  where: DeviceConnectOrCreateWhere;
};

export type InterviewLinkDeviceConnectOrCreateFieldInputOnCreate = {
  node: DeviceOnCreateInput;
};

export type InterviewLinkDeviceConnectionWhere = {
  AND?: InputMaybe<Array<InterviewLinkDeviceConnectionWhere>>;
  NOT?: InputMaybe<InterviewLinkDeviceConnectionWhere>;
  OR?: InputMaybe<Array<InterviewLinkDeviceConnectionWhere>>;
  node?: InputMaybe<DeviceWhere>;
};

export type InterviewLinkDeviceCreateFieldInput = {
  node: DeviceCreateInput;
};

export type InterviewLinkDeviceDeleteFieldInput = {
  delete?: InputMaybe<DeviceDeleteInput>;
  where?: InputMaybe<InterviewLinkDeviceConnectionWhere>;
};

export type InterviewLinkDeviceDisconnectFieldInput = {
  disconnect?: InputMaybe<DeviceDisconnectInput>;
  where?: InputMaybe<InterviewLinkDeviceConnectionWhere>;
};

export type InterviewLinkDeviceFieldInput = {
  connect?: InputMaybe<InterviewLinkDeviceConnectFieldInput>;
  connectOrCreate?: InputMaybe<InterviewLinkDeviceConnectOrCreateFieldInput>;
  create?: InputMaybe<InterviewLinkDeviceCreateFieldInput>;
};

export type InterviewLinkDeviceUpdateConnectionInput = {
  node?: InputMaybe<DeviceUpdateInput>;
};

export type InterviewLinkDeviceUpdateFieldInput = {
  connect?: InputMaybe<InterviewLinkDeviceConnectFieldInput>;
  connectOrCreate?: InputMaybe<InterviewLinkDeviceConnectOrCreateFieldInput>;
  create?: InputMaybe<InterviewLinkDeviceCreateFieldInput>;
  delete?: InputMaybe<InterviewLinkDeviceDeleteFieldInput>;
  disconnect?: InputMaybe<InterviewLinkDeviceDisconnectFieldInput>;
  update?: InputMaybe<InterviewLinkDeviceUpdateConnectionInput>;
  where?: InputMaybe<InterviewLinkDeviceConnectionWhere>;
};

export type InterviewLinkDisconnectInput = {
  Device?: InputMaybe<InterviewLinkDeviceDisconnectFieldInput>;
  WorkflowLink?: InputMaybe<InterviewLinkWorkflowLinkDisconnectFieldInput>;
};

export type InterviewLinkRelationship = {
  __typename?: 'InterviewLinkRelationship';
  cursor: Scalars['String']['output'];
  node: Link;
};

export type InterviewLinkUpdateInput = {
  Device?: InputMaybe<InterviewLinkDeviceUpdateFieldInput>;
  WorkflowLink?: InputMaybe<InterviewLinkWorkflowLinkUpdateFieldInput>;
};

export type InterviewLinkWorkflowLinkConnectFieldInput = {
  connect?: InputMaybe<WorkflowLinkConnectInput>;
  where?: InputMaybe<WorkflowLinkConnectWhere>;
};

export type InterviewLinkWorkflowLinkConnectOrCreateFieldInput = {
  onCreate: InterviewLinkWorkflowLinkConnectOrCreateFieldInputOnCreate;
  where: WorkflowLinkConnectOrCreateWhere;
};

export type InterviewLinkWorkflowLinkConnectOrCreateFieldInputOnCreate = {
  node: WorkflowLinkOnCreateInput;
};

export type InterviewLinkWorkflowLinkConnectionWhere = {
  AND?: InputMaybe<Array<InterviewLinkWorkflowLinkConnectionWhere>>;
  NOT?: InputMaybe<InterviewLinkWorkflowLinkConnectionWhere>;
  OR?: InputMaybe<Array<InterviewLinkWorkflowLinkConnectionWhere>>;
  node?: InputMaybe<WorkflowLinkWhere>;
};

export type InterviewLinkWorkflowLinkCreateFieldInput = {
  node: WorkflowLinkCreateInput;
};

export type InterviewLinkWorkflowLinkDeleteFieldInput = {
  delete?: InputMaybe<WorkflowLinkDeleteInput>;
  where?: InputMaybe<InterviewLinkWorkflowLinkConnectionWhere>;
};

export type InterviewLinkWorkflowLinkDisconnectFieldInput = {
  disconnect?: InputMaybe<WorkflowLinkDisconnectInput>;
  where?: InputMaybe<InterviewLinkWorkflowLinkConnectionWhere>;
};

export type InterviewLinkWorkflowLinkFieldInput = {
  connect?: InputMaybe<InterviewLinkWorkflowLinkConnectFieldInput>;
  connectOrCreate?: InputMaybe<InterviewLinkWorkflowLinkConnectOrCreateFieldInput>;
  create?: InputMaybe<InterviewLinkWorkflowLinkCreateFieldInput>;
};

export type InterviewLinkWorkflowLinkUpdateConnectionInput = {
  node?: InputMaybe<WorkflowLinkUpdateInput>;
};

export type InterviewLinkWorkflowLinkUpdateFieldInput = {
  connect?: InputMaybe<InterviewLinkWorkflowLinkConnectFieldInput>;
  connectOrCreate?: InputMaybe<InterviewLinkWorkflowLinkConnectOrCreateFieldInput>;
  create?: InputMaybe<InterviewLinkWorkflowLinkCreateFieldInput>;
  delete?: InputMaybe<InterviewLinkWorkflowLinkDeleteFieldInput>;
  disconnect?: InputMaybe<InterviewLinkWorkflowLinkDisconnectFieldInput>;
  update?: InputMaybe<InterviewLinkWorkflowLinkUpdateConnectionInput>;
  where?: InputMaybe<InterviewLinkWorkflowLinkConnectionWhere>;
};

export type InterviewOnCreateInput = {
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  opened?: InputMaybe<Scalars['Boolean']['input']>;
};

export type InterviewOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more InterviewSort objects to sort Interviews by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<InterviewSort>>;
};

export type InterviewPatientAggregateInput = {
  AND?: InputMaybe<Array<InterviewPatientAggregateInput>>;
  NOT?: InputMaybe<InterviewPatientAggregateInput>;
  OR?: InputMaybe<Array<InterviewPatientAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<InterviewPatientNodeAggregationWhereInput>;
};

export type InterviewPatientConnectFieldInput = {
  connect?: InputMaybe<PatientConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<PatientConnectWhere>;
};

export type InterviewPatientConnectOrCreateFieldInput = {
  onCreate: InterviewPatientConnectOrCreateFieldInputOnCreate;
  where: PatientConnectOrCreateWhere;
};

export type InterviewPatientConnectOrCreateFieldInputOnCreate = {
  node: PatientOnCreateInput;
};

export type InterviewPatientConnection = {
  __typename?: 'InterviewPatientConnection';
  edges: Array<InterviewPatientRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type InterviewPatientConnectionSort = {
  node?: InputMaybe<PatientSort>;
};

export type InterviewPatientConnectionWhere = {
  AND?: InputMaybe<Array<InterviewPatientConnectionWhere>>;
  NOT?: InputMaybe<InterviewPatientConnectionWhere>;
  OR?: InputMaybe<Array<InterviewPatientConnectionWhere>>;
  node?: InputMaybe<PatientWhere>;
};

export type InterviewPatientCreateFieldInput = {
  node: PatientCreateInput;
};

export type InterviewPatientDeleteFieldInput = {
  delete?: InputMaybe<PatientDeleteInput>;
  where?: InputMaybe<InterviewPatientConnectionWhere>;
};

export type InterviewPatientDisconnectFieldInput = {
  disconnect?: InputMaybe<PatientDisconnectInput>;
  where?: InputMaybe<InterviewPatientConnectionWhere>;
};

export type InterviewPatientFieldInput = {
  connect?: InputMaybe<InterviewPatientConnectFieldInput>;
  connectOrCreate?: InputMaybe<InterviewPatientConnectOrCreateFieldInput>;
  create?: InputMaybe<InterviewPatientCreateFieldInput>;
};

export type InterviewPatientNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InterviewPatientNodeAggregationWhereInput>>;
  NOT?: InputMaybe<InterviewPatientNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<InterviewPatientNodeAggregationWhereInput>>;
  additionalAddressInfo_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  additionalAddressInfo_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  additionalAddressInfo_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  additionalAddressInfo_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  additionalAddressInfo_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  additionalAddressInfo_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  additionalAddressInfo_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  additionalAddressInfo_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  additionalAddressInfo_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  additionalAddressInfo_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  additionalAddressInfo_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  additionalAddressInfo_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  additionalAddressInfo_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  additionalAddressInfo_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  additionalAddressInfo_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  birthName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  birthName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  birthName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  birthName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  birthName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  birthName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  birthName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  birthName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  birthName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  birthName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  birthName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  birthName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  birthName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  birthName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  birthName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  city_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  city_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  city_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  city_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  city_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  contactEmail_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  contactEmail_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  contactEmail_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  contactEmail_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  contactEmail_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  contactEmail_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  contactEmail_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  contactEmail_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  contactEmail_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  contactEmail_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  contactEmail_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  contactEmail_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  contactEmail_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  contactEmail_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  contactEmail_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  gender_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  gender_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  gender_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  gender_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  gender_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  gender_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  gender_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  gender_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  gender_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  gender_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  gender_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  gender_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  gender_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  gender_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  gender_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  phone_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  postalCode_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  postalCode_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  postalCode_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type InterviewPatientPatientAggregationSelection = {
  __typename?: 'InterviewPatientPatientAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<InterviewPatientPatientNodeAggregateSelection>;
};

export type InterviewPatientPatientNodeAggregateSelection = {
  __typename?: 'InterviewPatientPatientNodeAggregateSelection';
  additionalAddressInfo: StringAggregateSelection;
  birthName: StringAggregateSelection;
  city: StringAggregateSelection;
  contactEmail: StringAggregateSelection;
  email: StringAggregateSelection;
  firstName: StringAggregateSelection;
  firstNameNormalized: StringAggregateSelection;
  gender: StringAggregateSelection;
  id: IdAggregateSelection;
  lastName: StringAggregateSelection;
  lastNameNormalized: StringAggregateSelection;
  phone: StringAggregateSelection;
  postalCode: StringAggregateSelection;
};

export type InterviewPatientRelationship = {
  __typename?: 'InterviewPatientRelationship';
  cursor: Scalars['String']['output'];
  node: Patient;
};

export type InterviewPatientUpdateConnectionInput = {
  node?: InputMaybe<PatientUpdateInput>;
};

export type InterviewPatientUpdateFieldInput = {
  connect?: InputMaybe<InterviewPatientConnectFieldInput>;
  connectOrCreate?: InputMaybe<InterviewPatientConnectOrCreateFieldInput>;
  create?: InputMaybe<InterviewPatientCreateFieldInput>;
  delete?: InputMaybe<InterviewPatientDeleteFieldInput>;
  disconnect?: InputMaybe<InterviewPatientDisconnectFieldInput>;
  update?: InputMaybe<InterviewPatientUpdateConnectionInput>;
  where?: InputMaybe<InterviewPatientConnectionWhere>;
};

export type InterviewRelationInput = {
  answers?: InputMaybe<Array<InterviewAnswersCreateFieldInput>>;
  doctor?: InputMaybe<InterviewDoctorCreateFieldInput>;
  link?: InputMaybe<InterviewLinkCreateFieldInput>;
  patient?: InputMaybe<InterviewPatientCreateFieldInput>;
  scored?: InputMaybe<Array<InterviewScoredCreateFieldInput>>;
};

export type InterviewScoredAggregateInput = {
  AND?: InputMaybe<Array<InterviewScoredAggregateInput>>;
  NOT?: InputMaybe<InterviewScoredAggregateInput>;
  OR?: InputMaybe<Array<InterviewScoredAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<ScoredAggregationWhereInput>;
  node?: InputMaybe<InterviewScoredNodeAggregationWhereInput>;
};

export type InterviewScoredConnectFieldInput = {
  connect?: InputMaybe<Array<VersionnedGraphConnectInput>>;
  edge?: InputMaybe<ScoredCreateInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type InterviewScoredConnection = {
  __typename?: 'InterviewScoredConnection';
  edges: Array<InterviewScoredRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type InterviewScoredConnectionSort = {
  edge?: InputMaybe<ScoredSort>;
  node?: InputMaybe<VersionnedGraphSort>;
};

export type InterviewScoredConnectionWhere = {
  AND?: InputMaybe<Array<InterviewScoredConnectionWhere>>;
  NOT?: InputMaybe<InterviewScoredConnectionWhere>;
  OR?: InputMaybe<Array<InterviewScoredConnectionWhere>>;
  edge?: InputMaybe<ScoredWhere>;
  node?: InputMaybe<VersionnedGraphWhere>;
};

export type InterviewScoredCreateFieldInput = {
  edge?: InputMaybe<ScoredCreateInput>;
  node: VersionnedGraphCreateInput;
};

export type InterviewScoredDeleteFieldInput = {
  delete?: InputMaybe<VersionnedGraphDeleteInput>;
  where?: InputMaybe<InterviewScoredConnectionWhere>;
};

export type InterviewScoredDisconnectFieldInput = {
  disconnect?: InputMaybe<VersionnedGraphDisconnectInput>;
  where?: InputMaybe<InterviewScoredConnectionWhere>;
};

export type InterviewScoredFieldInput = {
  connect?: InputMaybe<Array<InterviewScoredConnectFieldInput>>;
  create?: InputMaybe<Array<InterviewScoredCreateFieldInput>>;
};

export type InterviewScoredNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InterviewScoredNodeAggregationWhereInput>>;
  NOT?: InputMaybe<InterviewScoredNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<InterviewScoredNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type InterviewScoredRelationship = {
  __typename?: 'InterviewScoredRelationship';
  cursor: Scalars['String']['output'];
  node: VersionnedGraph;
  properties: Scored;
};

export type InterviewScoredUpdateConnectionInput = {
  edge?: InputMaybe<ScoredUpdateInput>;
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type InterviewScoredUpdateFieldInput = {
  connect?: InputMaybe<Array<InterviewScoredConnectFieldInput>>;
  create?: InputMaybe<Array<InterviewScoredCreateFieldInput>>;
  delete?: InputMaybe<Array<InterviewScoredDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<InterviewScoredDisconnectFieldInput>>;
  update?: InputMaybe<InterviewScoredUpdateConnectionInput>;
  where?: InputMaybe<InterviewScoredConnectionWhere>;
};

/** Fields to sort Interviews by. The order in which sorts are applied is not guaranteed when specifying many fields in one InterviewSort object. */
export type InterviewSort = {
  alert?: InputMaybe<SortDirection>;
  completed?: InputMaybe<SortDirection>;
  createdAt?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  opened?: InputMaybe<SortDirection>;
  thirdParty?: InputMaybe<SortDirection>;
};

export type InterviewUniqueWhere = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type InterviewUpdateInput = {
  answers?: InputMaybe<Array<InterviewAnswersUpdateFieldInput>>;
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  doctor?: InputMaybe<InterviewDoctorUpdateFieldInput>;
  link?: InputMaybe<InterviewLinkUpdateInput>;
  opened?: InputMaybe<Scalars['Boolean']['input']>;
  patient?: InputMaybe<InterviewPatientUpdateFieldInput>;
  scored?: InputMaybe<Array<InterviewScoredUpdateFieldInput>>;
};

export type InterviewVersionnedGraphScoredAggregationSelection = {
  __typename?: 'InterviewVersionnedGraphScoredAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<InterviewVersionnedGraphScoredEdgeAggregateSelection>;
  node?: Maybe<InterviewVersionnedGraphScoredNodeAggregateSelection>;
};

export type InterviewVersionnedGraphScoredEdgeAggregateSelection = {
  __typename?: 'InterviewVersionnedGraphScoredEdgeAggregateSelection';
  value: IntAggregateSelection;
};

export type InterviewVersionnedGraphScoredNodeAggregateSelection = {
  __typename?: 'InterviewVersionnedGraphScoredNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type InterviewWhere = {
  AND?: InputMaybe<Array<InterviewWhere>>;
  NOT?: InputMaybe<InterviewWhere>;
  OR?: InputMaybe<Array<InterviewWhere>>;
  alert?: InputMaybe<AlertLevel>;
  alert_IN?: InputMaybe<Array<AlertLevel>>;
  alerts?: InputMaybe<QuestionnaireAlertsWhere>;
  alerts_ALL?: InputMaybe<QuestionnaireAlertsWhere>;
  alerts_NONE?: InputMaybe<QuestionnaireAlertsWhere>;
  alerts_SINGLE?: InputMaybe<QuestionnaireAlertsWhere>;
  alerts_SOME?: InputMaybe<QuestionnaireAlertsWhere>;
  answersAggregate?: InputMaybe<InterviewAnswersAggregateInput>;
  /** Return Interviews where all of the related InterviewAnswersConnections match this filter */
  answersConnection_ALL?: InputMaybe<InterviewAnswersConnectionWhere>;
  /** Return Interviews where none of the related InterviewAnswersConnections match this filter */
  answersConnection_NONE?: InputMaybe<InterviewAnswersConnectionWhere>;
  /** Return Interviews where one of the related InterviewAnswersConnections match this filter */
  answersConnection_SINGLE?: InputMaybe<InterviewAnswersConnectionWhere>;
  /** Return Interviews where some of the related InterviewAnswersConnections match this filter */
  answersConnection_SOME?: InputMaybe<InterviewAnswersConnectionWhere>;
  /** Return Interviews where all of the related Answers match this filter */
  answers_ALL?: InputMaybe<AnswerWhere>;
  /** Return Interviews where none of the related Answers match this filter */
  answers_NONE?: InputMaybe<AnswerWhere>;
  /** Return Interviews where one of the related Answers match this filter */
  answers_SINGLE?: InputMaybe<AnswerWhere>;
  /** Return Interviews where some of the related Answers match this filter */
  answers_SOME?: InputMaybe<AnswerWhere>;
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_IN?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  createdAt_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  doctor?: InputMaybe<DoctorWhere>;
  doctorAggregate?: InputMaybe<InterviewDoctorAggregateInput>;
  doctorConnection?: InputMaybe<InterviewDoctorConnectionWhere>;
  doctorConnection_NOT?: InputMaybe<InterviewDoctorConnectionWhere>;
  doctor_NOT?: InputMaybe<DoctorWhere>;
  graphs?: InputMaybe<VersionnedGraphWhere>;
  graphs_ALL?: InputMaybe<VersionnedGraphWhere>;
  graphs_NONE?: InputMaybe<VersionnedGraphWhere>;
  graphs_SINGLE?: InputMaybe<VersionnedGraphWhere>;
  graphs_SOME?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  link?: InputMaybe<LinkWhere>;
  linkConnection?: InputMaybe<InterviewLinkConnectionWhere>;
  linkConnection_NOT?: InputMaybe<InterviewLinkConnectionWhere>;
  link_NOT?: InputMaybe<LinkWhere>;
  opened?: InputMaybe<Scalars['Boolean']['input']>;
  patient?: InputMaybe<PatientWhere>;
  patientAggregate?: InputMaybe<InterviewPatientAggregateInput>;
  patientConnection?: InputMaybe<InterviewPatientConnectionWhere>;
  patientConnection_NOT?: InputMaybe<InterviewPatientConnectionWhere>;
  patient_NOT?: InputMaybe<PatientWhere>;
  scoredAggregate?: InputMaybe<InterviewScoredAggregateInput>;
  /** Return Interviews where all of the related InterviewScoredConnections match this filter */
  scoredConnection_ALL?: InputMaybe<InterviewScoredConnectionWhere>;
  /** Return Interviews where none of the related InterviewScoredConnections match this filter */
  scoredConnection_NONE?: InputMaybe<InterviewScoredConnectionWhere>;
  /** Return Interviews where one of the related InterviewScoredConnections match this filter */
  scoredConnection_SINGLE?: InputMaybe<InterviewScoredConnectionWhere>;
  /** Return Interviews where some of the related InterviewScoredConnections match this filter */
  scoredConnection_SOME?: InputMaybe<InterviewScoredConnectionWhere>;
  /** Return Interviews where all of the related VersionnedGraphs match this filter */
  scored_ALL?: InputMaybe<VersionnedGraphWhere>;
  /** Return Interviews where none of the related VersionnedGraphs match this filter */
  scored_NONE?: InputMaybe<VersionnedGraphWhere>;
  /** Return Interviews where one of the related VersionnedGraphs match this filter */
  scored_SINGLE?: InputMaybe<VersionnedGraphWhere>;
  /** Return Interviews where some of the related VersionnedGraphs match this filter */
  scored_SOME?: InputMaybe<VersionnedGraphWhere>;
  thirdParty?: InputMaybe<Scalars['Boolean']['input']>;
};

export type InterviewsByDoctors = {
  __typename?: 'InterviewsByDoctors';
  date: Scalars['Date']['output'];
  doctor: Doctor;
  interviews: Scalars['Int']['output'];
};

export type InterviewsByLink = {
  __typename?: 'InterviewsByLink';
  interviews: Scalars['Int']['output'];
  link: Link;
};

export type InterviewsByWorkflow = {
  __typename?: 'InterviewsByWorkflow';
  date: Scalars['Date']['output'];
  interviews: Scalars['Int']['output'];
};

export type InterviewsConnection = {
  __typename?: 'InterviewsConnection';
  edges: Array<InterviewEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Invoice = {
  __typename?: 'Invoice';
  amount?: Maybe<Scalars['Int']['output']>;
  document?: Maybe<Document>;
  id?: Maybe<Scalars['Int']['output']>;
};

export type InvoiceAggregateSelection = {
  __typename?: 'InvoiceAggregateSelection';
  amount: IntAggregateSelection;
  count: Scalars['Int']['output'];
  id: IntAggregateSelection;
};

export type InvoiceCreateInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

export type InvoiceEdge = {
  __typename?: 'InvoiceEdge';
  cursor: Scalars['String']['output'];
  node: Invoice;
};

export type InvoiceOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more InvoiceSort objects to sort Invoices by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<InvoiceSort>>;
};

/** Fields to sort Invoices by. The order in which sorts are applied is not guaranteed when specifying many fields in one InvoiceSort object. */
export type InvoiceSort = {
  amount?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
};

export type InvoiceUpdateInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  amount_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  amount_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  id_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  id_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
};

export type InvoiceWhere = {
  AND?: InputMaybe<Array<InvoiceWhere>>;
  NOT?: InputMaybe<InvoiceWhere>;
  OR?: InputMaybe<Array<InvoiceWhere>>;
  amount?: InputMaybe<Scalars['Int']['input']>;
  amount_GT?: InputMaybe<Scalars['Int']['input']>;
  amount_GTE?: InputMaybe<Scalars['Int']['input']>;
  amount_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  amount_LT?: InputMaybe<Scalars['Int']['input']>;
  amount_LTE?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  id_GT?: InputMaybe<Scalars['Int']['input']>;
  id_GTE?: InputMaybe<Scalars['Int']['input']>;
  id_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  id_LT?: InputMaybe<Scalars['Int']['input']>;
  id_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type InvoicesConnection = {
  __typename?: 'InvoicesConnection';
  edges: Array<InvoiceEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Link = Device | WorkflowLink;

export type LinkWhere = {
  Device?: InputMaybe<DeviceWhere>;
  WorkflowLink?: InputMaybe<WorkflowLinkWhere>;
};

export type Manager = User & {
  __typename?: 'Manager';
  email: Scalars['String']['output'];
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  phone?: Maybe<Scalars['String']['output']>;
  role: ManagerRole;
};

export type ManagerAggregateSelection = {
  __typename?: 'ManagerAggregateSelection';
  count: Scalars['Int']['output'];
  email: StringAggregateSelection;
  firstName: StringAggregateSelection;
  id: IdAggregateSelection;
  lastName: StringAggregateSelection;
  phone: StringAggregateSelection;
};

export type ManagerConnectOrCreateWhere = {
  node: ManagerUniqueWhere;
};

export type ManagerConnectWhere = {
  node: ManagerWhere;
};

export type ManagerCreateInput = {
  email: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  phone?: InputMaybe<Scalars['String']['input']>;
  role: ManagerRole;
};

export type ManagerEdge = {
  __typename?: 'ManagerEdge';
  cursor: Scalars['String']['output'];
  node: Manager;
};

export type ManagerOnCreateInput = {
  email: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  phone?: InputMaybe<Scalars['String']['input']>;
  role: ManagerRole;
};

export type ManagerOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more ManagerSort objects to sort Managers by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ManagerSort>>;
};

export enum ManagerRole {
  Administrator = 'Administrator',
  Advisor = 'Advisor',
  Support = 'Support'
}

/** Fields to sort Managers by. The order in which sorts are applied is not guaranteed when specifying many fields in one ManagerSort object. */
export type ManagerSort = {
  email?: InputMaybe<SortDirection>;
  firstName?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  lastName?: InputMaybe<SortDirection>;
  phone?: InputMaybe<SortDirection>;
  role?: InputMaybe<SortDirection>;
};

export type ManagerUniqueWhere = {
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type ManagerUpdateInput = {
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<ManagerRole>;
};

export type ManagerWhere = {
  AND?: InputMaybe<Array<ManagerWhere>>;
  NOT?: InputMaybe<ManagerWhere>;
  OR?: InputMaybe<Array<ManagerWhere>>;
  email?: InputMaybe<Scalars['String']['input']>;
  email_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  email_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  email_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  email_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  firstName_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  firstName_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  firstName_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  firstName_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastName_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  lastName_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  lastName_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  lastName_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phone_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  phone_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  phone_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  phone_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<ManagerRole>;
  role_IN?: InputMaybe<Array<ManagerRole>>;
};

export type ManagersConnection = {
  __typename?: 'ManagersConnection';
  edges: Array<ManagerEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Mutation = {
  __typename?: 'Mutation';
  addDoctor?: Maybe<Doctor>;
  addManager?: Maybe<Manager>;
  addPatient?: Maybe<Scalars['String']['output']>;
  answer: Scalars['Boolean']['output'];
  authPatient?: Maybe<Scalars['String']['output']>;
  completeInterview: Scalars['Boolean']['output'];
  createAiResponses: CreateAiResponsesMutationResponse;
  createAlertGroups: CreateAlertGroupsMutationResponse;
  createAlerts: CreateAlertsMutationResponse;
  createAnswers: CreateAnswersMutationResponse;
  createCheckboxQuestions: CreateCheckboxQuestionsMutationResponse;
  createConditionGroups: CreateConditionGroupsMutationResponse;
  createConditions: CreateConditionsMutationResponse;
  createConfigurations: CreateConfigurationsMutationResponse;
  createCooldowns: CreateCooldownsMutationResponse;
  createDateQuestions: CreateDateQuestionsMutationResponse;
  createDeleteInfos: CreateDeleteInfosMutationResponse;
  createDevices: CreateDevicesMutationResponse;
  createDocuments: CreateDocumentsMutationResponse;
  createInstitutions: CreateInstitutionsMutationResponse;
  createInterviews: CreateInterviewsMutationResponse;
  createInvoices: CreateInvoicesMutationResponse;
  createPatients: CreatePatientsMutationResponse;
  createPdfDocuments: CreatePdfDocumentsMutationResponse;
  createPostalAddresses: CreatePostalAddressesMutationResponse;
  createQuestionItems: CreateQuestionItemsMutationResponse;
  createQuestionnaire?: Maybe<Scalars['ID']['output']>;
  createQuestionnaireAis: CreateQuestionnaireAisMutationResponse;
  createQuestionnaireAlerts: CreateQuestionnaireAlertsMutationResponse;
  createQuestionnaireAppointmentDates: CreateQuestionnaireAppointmentDatesMutationResponse;
  createQuestionnaireConditions: CreateQuestionnaireConditionsMutationResponse;
  createQuestionnaireDocumentFillers: CreateQuestionnaireDocumentFillersMutationResponse;
  createQuestionnaireDocuments: CreateQuestionnaireDocumentsMutationResponse;
  createQuestionnaireIdentities: CreateQuestionnaireIdentitiesMutationResponse;
  createQuestionnaireInfoSteps: CreateQuestionnaireInfoStepsMutationResponse;
  createQuestionnaireInterviews: CreateQuestionnaireInterviewsMutationResponse;
  createQuestionnaireMenuEntries: CreateQuestionnaireMenuEntriesMutationResponse;
  createQuestionnaireMenuItems: CreateQuestionnaireMenuItemsMutationResponse;
  createQuestionnaireMenus: CreateQuestionnaireMenusMutationResponse;
  createQuestionnaireRouters: CreateQuestionnaireRoutersMutationResponse;
  createQuestionnaireSelectMenus: CreateQuestionnaireSelectMenusMutationResponse;
  createQuestionnaireSetProperties: CreateQuestionnaireSetPropertiesMutationResponse;
  createQuestionnaireSurveys: CreateQuestionnaireSurveysMutationResponse;
  createQuestionnaireThirdParties: CreateQuestionnaireThirdPartiesMutationResponse;
  createQuestionnaireWelcomeSteps: CreateQuestionnaireWelcomeStepsMutationResponse;
  createQuestionnaires: CreateQuestionnairesMutationResponse;
  createQuotings: CreateQuotingsMutationResponse;
  createRadioQuestions: CreateRadioQuestionsMutationResponse;
  createRangeQuestions: CreateRangeQuestionsMutationResponse;
  createSearchQuestionResults: CreateSearchQuestionResultsMutationResponse;
  createSelectQuestions: CreateSelectQuestionsMutationResponse;
  createSerializationNodes: CreateSerializationNodesMutationResponse;
  createSerializationSockets: CreateSerializationSocketsMutationResponse;
  createSession: Scalars['ID']['output'];
  createSpecialities: CreateSpecialitiesMutationResponse;
  createTextQuestions: CreateTextQuestionsMutationResponse;
  createUnserializationResponses: CreateUnserializationResponsesMutationResponse;
  createVersionnedGraphs: CreateVersionnedGraphsMutationResponse;
  createWorkflow?: Maybe<Scalars['ID']['output']>;
  createWorkflowLinks: CreateWorkflowLinksMutationResponse;
  createWorkflows: CreateWorkflowsMutationResponse;
  deleteAiResponses: DeleteInfo;
  deleteAlertGroups: DeleteInfo;
  deleteAlerts: DeleteInfo;
  deleteAnswers: DeleteInfo;
  deleteCheckboxQuestions: DeleteInfo;
  deleteConditionGroups: DeleteInfo;
  deleteConditions: DeleteInfo;
  deleteConfigurations: DeleteInfo;
  deleteCooldowns: DeleteInfo;
  deleteDateQuestions: DeleteInfo;
  deleteDeleteInfos: DeleteInfo;
  deleteDevices?: Maybe<DeleteInfo>;
  deleteDoctors: DeleteInfo;
  deleteDocuments: DeleteInfo;
  deleteInstitutions: DeleteInfo;
  deleteInterviews: DeleteInfo;
  deleteInvoices: DeleteInfo;
  deleteManagers: DeleteInfo;
  deletePatients: DeleteInfo;
  deletePdfDocuments: DeleteInfo;
  deletePostalAddresses: DeleteInfo;
  deleteQuestionItems: DeleteInfo;
  deleteQuestionnaireAis: DeleteInfo;
  deleteQuestionnaireAlerts: DeleteInfo;
  deleteQuestionnaireAppointmentDates: DeleteInfo;
  deleteQuestionnaireConditions: DeleteInfo;
  deleteQuestionnaireDocumentFillers: DeleteInfo;
  deleteQuestionnaireDocuments: DeleteInfo;
  deleteQuestionnaireIdentities: DeleteInfo;
  deleteQuestionnaireInfoSteps: DeleteInfo;
  deleteQuestionnaireInterviews: DeleteInfo;
  deleteQuestionnaireMenuEntries: DeleteInfo;
  deleteQuestionnaireMenuItems: DeleteInfo;
  deleteQuestionnaireMenus: DeleteInfo;
  deleteQuestionnaireRouters: DeleteInfo;
  deleteQuestionnaireSelectMenus: DeleteInfo;
  deleteQuestionnaireSetProperties: DeleteInfo;
  deleteQuestionnaireSurveys: DeleteInfo;
  deleteQuestionnaireThirdParties: DeleteInfo;
  deleteQuestionnaireWelcomeSteps: DeleteInfo;
  deleteQuestionnaires: DeleteInfo;
  deleteQuotings: DeleteInfo;
  deleteRadioQuestions: DeleteInfo;
  deleteRangeQuestions: DeleteInfo;
  deleteSearchQuestionResults: DeleteInfo;
  deleteSelectQuestions: DeleteInfo;
  deleteSerializationNodes: DeleteInfo;
  deleteSerializationSockets: DeleteInfo;
  deleteSpecialities: DeleteInfo;
  deleteTextQuestions: DeleteInfo;
  deleteUnserializationResponses: DeleteInfo;
  deleteVersionnedGraphs: DeleteInfo;
  deleteWorkflowLinks?: Maybe<DeleteInfo>;
  deleteWorkflows: DeleteInfo;
  linkChromePlugin?: Maybe<Scalars['String']['output']>;
  populatePdfVars: Array<PdfField>;
  pscAuth?: Maybe<Scalars['String']['output']>;
  saveConfiguration?: Maybe<Scalars['Boolean']['output']>;
  saveQuestionnaire?: Maybe<Scalars['ID']['output']>;
  saveWorkflow?: Maybe<Scalars['ID']['output']>;
  sendNoticeByEmail?: Maybe<Scalars['Boolean']['output']>;
  signInDoctor?: Maybe<Scalars['String']['output']>;
  signInManager?: Maybe<Scalars['String']['output']>;
  signInPatient?: Maybe<Scalars['String']['output']>;
  signUpDoctor?: Maybe<Scalars['String']['output']>;
  signUpPatient?: Maybe<Scalars['String']['output']>;
  subscribe?: Maybe<Scalars['Boolean']['output']>;
  updateAiResponses: UpdateAiResponsesMutationResponse;
  updateAlertGroups: UpdateAlertGroupsMutationResponse;
  updateAlerts: UpdateAlertsMutationResponse;
  updateAnswers: UpdateAnswersMutationResponse;
  updateCheckboxQuestions: UpdateCheckboxQuestionsMutationResponse;
  updateConditionGroups: UpdateConditionGroupsMutationResponse;
  updateConditions: UpdateConditionsMutationResponse;
  updateConfigurations: UpdateConfigurationsMutationResponse;
  updateCooldowns: UpdateCooldownsMutationResponse;
  updateDateQuestions: UpdateDateQuestionsMutationResponse;
  updateDeleteInfos: UpdateDeleteInfosMutationResponse;
  updateDevices: UpdateDevicesMutationResponse;
  updateDoctorPassword?: Maybe<Scalars['String']['output']>;
  updateDoctors: UpdateDoctorsMutationResponse;
  updateDocuments: UpdateDocumentsMutationResponse;
  updateInstitutions: UpdateInstitutionsMutationResponse;
  updateInterviews: UpdateInterviewsMutationResponse;
  updateInvoices: UpdateInvoicesMutationResponse;
  updateManagerPassword?: Maybe<Scalars['String']['output']>;
  updateManagers: UpdateManagersMutationResponse;
  updatePatients: UpdatePatientsMutationResponse;
  updatePdfDocuments: UpdatePdfDocumentsMutationResponse;
  updatePostalAddresses: UpdatePostalAddressesMutationResponse;
  updateQuestionItems: UpdateQuestionItemsMutationResponse;
  updateQuestionnaireAis: UpdateQuestionnaireAisMutationResponse;
  updateQuestionnaireAlerts: UpdateQuestionnaireAlertsMutationResponse;
  updateQuestionnaireAppointmentDates: UpdateQuestionnaireAppointmentDatesMutationResponse;
  updateQuestionnaireConditions: UpdateQuestionnaireConditionsMutationResponse;
  updateQuestionnaireDocumentFillers: UpdateQuestionnaireDocumentFillersMutationResponse;
  updateQuestionnaireDocuments: UpdateQuestionnaireDocumentsMutationResponse;
  updateQuestionnaireIdentities: UpdateQuestionnaireIdentitiesMutationResponse;
  updateQuestionnaireInfoSteps: UpdateQuestionnaireInfoStepsMutationResponse;
  updateQuestionnaireInterviews: UpdateQuestionnaireInterviewsMutationResponse;
  updateQuestionnaireMenuEntries: UpdateQuestionnaireMenuEntriesMutationResponse;
  updateQuestionnaireMenuItems: UpdateQuestionnaireMenuItemsMutationResponse;
  updateQuestionnaireMenus: UpdateQuestionnaireMenusMutationResponse;
  updateQuestionnaireRouters: UpdateQuestionnaireRoutersMutationResponse;
  updateQuestionnaireSelectMenus: UpdateQuestionnaireSelectMenusMutationResponse;
  updateQuestionnaireSetProperties: UpdateQuestionnaireSetPropertiesMutationResponse;
  updateQuestionnaireSurveys: UpdateQuestionnaireSurveysMutationResponse;
  updateQuestionnaireThirdParties: UpdateQuestionnaireThirdPartiesMutationResponse;
  updateQuestionnaireWelcomeSteps: UpdateQuestionnaireWelcomeStepsMutationResponse;
  updateQuestionnaires: UpdateQuestionnairesMutationResponse;
  updateQuotings: UpdateQuotingsMutationResponse;
  updateRadioQuestions: UpdateRadioQuestionsMutationResponse;
  updateRangeQuestions: UpdateRangeQuestionsMutationResponse;
  updateSearchQuestionResults: UpdateSearchQuestionResultsMutationResponse;
  updateSelectQuestions: UpdateSelectQuestionsMutationResponse;
  updateSerializationNodes: UpdateSerializationNodesMutationResponse;
  updateSerializationSockets: UpdateSerializationSocketsMutationResponse;
  updateSpecialities: UpdateSpecialitiesMutationResponse;
  updateTextQuestions: UpdateTextQuestionsMutationResponse;
  updateUnserializationResponses: UpdateUnserializationResponsesMutationResponse;
  updateVersionnedGraphs: UpdateVersionnedGraphsMutationResponse;
  updateWorkflowLinks: UpdateWorkflowLinksMutationResponse;
  updateWorkflows: UpdateWorkflowsMutationResponse;
};


export type MutationAddDoctorArgs = {
  address?: InputMaybe<PostalAddressCreateInput>;
  email: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  password: Scalars['String']['input'];
  phone?: InputMaybe<Scalars['String']['input']>;
  rpps: Scalars['String']['input'];
  speciality: Scalars['ID']['input'];
};


export type MutationAddManagerArgs = {
  email: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  password: Scalars['String']['input'];
  phone?: InputMaybe<Scalars['String']['input']>;
  role: ManagerRole;
};


export type MutationAddPatientArgs = {
  additionalAddressInfo?: InputMaybe<Scalars['String']['input']>;
  birthName?: InputMaybe<Scalars['String']['input']>;
  birthdate?: InputMaybe<Scalars['Date']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  session: Scalars['ID']['input'];
};


export type MutationAnswerArgs = {
  choices?: InputMaybe<Array<Scalars['String']['input']>>;
  field?: InputMaybe<Scalars['String']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  order: Scalars['Int']['input'];
  question: Scalars['ID']['input'];
  session: Scalars['ID']['input'];
  type?: InputMaybe<AiResponseType>;
  values: Array<Scalars['String']['input']>;
};


export type MutationAuthPatientArgs = {
  token: Scalars['String']['input'];
};


export type MutationCompleteInterviewArgs = {
  session: Scalars['ID']['input'];
};


export type MutationCreateAiResponsesArgs = {
  input: Array<AiResponseCreateInput>;
};


export type MutationCreateAlertGroupsArgs = {
  input: Array<AlertGroupCreateInput>;
};


export type MutationCreateAlertsArgs = {
  input: Array<AlertCreateInput>;
};


export type MutationCreateAnswersArgs = {
  input: Array<AnswerCreateInput>;
};


export type MutationCreateCheckboxQuestionsArgs = {
  input: Array<CheckboxQuestionCreateInput>;
};


export type MutationCreateConditionGroupsArgs = {
  input: Array<ConditionGroupCreateInput>;
};


export type MutationCreateConditionsArgs = {
  input: Array<ConditionCreateInput>;
};


export type MutationCreateConfigurationsArgs = {
  input: Array<ConfigurationCreateInput>;
};


export type MutationCreateCooldownsArgs = {
  input: Array<CooldownCreateInput>;
};


export type MutationCreateDateQuestionsArgs = {
  input: Array<DateQuestionCreateInput>;
};


export type MutationCreateDeleteInfosArgs = {
  input: Array<DeleteInfoCreateInput>;
};


export type MutationCreateDevicesArgs = {
  input: Array<DeviceCreateInput>;
};


export type MutationCreateDocumentsArgs = {
  input: Array<DocumentCreateInput>;
};


export type MutationCreateInstitutionsArgs = {
  input: Array<InstitutionCreateInput>;
};


export type MutationCreateInterviewsArgs = {
  input: Array<InterviewCreateInput>;
};


export type MutationCreateInvoicesArgs = {
  input: Array<InvoiceCreateInput>;
};


export type MutationCreatePatientsArgs = {
  input: Array<PatientCreateInput>;
};


export type MutationCreatePdfDocumentsArgs = {
  input: Array<PdfDocumentCreateInput>;
};


export type MutationCreatePostalAddressesArgs = {
  input: Array<PostalAddressCreateInput>;
};


export type MutationCreateQuestionItemsArgs = {
  input: Array<QuestionItemCreateInput>;
};


export type MutationCreateQuestionnaireArgs = {
  alerts?: InputMaybe<AlertGroupInput>;
  cooldown?: InputMaybe<CooldownCreateInput>;
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  nodes: Array<SerializationNodeInput>;
  quoting?: InputMaybe<QuotingCreateInput>;
};


export type MutationCreateQuestionnaireAisArgs = {
  input: Array<QuestionnaireAiCreateInput>;
};


export type MutationCreateQuestionnaireAlertsArgs = {
  input: Array<QuestionnaireAlertsCreateInput>;
};


export type MutationCreateQuestionnaireAppointmentDatesArgs = {
  input: Array<QuestionnaireAppointmentDateCreateInput>;
};


export type MutationCreateQuestionnaireConditionsArgs = {
  input: Array<QuestionnaireConditionCreateInput>;
};


export type MutationCreateQuestionnaireDocumentFillersArgs = {
  input: Array<QuestionnaireDocumentFillerCreateInput>;
};


export type MutationCreateQuestionnaireDocumentsArgs = {
  input: Array<QuestionnaireDocumentCreateInput>;
};


export type MutationCreateQuestionnaireIdentitiesArgs = {
  input: Array<QuestionnaireIdentityCreateInput>;
};


export type MutationCreateQuestionnaireInfoStepsArgs = {
  input: Array<QuestionnaireInfoStepCreateInput>;
};


export type MutationCreateQuestionnaireInterviewsArgs = {
  input: Array<QuestionnaireInterviewCreateInput>;
};


export type MutationCreateQuestionnaireMenuEntriesArgs = {
  input: Array<QuestionnaireMenuEntryCreateInput>;
};


export type MutationCreateQuestionnaireMenuItemsArgs = {
  input: Array<QuestionnaireMenuItemCreateInput>;
};


export type MutationCreateQuestionnaireMenusArgs = {
  input: Array<QuestionnaireMenuCreateInput>;
};


export type MutationCreateQuestionnaireRoutersArgs = {
  input: Array<QuestionnaireRouterCreateInput>;
};


export type MutationCreateQuestionnaireSelectMenusArgs = {
  input: Array<QuestionnaireSelectMenuCreateInput>;
};


export type MutationCreateQuestionnaireSetPropertiesArgs = {
  input: Array<QuestionnaireSetPropertyCreateInput>;
};


export type MutationCreateQuestionnaireSurveysArgs = {
  input: Array<QuestionnaireSurveyCreateInput>;
};


export type MutationCreateQuestionnaireThirdPartiesArgs = {
  input: Array<QuestionnaireThirdPartyCreateInput>;
};


export type MutationCreateQuestionnaireWelcomeStepsArgs = {
  input: Array<QuestionnaireWelcomeStepCreateInput>;
};


export type MutationCreateQuestionnairesArgs = {
  input: Array<QuestionnaireCreateInput>;
};


export type MutationCreateQuotingsArgs = {
  input: Array<QuotingCreateInput>;
};


export type MutationCreateRadioQuestionsArgs = {
  input: Array<RadioQuestionCreateInput>;
};


export type MutationCreateRangeQuestionsArgs = {
  input: Array<RangeQuestionCreateInput>;
};


export type MutationCreateSearchQuestionResultsArgs = {
  input: Array<SearchQuestionResultCreateInput>;
};


export type MutationCreateSelectQuestionsArgs = {
  input: Array<SelectQuestionCreateInput>;
};


export type MutationCreateSerializationNodesArgs = {
  input: Array<SerializationNodeCreateInput>;
};


export type MutationCreateSerializationSocketsArgs = {
  input: Array<SerializationSocketCreateInput>;
};


export type MutationCreateSessionArgs = {
  doctorId: Scalars['ID']['input'];
  isDeviceLink: Scalars['Boolean']['input'];
  linkId: Scalars['String']['input'];
};


export type MutationCreateSpecialitiesArgs = {
  input: Array<SpecialityCreateInput>;
};


export type MutationCreateTextQuestionsArgs = {
  input: Array<TextQuestionCreateInput>;
};


export type MutationCreateUnserializationResponsesArgs = {
  input: Array<UnserializationResponseCreateInput>;
};


export type MutationCreateVersionnedGraphsArgs = {
  input: Array<VersionnedGraphCreateInput>;
};


export type MutationCreateWorkflowArgs = {
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  nodes: Array<SerializationNodeInput>;
};


export type MutationCreateWorkflowLinksArgs = {
  input: Array<WorkflowLinkCreateInput>;
};


export type MutationCreateWorkflowsArgs = {
  input: Array<WorkflowCreateInput>;
};


export type MutationDeleteAiResponsesArgs = {
  where?: InputMaybe<AiResponseWhere>;
};


export type MutationDeleteAlertGroupsArgs = {
  delete?: InputMaybe<AlertGroupDeleteInput>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type MutationDeleteAlertsArgs = {
  delete?: InputMaybe<AlertDeleteInput>;
  where?: InputMaybe<AlertWhere>;
};


export type MutationDeleteAnswersArgs = {
  delete?: InputMaybe<AnswerDeleteInput>;
  where?: InputMaybe<AnswerWhere>;
};


export type MutationDeleteCheckboxQuestionsArgs = {
  delete?: InputMaybe<CheckboxQuestionDeleteInput>;
  where?: InputMaybe<CheckboxQuestionWhere>;
};


export type MutationDeleteConditionGroupsArgs = {
  delete?: InputMaybe<ConditionGroupDeleteInput>;
  where?: InputMaybe<ConditionGroupWhere>;
};


export type MutationDeleteConditionsArgs = {
  where?: InputMaybe<ConditionWhere>;
};


export type MutationDeleteConfigurationsArgs = {
  delete?: InputMaybe<ConfigurationDeleteInput>;
  where?: InputMaybe<ConfigurationWhere>;
};


export type MutationDeleteCooldownsArgs = {
  where?: InputMaybe<CooldownWhere>;
};


export type MutationDeleteDateQuestionsArgs = {
  delete?: InputMaybe<DateQuestionDeleteInput>;
  where?: InputMaybe<DateQuestionWhere>;
};


export type MutationDeleteDeleteInfosArgs = {
  where?: InputMaybe<DeleteInfoWhere>;
};


export type MutationDeleteDevicesArgs = {
  hardDelete?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<DeviceWhere>;
};


export type MutationDeleteDoctorsArgs = {
  delete?: InputMaybe<DoctorDeleteInput>;
  where?: InputMaybe<DoctorWhere>;
};


export type MutationDeleteDocumentsArgs = {
  where?: InputMaybe<DocumentWhere>;
};


export type MutationDeleteInstitutionsArgs = {
  delete?: InputMaybe<InstitutionDeleteInput>;
  where?: InputMaybe<InstitutionWhere>;
};


export type MutationDeleteInterviewsArgs = {
  delete?: InputMaybe<InterviewDeleteInput>;
  where?: InputMaybe<InterviewWhere>;
};


export type MutationDeleteInvoicesArgs = {
  where?: InputMaybe<InvoiceWhere>;
};


export type MutationDeleteManagersArgs = {
  where?: InputMaybe<ManagerWhere>;
};


export type MutationDeletePatientsArgs = {
  delete?: InputMaybe<PatientDeleteInput>;
  where?: InputMaybe<PatientWhere>;
};


export type MutationDeletePdfDocumentsArgs = {
  delete?: InputMaybe<PdfDocumentDeleteInput>;
  where?: InputMaybe<PdfDocumentWhere>;
};


export type MutationDeletePostalAddressesArgs = {
  where?: InputMaybe<PostalAddressWhere>;
};


export type MutationDeleteQuestionItemsArgs = {
  where?: InputMaybe<QuestionItemWhere>;
};


export type MutationDeleteQuestionnaireAisArgs = {
  delete?: InputMaybe<QuestionnaireAiDeleteInput>;
  where?: InputMaybe<QuestionnaireAiWhere>;
};


export type MutationDeleteQuestionnaireAlertsArgs = {
  where?: InputMaybe<QuestionnaireAlertsWhere>;
};


export type MutationDeleteQuestionnaireAppointmentDatesArgs = {
  delete?: InputMaybe<QuestionnaireAppointmentDateDeleteInput>;
  where?: InputMaybe<QuestionnaireAppointmentDateWhere>;
};


export type MutationDeleteQuestionnaireConditionsArgs = {
  delete?: InputMaybe<QuestionnaireConditionDeleteInput>;
  where?: InputMaybe<QuestionnaireConditionWhere>;
};


export type MutationDeleteQuestionnaireDocumentFillersArgs = {
  delete?: InputMaybe<QuestionnaireDocumentFillerDeleteInput>;
  where?: InputMaybe<QuestionnaireDocumentFillerWhere>;
};


export type MutationDeleteQuestionnaireDocumentsArgs = {
  delete?: InputMaybe<QuestionnaireDocumentDeleteInput>;
  where?: InputMaybe<QuestionnaireDocumentWhere>;
};


export type MutationDeleteQuestionnaireIdentitiesArgs = {
  delete?: InputMaybe<QuestionnaireIdentityDeleteInput>;
  where?: InputMaybe<QuestionnaireIdentityWhere>;
};


export type MutationDeleteQuestionnaireInfoStepsArgs = {
  delete?: InputMaybe<QuestionnaireInfoStepDeleteInput>;
  where?: InputMaybe<QuestionnaireInfoStepWhere>;
};


export type MutationDeleteQuestionnaireInterviewsArgs = {
  delete?: InputMaybe<QuestionnaireInterviewDeleteInput>;
  where?: InputMaybe<QuestionnaireInterviewWhere>;
};


export type MutationDeleteQuestionnaireMenuEntriesArgs = {
  delete?: InputMaybe<QuestionnaireMenuEntryDeleteInput>;
  where?: InputMaybe<QuestionnaireMenuEntryWhere>;
};


export type MutationDeleteQuestionnaireMenuItemsArgs = {
  where?: InputMaybe<QuestionnaireMenuItemWhere>;
};


export type MutationDeleteQuestionnaireMenusArgs = {
  delete?: InputMaybe<QuestionnaireMenuDeleteInput>;
  where?: InputMaybe<QuestionnaireMenuWhere>;
};


export type MutationDeleteQuestionnaireRoutersArgs = {
  delete?: InputMaybe<QuestionnaireRouterDeleteInput>;
  where?: InputMaybe<QuestionnaireRouterWhere>;
};


export type MutationDeleteQuestionnaireSelectMenusArgs = {
  delete?: InputMaybe<QuestionnaireSelectMenuDeleteInput>;
  where?: InputMaybe<QuestionnaireSelectMenuWhere>;
};


export type MutationDeleteQuestionnaireSetPropertiesArgs = {
  delete?: InputMaybe<QuestionnaireSetPropertyDeleteInput>;
  where?: InputMaybe<QuestionnaireSetPropertyWhere>;
};


export type MutationDeleteQuestionnaireSurveysArgs = {
  delete?: InputMaybe<QuestionnaireSurveyDeleteInput>;
  where?: InputMaybe<QuestionnaireSurveyWhere>;
};


export type MutationDeleteQuestionnaireThirdPartiesArgs = {
  delete?: InputMaybe<QuestionnaireThirdPartyDeleteInput>;
  where?: InputMaybe<QuestionnaireThirdPartyWhere>;
};


export type MutationDeleteQuestionnaireWelcomeStepsArgs = {
  delete?: InputMaybe<QuestionnaireWelcomeStepDeleteInput>;
  where?: InputMaybe<QuestionnaireWelcomeStepWhere>;
};


export type MutationDeleteQuestionnairesArgs = {
  delete?: InputMaybe<QuestionnaireDeleteInput>;
  where?: InputMaybe<QuestionnaireWhere>;
};


export type MutationDeleteQuotingsArgs = {
  delete?: InputMaybe<QuotingDeleteInput>;
  where?: InputMaybe<QuotingWhere>;
};


export type MutationDeleteRadioQuestionsArgs = {
  delete?: InputMaybe<RadioQuestionDeleteInput>;
  where?: InputMaybe<RadioQuestionWhere>;
};


export type MutationDeleteRangeQuestionsArgs = {
  delete?: InputMaybe<RangeQuestionDeleteInput>;
  where?: InputMaybe<RangeQuestionWhere>;
};


export type MutationDeleteSearchQuestionResultsArgs = {
  where?: InputMaybe<SearchQuestionResultWhere>;
};


export type MutationDeleteSelectQuestionsArgs = {
  delete?: InputMaybe<SelectQuestionDeleteInput>;
  where?: InputMaybe<SelectQuestionWhere>;
};


export type MutationDeleteSerializationNodesArgs = {
  where?: InputMaybe<SerializationNodeWhere>;
};


export type MutationDeleteSerializationSocketsArgs = {
  where?: InputMaybe<SerializationSocketWhere>;
};


export type MutationDeleteSpecialitiesArgs = {
  delete?: InputMaybe<SpecialityDeleteInput>;
  where?: InputMaybe<SpecialityWhere>;
};


export type MutationDeleteTextQuestionsArgs = {
  delete?: InputMaybe<TextQuestionDeleteInput>;
  where?: InputMaybe<TextQuestionWhere>;
};


export type MutationDeleteUnserializationResponsesArgs = {
  where?: InputMaybe<UnserializationResponseWhere>;
};


export type MutationDeleteVersionnedGraphsArgs = {
  delete?: InputMaybe<VersionnedGraphDeleteInput>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type MutationDeleteWorkflowLinksArgs = {
  hardDelete?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<WorkflowLinkWhere>;
};


export type MutationDeleteWorkflowsArgs = {
  delete?: InputMaybe<WorkflowDeleteInput>;
  where?: InputMaybe<WorkflowWhere>;
};


export type MutationPopulatePdfVarsArgs = {
  pdfId: Scalars['ID']['input'];
};


export type MutationPscAuthArgs = {
  code: Scalars['String']['input'];
};


export type MutationSaveConfigurationArgs = {
  dashboardLayout?: InputMaybe<Scalars['String']['input']>;
  institutionId: Scalars['ID']['input'];
};


export type MutationSaveQuestionnaireArgs = {
  alerts?: InputMaybe<AlertGroupInput>;
  cooldown?: InputMaybe<CooldownCreateInput>;
  id: Scalars['ID']['input'];
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  nodes: Array<SerializationNodeInput>;
  quoting?: InputMaybe<QuotingCreateInput>;
};


export type MutationSaveWorkflowArgs = {
  id: Scalars['ID']['input'];
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  nodes: Array<SerializationNodeInput>;
};


export type MutationSendNoticeByEmailArgs = {
  email: Scalars['String']['input'];
  question: Scalars['ID']['input'];
};


export type MutationSignInDoctorArgs = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type MutationSignInManagerArgs = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type MutationSignInPatientArgs = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type MutationSignUpDoctorArgs = {
  address?: InputMaybe<PostalAddressCreateInput>;
  email: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  password: Scalars['String']['input'];
  phone?: InputMaybe<Scalars['String']['input']>;
  rpps: Scalars['String']['input'];
  speciality: Scalars['ID']['input'];
};


export type MutationSignUpPatientArgs = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type MutationSubscribeArgs = {
  email: Scalars['String']['input'];
  phone: Scalars['String']['input'];
};


export type MutationUpdateAiResponsesArgs = {
  update?: InputMaybe<AiResponseUpdateInput>;
  where?: InputMaybe<AiResponseWhere>;
};


export type MutationUpdateAlertGroupsArgs = {
  update?: InputMaybe<AlertGroupUpdateInput>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type MutationUpdateAlertsArgs = {
  update?: InputMaybe<AlertUpdateInput>;
  where?: InputMaybe<AlertWhere>;
};


export type MutationUpdateAnswersArgs = {
  update?: InputMaybe<AnswerUpdateInput>;
  where?: InputMaybe<AnswerWhere>;
};


export type MutationUpdateCheckboxQuestionsArgs = {
  update?: InputMaybe<CheckboxQuestionUpdateInput>;
  where?: InputMaybe<CheckboxQuestionWhere>;
};


export type MutationUpdateConditionGroupsArgs = {
  update?: InputMaybe<ConditionGroupUpdateInput>;
  where?: InputMaybe<ConditionGroupWhere>;
};


export type MutationUpdateConditionsArgs = {
  update?: InputMaybe<ConditionUpdateInput>;
  where?: InputMaybe<ConditionWhere>;
};


export type MutationUpdateConfigurationsArgs = {
  update?: InputMaybe<ConfigurationUpdateInput>;
  where?: InputMaybe<ConfigurationWhere>;
};


export type MutationUpdateCooldownsArgs = {
  update?: InputMaybe<CooldownUpdateInput>;
  where?: InputMaybe<CooldownWhere>;
};


export type MutationUpdateDateQuestionsArgs = {
  update?: InputMaybe<DateQuestionUpdateInput>;
  where?: InputMaybe<DateQuestionWhere>;
};


export type MutationUpdateDeleteInfosArgs = {
  update?: InputMaybe<DeleteInfoUpdateInput>;
  where?: InputMaybe<DeleteInfoWhere>;
};


export type MutationUpdateDevicesArgs = {
  update?: InputMaybe<DeviceUpdateInput>;
  where?: InputMaybe<DeviceWhere>;
};


export type MutationUpdateDoctorPasswordArgs = {
  id: Scalars['ID']['input'];
  password?: InputMaybe<Scalars['String']['input']>;
};


export type MutationUpdateDoctorsArgs = {
  update?: InputMaybe<DoctorUpdateInput>;
  where?: InputMaybe<DoctorWhere>;
};


export type MutationUpdateDocumentsArgs = {
  update?: InputMaybe<DocumentUpdateInput>;
  where?: InputMaybe<DocumentWhere>;
};


export type MutationUpdateInstitutionsArgs = {
  update?: InputMaybe<InstitutionUpdateInput>;
  where?: InputMaybe<InstitutionWhere>;
};


export type MutationUpdateInterviewsArgs = {
  update?: InputMaybe<InterviewUpdateInput>;
  where?: InputMaybe<InterviewWhere>;
};


export type MutationUpdateInvoicesArgs = {
  update?: InputMaybe<InvoiceUpdateInput>;
  where?: InputMaybe<InvoiceWhere>;
};


export type MutationUpdateManagerPasswordArgs = {
  id: Scalars['ID']['input'];
  password?: InputMaybe<Scalars['String']['input']>;
};


export type MutationUpdateManagersArgs = {
  update?: InputMaybe<ManagerUpdateInput>;
  where?: InputMaybe<ManagerWhere>;
};


export type MutationUpdatePatientsArgs = {
  update?: InputMaybe<PatientUpdateInput>;
  where?: InputMaybe<PatientWhere>;
};


export type MutationUpdatePdfDocumentsArgs = {
  update?: InputMaybe<PdfDocumentUpdateInput>;
  where?: InputMaybe<PdfDocumentWhere>;
};


export type MutationUpdatePostalAddressesArgs = {
  update?: InputMaybe<PostalAddressUpdateInput>;
  where?: InputMaybe<PostalAddressWhere>;
};


export type MutationUpdateQuestionItemsArgs = {
  update?: InputMaybe<QuestionItemUpdateInput>;
  where?: InputMaybe<QuestionItemWhere>;
};


export type MutationUpdateQuestionnaireAisArgs = {
  update?: InputMaybe<QuestionnaireAiUpdateInput>;
  where?: InputMaybe<QuestionnaireAiWhere>;
};


export type MutationUpdateQuestionnaireAlertsArgs = {
  update?: InputMaybe<QuestionnaireAlertsUpdateInput>;
  where?: InputMaybe<QuestionnaireAlertsWhere>;
};


export type MutationUpdateQuestionnaireAppointmentDatesArgs = {
  update?: InputMaybe<QuestionnaireAppointmentDateUpdateInput>;
  where?: InputMaybe<QuestionnaireAppointmentDateWhere>;
};


export type MutationUpdateQuestionnaireConditionsArgs = {
  update?: InputMaybe<QuestionnaireConditionUpdateInput>;
  where?: InputMaybe<QuestionnaireConditionWhere>;
};


export type MutationUpdateQuestionnaireDocumentFillersArgs = {
  update?: InputMaybe<QuestionnaireDocumentFillerUpdateInput>;
  where?: InputMaybe<QuestionnaireDocumentFillerWhere>;
};


export type MutationUpdateQuestionnaireDocumentsArgs = {
  update?: InputMaybe<QuestionnaireDocumentUpdateInput>;
  where?: InputMaybe<QuestionnaireDocumentWhere>;
};


export type MutationUpdateQuestionnaireIdentitiesArgs = {
  update?: InputMaybe<QuestionnaireIdentityUpdateInput>;
  where?: InputMaybe<QuestionnaireIdentityWhere>;
};


export type MutationUpdateQuestionnaireInfoStepsArgs = {
  update?: InputMaybe<QuestionnaireInfoStepUpdateInput>;
  where?: InputMaybe<QuestionnaireInfoStepWhere>;
};


export type MutationUpdateQuestionnaireInterviewsArgs = {
  update?: InputMaybe<QuestionnaireInterviewUpdateInput>;
  where?: InputMaybe<QuestionnaireInterviewWhere>;
};


export type MutationUpdateQuestionnaireMenuEntriesArgs = {
  update?: InputMaybe<QuestionnaireMenuEntryUpdateInput>;
  where?: InputMaybe<QuestionnaireMenuEntryWhere>;
};


export type MutationUpdateQuestionnaireMenuItemsArgs = {
  update?: InputMaybe<QuestionnaireMenuItemUpdateInput>;
  where?: InputMaybe<QuestionnaireMenuItemWhere>;
};


export type MutationUpdateQuestionnaireMenusArgs = {
  update?: InputMaybe<QuestionnaireMenuUpdateInput>;
  where?: InputMaybe<QuestionnaireMenuWhere>;
};


export type MutationUpdateQuestionnaireRoutersArgs = {
  update?: InputMaybe<QuestionnaireRouterUpdateInput>;
  where?: InputMaybe<QuestionnaireRouterWhere>;
};


export type MutationUpdateQuestionnaireSelectMenusArgs = {
  update?: InputMaybe<QuestionnaireSelectMenuUpdateInput>;
  where?: InputMaybe<QuestionnaireSelectMenuWhere>;
};


export type MutationUpdateQuestionnaireSetPropertiesArgs = {
  update?: InputMaybe<QuestionnaireSetPropertyUpdateInput>;
  where?: InputMaybe<QuestionnaireSetPropertyWhere>;
};


export type MutationUpdateQuestionnaireSurveysArgs = {
  update?: InputMaybe<QuestionnaireSurveyUpdateInput>;
  where?: InputMaybe<QuestionnaireSurveyWhere>;
};


export type MutationUpdateQuestionnaireThirdPartiesArgs = {
  update?: InputMaybe<QuestionnaireThirdPartyUpdateInput>;
  where?: InputMaybe<QuestionnaireThirdPartyWhere>;
};


export type MutationUpdateQuestionnaireWelcomeStepsArgs = {
  update?: InputMaybe<QuestionnaireWelcomeStepUpdateInput>;
  where?: InputMaybe<QuestionnaireWelcomeStepWhere>;
};


export type MutationUpdateQuestionnairesArgs = {
  update?: InputMaybe<QuestionnaireUpdateInput>;
  where?: InputMaybe<QuestionnaireWhere>;
};


export type MutationUpdateQuotingsArgs = {
  update?: InputMaybe<QuotingUpdateInput>;
  where?: InputMaybe<QuotingWhere>;
};


export type MutationUpdateRadioQuestionsArgs = {
  update?: InputMaybe<RadioQuestionUpdateInput>;
  where?: InputMaybe<RadioQuestionWhere>;
};


export type MutationUpdateRangeQuestionsArgs = {
  update?: InputMaybe<RangeQuestionUpdateInput>;
  where?: InputMaybe<RangeQuestionWhere>;
};


export type MutationUpdateSearchQuestionResultsArgs = {
  update?: InputMaybe<SearchQuestionResultUpdateInput>;
  where?: InputMaybe<SearchQuestionResultWhere>;
};


export type MutationUpdateSelectQuestionsArgs = {
  update?: InputMaybe<SelectQuestionUpdateInput>;
  where?: InputMaybe<SelectQuestionWhere>;
};


export type MutationUpdateSerializationNodesArgs = {
  update?: InputMaybe<SerializationNodeUpdateInput>;
  where?: InputMaybe<SerializationNodeWhere>;
};


export type MutationUpdateSerializationSocketsArgs = {
  update?: InputMaybe<SerializationSocketUpdateInput>;
  where?: InputMaybe<SerializationSocketWhere>;
};


export type MutationUpdateSpecialitiesArgs = {
  update?: InputMaybe<SpecialityUpdateInput>;
  where?: InputMaybe<SpecialityWhere>;
};


export type MutationUpdateTextQuestionsArgs = {
  update?: InputMaybe<TextQuestionUpdateInput>;
  where?: InputMaybe<TextQuestionWhere>;
};


export type MutationUpdateUnserializationResponsesArgs = {
  update?: InputMaybe<UnserializationResponseUpdateInput>;
  where?: InputMaybe<UnserializationResponseWhere>;
};


export type MutationUpdateVersionnedGraphsArgs = {
  update?: InputMaybe<VersionnedGraphUpdateInput>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type MutationUpdateWorkflowLinksArgs = {
  update?: InputMaybe<WorkflowLinkUpdateInput>;
  where?: InputMaybe<WorkflowLinkWhere>;
};


export type MutationUpdateWorkflowsArgs = {
  update?: InputMaybe<WorkflowUpdateInput>;
  where?: InputMaybe<WorkflowWhere>;
};

export enum OperatingMode {
  Cpts = 'CPTS',
  Consultation = 'Consultation',
  Emergency = 'Emergency'
}

export type Owner = Doctor | Institution;

export type OwnerWhere = {
  Doctor?: InputMaybe<DoctorWhere>;
  Institution?: InputMaybe<InstitutionWhere>;
};

export type PdfDocument = {
  __typename?: 'PDFDocument';
  document?: Maybe<Document>;
  fields: Array<PdfField>;
  fieldsAggregate?: Maybe<PdfDocumentPdfFieldFieldsAggregationSelection>;
  fieldsConnection: PdfDocumentFieldsConnection;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};


export type PdfDocumentFieldsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<PdfFieldOptions>;
  where?: InputMaybe<PdfFieldWhere>;
};


export type PdfDocumentFieldsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<PdfFieldWhere>;
};


export type PdfDocumentFieldsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<PdfDocumentFieldsConnectionSort>>;
  where?: InputMaybe<PdfDocumentFieldsConnectionWhere>;
};

export type PdfDocumentAggregateSelection = {
  __typename?: 'PDFDocumentAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type PdfDocumentConnectInput = {
  fields?: InputMaybe<Array<PdfDocumentFieldsConnectFieldInput>>;
};

export type PdfDocumentConnectOrCreateWhere = {
  node: PdfDocumentUniqueWhere;
};

export type PdfDocumentConnectWhere = {
  node: PdfDocumentWhere;
};

export type PdfDocumentCreateInput = {
  fields?: InputMaybe<PdfDocumentFieldsFieldInput>;
  name: Scalars['String']['input'];
};

export type PdfDocumentDeleteInput = {
  fields?: InputMaybe<Array<PdfDocumentFieldsDeleteFieldInput>>;
};

export type PdfDocumentDisconnectInput = {
  fields?: InputMaybe<Array<PdfDocumentFieldsDisconnectFieldInput>>;
};

export type PdfDocumentEdge = {
  __typename?: 'PDFDocumentEdge';
  cursor: Scalars['String']['output'];
  node: PdfDocument;
};

export type PdfDocumentFieldsAggregateInput = {
  AND?: InputMaybe<Array<PdfDocumentFieldsAggregateInput>>;
  NOT?: InputMaybe<PdfDocumentFieldsAggregateInput>;
  OR?: InputMaybe<Array<PdfDocumentFieldsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<PdfDocumentFieldsNodeAggregationWhereInput>;
};

export type PdfDocumentFieldsConnectFieldInput = {
  connect?: InputMaybe<Array<PdfFieldConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<PdfFieldConnectWhere>;
};

export type PdfDocumentFieldsConnection = {
  __typename?: 'PDFDocumentFieldsConnection';
  edges: Array<PdfDocumentFieldsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type PdfDocumentFieldsConnectionSort = {
  node?: InputMaybe<PdfFieldSort>;
};

export type PdfDocumentFieldsConnectionWhere = {
  AND?: InputMaybe<Array<PdfDocumentFieldsConnectionWhere>>;
  NOT?: InputMaybe<PdfDocumentFieldsConnectionWhere>;
  OR?: InputMaybe<Array<PdfDocumentFieldsConnectionWhere>>;
  node?: InputMaybe<PdfFieldWhere>;
};

export type PdfDocumentFieldsCreateFieldInput = {
  node: PdfFieldCreateInput;
};

export type PdfDocumentFieldsDeleteFieldInput = {
  delete?: InputMaybe<PdfFieldDeleteInput>;
  where?: InputMaybe<PdfDocumentFieldsConnectionWhere>;
};

export type PdfDocumentFieldsDisconnectFieldInput = {
  disconnect?: InputMaybe<PdfFieldDisconnectInput>;
  where?: InputMaybe<PdfDocumentFieldsConnectionWhere>;
};

export type PdfDocumentFieldsFieldInput = {
  connect?: InputMaybe<Array<PdfDocumentFieldsConnectFieldInput>>;
  create?: InputMaybe<Array<PdfDocumentFieldsCreateFieldInput>>;
};

export type PdfDocumentFieldsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PdfDocumentFieldsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<PdfDocumentFieldsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<PdfDocumentFieldsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type PdfDocumentFieldsRelationship = {
  __typename?: 'PDFDocumentFieldsRelationship';
  cursor: Scalars['String']['output'];
  node: PdfField;
};

export type PdfDocumentFieldsUpdateConnectionInput = {
  node?: InputMaybe<PdfFieldUpdateInput>;
};

export type PdfDocumentFieldsUpdateFieldInput = {
  connect?: InputMaybe<Array<PdfDocumentFieldsConnectFieldInput>>;
  create?: InputMaybe<Array<PdfDocumentFieldsCreateFieldInput>>;
  delete?: InputMaybe<Array<PdfDocumentFieldsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<PdfDocumentFieldsDisconnectFieldInput>>;
  update?: InputMaybe<PdfDocumentFieldsUpdateConnectionInput>;
  where?: InputMaybe<PdfDocumentFieldsConnectionWhere>;
};

export type PdfDocumentOnCreateInput = {
  name: Scalars['String']['input'];
};

export type PdfDocumentOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more PDFDocumentSort objects to sort PdfDocuments by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<PdfDocumentSort>>;
};

export type PdfDocumentPdfFieldFieldsAggregationSelection = {
  __typename?: 'PDFDocumentPDFFieldFieldsAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<PdfDocumentPdfFieldFieldsNodeAggregateSelection>;
};

export type PdfDocumentPdfFieldFieldsNodeAggregateSelection = {
  __typename?: 'PDFDocumentPDFFieldFieldsNodeAggregateSelection';
  name: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type PdfDocumentRelationInput = {
  fields?: InputMaybe<Array<PdfDocumentFieldsCreateFieldInput>>;
};

/** Fields to sort PdfDocuments by. The order in which sorts are applied is not guaranteed when specifying many fields in one PDFDocumentSort object. */
export type PdfDocumentSort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type PdfDocumentUniqueWhere = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type PdfDocumentUpdateInput = {
  fields?: InputMaybe<Array<PdfDocumentFieldsUpdateFieldInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type PdfDocumentWhere = {
  AND?: InputMaybe<Array<PdfDocumentWhere>>;
  NOT?: InputMaybe<PdfDocumentWhere>;
  OR?: InputMaybe<Array<PdfDocumentWhere>>;
  fieldsAggregate?: InputMaybe<PdfDocumentFieldsAggregateInput>;
  /** Return PDFDocuments where all of the related PDFDocumentFieldsConnections match this filter */
  fieldsConnection_ALL?: InputMaybe<PdfDocumentFieldsConnectionWhere>;
  /** Return PDFDocuments where none of the related PDFDocumentFieldsConnections match this filter */
  fieldsConnection_NONE?: InputMaybe<PdfDocumentFieldsConnectionWhere>;
  /** Return PDFDocuments where one of the related PDFDocumentFieldsConnections match this filter */
  fieldsConnection_SINGLE?: InputMaybe<PdfDocumentFieldsConnectionWhere>;
  /** Return PDFDocuments where some of the related PDFDocumentFieldsConnections match this filter */
  fieldsConnection_SOME?: InputMaybe<PdfDocumentFieldsConnectionWhere>;
  /** Return PDFDocuments where all of the related PDFFields match this filter */
  fields_ALL?: InputMaybe<PdfFieldWhere>;
  /** Return PDFDocuments where none of the related PDFFields match this filter */
  fields_NONE?: InputMaybe<PdfFieldWhere>;
  /** Return PDFDocuments where one of the related PDFFields match this filter */
  fields_SINGLE?: InputMaybe<PdfFieldWhere>;
  /** Return PDFDocuments where some of the related PDFFields match this filter */
  fields_SOME?: InputMaybe<PdfFieldWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type PdfField = {
  __typename?: 'PDFField';
  name: Scalars['String']['output'];
  options: Array<Scalars['String']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  parent?: Maybe<PdfDocument>;
  parentAggregate?: Maybe<PdfFieldPdfDocumentParentAggregationSelection>;
  parentConnection: PdfFieldParentConnection;
  type: PdfFieldType;
};


export type PdfFieldParentArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<PdfDocumentOptions>;
  where?: InputMaybe<PdfDocumentWhere>;
};


export type PdfFieldParentAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<PdfDocumentWhere>;
};


export type PdfFieldParentConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<PdfFieldParentConnectionSort>>;
  where?: InputMaybe<PdfFieldParentConnectionWhere>;
};

export type PdfFieldConnectInput = {
  parent?: InputMaybe<PdfFieldParentConnectFieldInput>;
};

export type PdfFieldConnectWhere = {
  node: PdfFieldWhere;
};

export type PdfFieldCreateInput = {
  name: Scalars['String']['input'];
  options: Array<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  parent?: InputMaybe<PdfFieldParentFieldInput>;
  type: PdfFieldType;
};

export type PdfFieldDeleteInput = {
  parent?: InputMaybe<PdfFieldParentDeleteFieldInput>;
};

export type PdfFieldDisconnectInput = {
  parent?: InputMaybe<PdfFieldParentDisconnectFieldInput>;
};

export type PdfFieldOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more PDFFieldSort objects to sort PdfFields by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<PdfFieldSort>>;
};

export type PdfFieldPdfDocumentParentAggregationSelection = {
  __typename?: 'PDFFieldPDFDocumentParentAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<PdfFieldPdfDocumentParentNodeAggregateSelection>;
};

export type PdfFieldPdfDocumentParentNodeAggregateSelection = {
  __typename?: 'PDFFieldPDFDocumentParentNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type PdfFieldParentAggregateInput = {
  AND?: InputMaybe<Array<PdfFieldParentAggregateInput>>;
  NOT?: InputMaybe<PdfFieldParentAggregateInput>;
  OR?: InputMaybe<Array<PdfFieldParentAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<PdfFieldParentNodeAggregationWhereInput>;
};

export type PdfFieldParentConnectFieldInput = {
  connect?: InputMaybe<PdfDocumentConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<PdfDocumentConnectWhere>;
};

export type PdfFieldParentConnectOrCreateFieldInput = {
  onCreate: PdfFieldParentConnectOrCreateFieldInputOnCreate;
  where: PdfDocumentConnectOrCreateWhere;
};

export type PdfFieldParentConnectOrCreateFieldInputOnCreate = {
  node: PdfDocumentOnCreateInput;
};

export type PdfFieldParentConnection = {
  __typename?: 'PDFFieldParentConnection';
  edges: Array<PdfFieldParentRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type PdfFieldParentConnectionSort = {
  node?: InputMaybe<PdfDocumentSort>;
};

export type PdfFieldParentConnectionWhere = {
  AND?: InputMaybe<Array<PdfFieldParentConnectionWhere>>;
  NOT?: InputMaybe<PdfFieldParentConnectionWhere>;
  OR?: InputMaybe<Array<PdfFieldParentConnectionWhere>>;
  node?: InputMaybe<PdfDocumentWhere>;
};

export type PdfFieldParentCreateFieldInput = {
  node: PdfDocumentCreateInput;
};

export type PdfFieldParentDeleteFieldInput = {
  delete?: InputMaybe<PdfDocumentDeleteInput>;
  where?: InputMaybe<PdfFieldParentConnectionWhere>;
};

export type PdfFieldParentDisconnectFieldInput = {
  disconnect?: InputMaybe<PdfDocumentDisconnectInput>;
  where?: InputMaybe<PdfFieldParentConnectionWhere>;
};

export type PdfFieldParentFieldInput = {
  connect?: InputMaybe<PdfFieldParentConnectFieldInput>;
  connectOrCreate?: InputMaybe<PdfFieldParentConnectOrCreateFieldInput>;
  create?: InputMaybe<PdfFieldParentCreateFieldInput>;
};

export type PdfFieldParentNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PdfFieldParentNodeAggregationWhereInput>>;
  NOT?: InputMaybe<PdfFieldParentNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<PdfFieldParentNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type PdfFieldParentRelationship = {
  __typename?: 'PDFFieldParentRelationship';
  cursor: Scalars['String']['output'];
  node: PdfDocument;
};

export type PdfFieldParentUpdateConnectionInput = {
  node?: InputMaybe<PdfDocumentUpdateInput>;
};

export type PdfFieldParentUpdateFieldInput = {
  connect?: InputMaybe<PdfFieldParentConnectFieldInput>;
  connectOrCreate?: InputMaybe<PdfFieldParentConnectOrCreateFieldInput>;
  create?: InputMaybe<PdfFieldParentCreateFieldInput>;
  delete?: InputMaybe<PdfFieldParentDeleteFieldInput>;
  disconnect?: InputMaybe<PdfFieldParentDisconnectFieldInput>;
  update?: InputMaybe<PdfFieldParentUpdateConnectionInput>;
  where?: InputMaybe<PdfFieldParentConnectionWhere>;
};

/** Fields to sort PdfFields by. The order in which sorts are applied is not guaranteed when specifying many fields in one PDFFieldSort object. */
export type PdfFieldSort = {
  name?: InputMaybe<SortDirection>;
  order?: InputMaybe<SortDirection>;
  type?: InputMaybe<SortDirection>;
};

export enum PdfFieldType {
  Checkbox = 'Checkbox',
  Dropdown = 'Dropdown',
  OptionList = 'OptionList',
  Radio = 'Radio',
  Signature = 'Signature',
  TextField = 'TextField',
  Unknown = 'Unknown'
}

export type PdfFieldUpdateInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  options?: InputMaybe<Array<Scalars['String']['input']>>;
  options_POP?: InputMaybe<Scalars['Int']['input']>;
  options_PUSH?: InputMaybe<Array<Scalars['String']['input']>>;
  order?: InputMaybe<Scalars['Int']['input']>;
  order_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  order_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  parent?: InputMaybe<PdfFieldParentUpdateFieldInput>;
  type?: InputMaybe<PdfFieldType>;
};

export type PdfFieldWhere = {
  AND?: InputMaybe<Array<PdfFieldWhere>>;
  NOT?: InputMaybe<PdfFieldWhere>;
  OR?: InputMaybe<Array<PdfFieldWhere>>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  options?: InputMaybe<Array<Scalars['String']['input']>>;
  options_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  order_GT?: InputMaybe<Scalars['Int']['input']>;
  order_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  order_LT?: InputMaybe<Scalars['Int']['input']>;
  order_LTE?: InputMaybe<Scalars['Int']['input']>;
  parent?: InputMaybe<PdfDocumentWhere>;
  parentAggregate?: InputMaybe<PdfFieldParentAggregateInput>;
  parentConnection?: InputMaybe<PdfFieldParentConnectionWhere>;
  parentConnection_NOT?: InputMaybe<PdfFieldParentConnectionWhere>;
  parent_NOT?: InputMaybe<PdfDocumentWhere>;
  type?: InputMaybe<PdfFieldType>;
  type_IN?: InputMaybe<Array<PdfFieldType>>;
};

/** Pagination information (Relay) */
export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['String']['output']>;
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  startCursor?: Maybe<Scalars['String']['output']>;
};

export type PathContext = {
  key: Scalars['String']['input'];
  objKey?: InputMaybe<Scalars['String']['input']>;
};

export type Patient = {
  __typename?: 'Patient';
  additionalAddressInfo?: Maybe<Scalars['String']['output']>;
  birthName?: Maybe<Scalars['String']['output']>;
  birthdate?: Maybe<Scalars['Date']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  contactEmail?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  firstNameNormalized?: Maybe<Scalars['String']['output']>;
  gender?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  interviews: Array<Interview>;
  interviewsAggregate?: Maybe<PatientInterviewInterviewsAggregationSelection>;
  interviewsConnection: PatientInterviewsConnection;
  lastName?: Maybe<Scalars['String']['output']>;
  lastNameNormalized?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  postalCode?: Maybe<Scalars['String']['output']>;
};


export type PatientInterviewsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<InterviewOptions>;
  where?: InputMaybe<InterviewWhere>;
};


export type PatientInterviewsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<InterviewWhere>;
};


export type PatientInterviewsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<PatientInterviewsConnectionSort>>;
  where?: InputMaybe<PatientInterviewsConnectionWhere>;
};

export type PatientAggregateSelection = {
  __typename?: 'PatientAggregateSelection';
  additionalAddressInfo: StringAggregateSelection;
  birthName: StringAggregateSelection;
  city: StringAggregateSelection;
  contactEmail: StringAggregateSelection;
  count: Scalars['Int']['output'];
  email: StringAggregateSelection;
  firstName: StringAggregateSelection;
  firstNameNormalized: StringAggregateSelection;
  gender: StringAggregateSelection;
  id: IdAggregateSelection;
  lastName: StringAggregateSelection;
  lastNameNormalized: StringAggregateSelection;
  phone: StringAggregateSelection;
  postalCode: StringAggregateSelection;
};

export type PatientConnectInput = {
  interviews?: InputMaybe<Array<PatientInterviewsConnectFieldInput>>;
};

export type PatientConnectOrCreateInput = {
  interviews?: InputMaybe<Array<PatientInterviewsConnectOrCreateFieldInput>>;
};

export type PatientConnectOrCreateWhere = {
  node: PatientUniqueWhere;
};

export type PatientConnectWhere = {
  node: PatientWhere;
};

export type PatientCreateInput = {
  additionalAddressInfo?: InputMaybe<Scalars['String']['input']>;
  birthName?: InputMaybe<Scalars['String']['input']>;
  birthdate?: InputMaybe<Scalars['Date']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Scalars['String']['input']>;
  interviews?: InputMaybe<PatientInterviewsFieldInput>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
};

export type PatientDeleteInput = {
  interviews?: InputMaybe<Array<PatientInterviewsDeleteFieldInput>>;
};

export type PatientDisconnectInput = {
  interviews?: InputMaybe<Array<PatientInterviewsDisconnectFieldInput>>;
};

export type PatientEdge = {
  __typename?: 'PatientEdge';
  cursor: Scalars['String']['output'];
  node: Patient;
};

export type PatientFulltext = {
  PatientAutocomplete?: InputMaybe<PatientPatientAutocompleteFulltext>;
};

/** The result of a fulltext search on an index of Patient */
export type PatientFulltextResult = {
  __typename?: 'PatientFulltextResult';
  patient: Patient;
  score: Scalars['Float']['output'];
};

/** The input for sorting a fulltext query on an index of Patient */
export type PatientFulltextSort = {
  patient?: InputMaybe<PatientSort>;
  score?: InputMaybe<SortDirection>;
};

/** The input for filtering a fulltext query on an index of Patient */
export type PatientFulltextWhere = {
  patient?: InputMaybe<PatientWhere>;
  score?: InputMaybe<FloatWhere>;
};

export type PatientInterviewInterviewsAggregationSelection = {
  __typename?: 'PatientInterviewInterviewsAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<PatientInterviewInterviewsNodeAggregateSelection>;
};

export type PatientInterviewInterviewsNodeAggregateSelection = {
  __typename?: 'PatientInterviewInterviewsNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
  id: IdAggregateSelection;
};

export type PatientInterviewsAggregateInput = {
  AND?: InputMaybe<Array<PatientInterviewsAggregateInput>>;
  NOT?: InputMaybe<PatientInterviewsAggregateInput>;
  OR?: InputMaybe<Array<PatientInterviewsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<PatientInterviewsNodeAggregationWhereInput>;
};

export type PatientInterviewsConnectFieldInput = {
  connect?: InputMaybe<Array<InterviewConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<InterviewConnectWhere>;
};

export type PatientInterviewsConnectOrCreateFieldInput = {
  onCreate: PatientInterviewsConnectOrCreateFieldInputOnCreate;
  where: InterviewConnectOrCreateWhere;
};

export type PatientInterviewsConnectOrCreateFieldInputOnCreate = {
  node: InterviewOnCreateInput;
};

export type PatientInterviewsConnection = {
  __typename?: 'PatientInterviewsConnection';
  edges: Array<PatientInterviewsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type PatientInterviewsConnectionSort = {
  node?: InputMaybe<InterviewSort>;
};

export type PatientInterviewsConnectionWhere = {
  AND?: InputMaybe<Array<PatientInterviewsConnectionWhere>>;
  NOT?: InputMaybe<PatientInterviewsConnectionWhere>;
  OR?: InputMaybe<Array<PatientInterviewsConnectionWhere>>;
  node?: InputMaybe<InterviewWhere>;
};

export type PatientInterviewsCreateFieldInput = {
  node: InterviewCreateInput;
};

export type PatientInterviewsDeleteFieldInput = {
  delete?: InputMaybe<InterviewDeleteInput>;
  where?: InputMaybe<PatientInterviewsConnectionWhere>;
};

export type PatientInterviewsDisconnectFieldInput = {
  disconnect?: InputMaybe<InterviewDisconnectInput>;
  where?: InputMaybe<PatientInterviewsConnectionWhere>;
};

export type PatientInterviewsFieldInput = {
  connect?: InputMaybe<Array<PatientInterviewsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<PatientInterviewsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<PatientInterviewsCreateFieldInput>>;
};

export type PatientInterviewsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PatientInterviewsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<PatientInterviewsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<PatientInterviewsNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PatientInterviewsRelationship = {
  __typename?: 'PatientInterviewsRelationship';
  cursor: Scalars['String']['output'];
  node: Interview;
};

export type PatientInterviewsUpdateConnectionInput = {
  node?: InputMaybe<InterviewUpdateInput>;
};

export type PatientInterviewsUpdateFieldInput = {
  connect?: InputMaybe<Array<PatientInterviewsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<PatientInterviewsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<PatientInterviewsCreateFieldInput>>;
  delete?: InputMaybe<Array<PatientInterviewsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<PatientInterviewsDisconnectFieldInput>>;
  update?: InputMaybe<PatientInterviewsUpdateConnectionInput>;
  where?: InputMaybe<PatientInterviewsConnectionWhere>;
};

export type PatientOnCreateInput = {
  additionalAddressInfo?: InputMaybe<Scalars['String']['input']>;
  birthName?: InputMaybe<Scalars['String']['input']>;
  birthdate?: InputMaybe<Scalars['Date']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
};

export type PatientOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more PatientSort objects to sort Patients by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<PatientSort>>;
};

export type PatientPatientAutocompleteFulltext = {
  phrase: Scalars['String']['input'];
};

export type PatientRelationInput = {
  interviews?: InputMaybe<Array<PatientInterviewsCreateFieldInput>>;
};

/** Fields to sort Patients by. The order in which sorts are applied is not guaranteed when specifying many fields in one PatientSort object. */
export type PatientSort = {
  additionalAddressInfo?: InputMaybe<SortDirection>;
  birthName?: InputMaybe<SortDirection>;
  birthdate?: InputMaybe<SortDirection>;
  city?: InputMaybe<SortDirection>;
  contactEmail?: InputMaybe<SortDirection>;
  email?: InputMaybe<SortDirection>;
  firstName?: InputMaybe<SortDirection>;
  firstNameNormalized?: InputMaybe<SortDirection>;
  gender?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  lastName?: InputMaybe<SortDirection>;
  lastNameNormalized?: InputMaybe<SortDirection>;
  phone?: InputMaybe<SortDirection>;
  postalCode?: InputMaybe<SortDirection>;
};

export type PatientUniqueWhere = {
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type PatientUpdateInput = {
  additionalAddressInfo?: InputMaybe<Scalars['String']['input']>;
  birthName?: InputMaybe<Scalars['String']['input']>;
  birthdate?: InputMaybe<Scalars['Date']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Scalars['String']['input']>;
  interviews?: InputMaybe<Array<PatientInterviewsUpdateFieldInput>>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
};

export type PatientWhere = {
  AND?: InputMaybe<Array<PatientWhere>>;
  NOT?: InputMaybe<PatientWhere>;
  OR?: InputMaybe<Array<PatientWhere>>;
  additionalAddressInfo?: InputMaybe<Scalars['String']['input']>;
  additionalAddressInfo_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  additionalAddressInfo_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  additionalAddressInfo_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  additionalAddressInfo_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  birthName?: InputMaybe<Scalars['String']['input']>;
  birthName_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  birthName_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  birthName_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  birthName_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  birthdate?: InputMaybe<Scalars['Date']['input']>;
  birthdate_GT?: InputMaybe<Scalars['Date']['input']>;
  birthdate_GTE?: InputMaybe<Scalars['Date']['input']>;
  birthdate_IN?: InputMaybe<Array<InputMaybe<Scalars['Date']['input']>>>;
  birthdate_LT?: InputMaybe<Scalars['Date']['input']>;
  birthdate_LTE?: InputMaybe<Scalars['Date']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  city_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  city_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  city_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  city_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactEmail_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  contactEmail_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  contactEmail_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  contactEmail_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  email_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  email_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  email_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  email_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  firstNameNormalized?: InputMaybe<Scalars['String']['input']>;
  firstNameNormalized_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  firstNameNormalized_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  firstNameNormalized_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  firstNameNormalized_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  firstName_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  firstName_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  firstName_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  firstName_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Scalars['String']['input']>;
  gender_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  gender_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  gender_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  gender_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  interviewsAggregate?: InputMaybe<PatientInterviewsAggregateInput>;
  /** Return Patients where all of the related PatientInterviewsConnections match this filter */
  interviewsConnection_ALL?: InputMaybe<PatientInterviewsConnectionWhere>;
  /** Return Patients where none of the related PatientInterviewsConnections match this filter */
  interviewsConnection_NONE?: InputMaybe<PatientInterviewsConnectionWhere>;
  /** Return Patients where one of the related PatientInterviewsConnections match this filter */
  interviewsConnection_SINGLE?: InputMaybe<PatientInterviewsConnectionWhere>;
  /** Return Patients where some of the related PatientInterviewsConnections match this filter */
  interviewsConnection_SOME?: InputMaybe<PatientInterviewsConnectionWhere>;
  /** Return Patients where all of the related Interviews match this filter */
  interviews_ALL?: InputMaybe<InterviewWhere>;
  /** Return Patients where none of the related Interviews match this filter */
  interviews_NONE?: InputMaybe<InterviewWhere>;
  /** Return Patients where one of the related Interviews match this filter */
  interviews_SINGLE?: InputMaybe<InterviewWhere>;
  /** Return Patients where some of the related Interviews match this filter */
  interviews_SOME?: InputMaybe<InterviewWhere>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastNameNormalized?: InputMaybe<Scalars['String']['input']>;
  lastNameNormalized_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  lastNameNormalized_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  lastNameNormalized_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  lastNameNormalized_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  lastName_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  lastName_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  lastName_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  lastName_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phone_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  phone_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  phone_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  phone_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  postalCode_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  postalCode_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  postalCode_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  postalCode_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type PatientsConnection = {
  __typename?: 'PatientsConnection';
  edges: Array<PatientEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type PdfDocumentsConnection = {
  __typename?: 'PdfDocumentsConnection';
  edges: Array<PdfDocumentEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type PostalAddress = {
  __typename?: 'PostalAddress';
  city: Scalars['String']['output'];
  country: CountryCode;
  postalCode: Scalars['String']['output'];
  street: Scalars['String']['output'];
};

export type PostalAddressAggregateSelection = {
  __typename?: 'PostalAddressAggregateSelection';
  city: StringAggregateSelection;
  count: Scalars['Int']['output'];
  postalCode: StringAggregateSelection;
  street: StringAggregateSelection;
};

export type PostalAddressConnectWhere = {
  node: PostalAddressWhere;
};

export type PostalAddressCreateInput = {
  city: Scalars['String']['input'];
  country: CountryCode;
  postalCode: Scalars['String']['input'];
  street: Scalars['String']['input'];
};

export type PostalAddressEdge = {
  __typename?: 'PostalAddressEdge';
  cursor: Scalars['String']['output'];
  node: PostalAddress;
};

export type PostalAddressOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more PostalAddressSort objects to sort PostalAddresses by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<PostalAddressSort>>;
};

/** Fields to sort PostalAddresses by. The order in which sorts are applied is not guaranteed when specifying many fields in one PostalAddressSort object. */
export type PostalAddressSort = {
  city?: InputMaybe<SortDirection>;
  country?: InputMaybe<SortDirection>;
  postalCode?: InputMaybe<SortDirection>;
  street?: InputMaybe<SortDirection>;
};

export type PostalAddressUpdateInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  street?: InputMaybe<Scalars['String']['input']>;
};

export type PostalAddressWhere = {
  AND?: InputMaybe<Array<PostalAddressWhere>>;
  NOT?: InputMaybe<PostalAddressWhere>;
  OR?: InputMaybe<Array<PostalAddressWhere>>;
  city?: InputMaybe<Scalars['String']['input']>;
  city_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  city_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  city_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  city_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<CountryCode>;
  country_IN?: InputMaybe<Array<CountryCode>>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  postalCode_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  postalCode_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  postalCode_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  postalCode_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  street?: InputMaybe<Scalars['String']['input']>;
  street_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  street_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  street_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  street_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type PostalAddressesConnection = {
  __typename?: 'PostalAddressesConnection';
  edges: Array<PostalAddressEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Query = {
  __typename?: 'Query';
  aiResponse?: Maybe<AiResponse>;
  aiResponses: Array<AiResponse>;
  aiResponsesAggregate: AiResponseAggregateSelection;
  aiResponsesConnection: AiResponsesConnection;
  alertGroups: Array<AlertGroup>;
  alertGroupsAggregate: AlertGroupAggregateSelection;
  alertGroupsConnection: AlertGroupsConnection;
  alerts: Array<Alert>;
  alertsAggregate: AlertAggregateSelection;
  alertsConnection: AlertsConnection;
  answers: Array<Answer>;
  answersAggregate: AnswerAggregateSelection;
  answersConnection: AnswersConnection;
  baseQuestionnaires: Array<BaseQuestionnaire>;
  baseQuestionnairesAggregate: BaseQuestionnaireAggregateSelection;
  baseQuestionnairesConnection: BaseQuestionnairesConnection;
  checkboxQuestions: Array<CheckboxQuestion>;
  checkboxQuestionsAggregate: CheckboxQuestionAggregateSelection;
  checkboxQuestionsConnection: CheckboxQuestionsConnection;
  conditionGroups: Array<ConditionGroup>;
  conditionGroupsAggregate: ConditionGroupAggregateSelection;
  conditionGroupsConnection: ConditionGroupsConnection;
  conditions: Array<Condition>;
  conditionsAggregate: ConditionAggregateSelection;
  conditionsConnection: ConditionsConnection;
  configurations: Array<Configuration>;
  configurationsAggregate: ConfigurationAggregateSelection;
  configurationsConnection: ConfigurationsConnection;
  cooldowns: Array<Cooldown>;
  cooldownsAggregate: CooldownAggregateSelection;
  cooldownsConnection: CooldownsConnection;
  countQuestionnaireByDoctor: Scalars['Int']['output'];
  countQuestions: Scalars['Int']['output'];
  dateQuestions: Array<DateQuestion>;
  dateQuestionsAggregate: DateQuestionAggregateSelection;
  dateQuestionsConnection: DateQuestionsConnection;
  deleteInfos: Array<DeleteInfo>;
  deleteInfosAggregate: DeleteInfoAggregateSelection;
  deleteInfosConnection: DeleteInfosConnection;
  devices: Array<Device>;
  devicesAggregate: DeviceAggregateSelection;
  devicesConnection: DevicesConnection;
  doctors: Array<Doctor>;
  doctorsAggregate: DoctorAggregateSelection;
  /** Query a full-text index. This query returns the query score, but does not allow for aggregations. Use the `fulltext` argument under other queries for this functionality. */
  doctorsAutocomplete: Array<DoctorFulltextResult>;
  doctorsConnection: DoctorsConnection;
  documents: Array<Document>;
  documentsAggregate: DocumentAggregateSelection;
  documentsConnection: DocumentsConnection;
  editors: Array<Editor>;
  evaluateStep?: Maybe<Scalars['ID']['output']>;
  getPatientSelectMenuChoice: Array<Scalars['String']['output']>;
  getQuestionFromWorkflow: Array<SearchQuestionResult>;
  institutions: Array<Institution>;
  institutionsAggregate: InstitutionAggregateSelection;
  /** Query a full-text index. This query returns the query score, but does not allow for aggregations. Use the `fulltext` argument under other queries for this functionality. */
  institutionsAutocomplete: Array<InstitutionFulltextResult>;
  institutionsConnection: InstitutionsConnection;
  interviews: Array<Interview>;
  interviewsAggregate: InterviewAggregateSelection;
  interviewsConnection: InterviewsConnection;
  invoices: Array<Invoice>;
  invoicesAggregate: InvoiceAggregateSelection;
  invoicesConnection: InvoicesConnection;
  isEmailAlreadyTaken: Scalars['Boolean']['output'];
  isThirdPartySession?: Maybe<Scalars['Boolean']['output']>;
  links: Array<Link>;
  loadQuestionnaire?: Maybe<UnserializationResponse>;
  loadWorkflow?: Maybe<UnserializationResponse>;
  managers: Array<Manager>;
  managersAggregate: ManagerAggregateSelection;
  managersConnection: ManagersConnection;
  meDoctor?: Maybe<Doctor>;
  meManager?: Maybe<Manager>;
  nextStep?: Maybe<Scalars['ID']['output']>;
  owners: Array<Owner>;
  /** Query a full-text index. This query returns the query score, but does not allow for aggregations. Use the `fulltext` argument under other queries for this functionality. */
  patientAutocomplete: Array<PatientFulltextResult>;
  patients: Array<Patient>;
  patientsAggregate: PatientAggregateSelection;
  patientsConnection: PatientsConnection;
  pdfDocuments: Array<PdfDocument>;
  pdfDocumentsAggregate: PdfDocumentAggregateSelection;
  pdfDocumentsConnection: PdfDocumentsConnection;
  postalAddresses: Array<PostalAddress>;
  postalAddressesAggregate: PostalAddressAggregateSelection;
  postalAddressesConnection: PostalAddressesConnection;
  previewExport: ExportTable;
  questionItems: Array<QuestionItem>;
  questionItemsAggregate: QuestionItemAggregateSelection;
  questionItemsConnection: QuestionItemsConnection;
  questionnaireAis: Array<QuestionnaireAi>;
  questionnaireAisAggregate: QuestionnaireAiAggregateSelection;
  questionnaireAisConnection: QuestionnaireAisConnection;
  questionnaireAlerts: Array<QuestionnaireAlerts>;
  questionnaireAlertsAggregate: QuestionnaireAlertsAggregateSelection;
  questionnaireAlertsConnection: QuestionnaireAlertsConnection;
  questionnaireAppointmentDates: Array<QuestionnaireAppointmentDate>;
  questionnaireAppointmentDatesAggregate: QuestionnaireAppointmentDateAggregateSelection;
  questionnaireAppointmentDatesConnection: QuestionnaireAppointmentDatesConnection;
  /** Query a full-text index. This query returns the query score, but does not allow for aggregations. Use the `fulltext` argument under other queries for this functionality. */
  questionnaireAutocomplete: Array<QuestionnaireFulltextResult>;
  questionnaireConditions: Array<QuestionnaireCondition>;
  questionnaireConditionsAggregate: QuestionnaireConditionAggregateSelection;
  questionnaireConditionsConnection: QuestionnaireConditionsConnection;
  questionnaireDocumentFillers: Array<QuestionnaireDocumentFiller>;
  questionnaireDocumentFillersAggregate: QuestionnaireDocumentFillerAggregateSelection;
  questionnaireDocumentFillersConnection: QuestionnaireDocumentFillersConnection;
  questionnaireDocuments: Array<QuestionnaireDocument>;
  questionnaireDocumentsAggregate: QuestionnaireDocumentAggregateSelection;
  questionnaireDocumentsConnection: QuestionnaireDocumentsConnection;
  questionnaireFromInstitution: Array<Questionnaire>;
  questionnaireIdentities: Array<QuestionnaireIdentity>;
  questionnaireIdentitiesAggregate: QuestionnaireIdentityAggregateSelection;
  questionnaireIdentitiesConnection: QuestionnaireIdentitiesConnection;
  questionnaireInfoSteps: Array<QuestionnaireInfoStep>;
  questionnaireInfoStepsAggregate: QuestionnaireInfoStepAggregateSelection;
  questionnaireInfoStepsConnection: QuestionnaireInfoStepsConnection;
  questionnaireInterviews: Array<QuestionnaireInterview>;
  questionnaireInterviewsAggregate: QuestionnaireInterviewAggregateSelection;
  questionnaireInterviewsConnection: QuestionnaireInterviewsConnection;
  questionnaireMenuEntries: Array<QuestionnaireMenuEntry>;
  questionnaireMenuEntriesAggregate: QuestionnaireMenuEntryAggregateSelection;
  questionnaireMenuEntriesConnection: QuestionnaireMenuEntriesConnection;
  questionnaireMenuItems: Array<QuestionnaireMenuItem>;
  questionnaireMenuItemsAggregate: QuestionnaireMenuItemAggregateSelection;
  questionnaireMenuItemsConnection: QuestionnaireMenuItemsConnection;
  questionnaireMenus: Array<QuestionnaireMenu>;
  questionnaireMenusAggregate: QuestionnaireMenuAggregateSelection;
  questionnaireMenusConnection: QuestionnaireMenusConnection;
  questionnaireRouters: Array<QuestionnaireRouter>;
  questionnaireRoutersAggregate: QuestionnaireRouterAggregateSelection;
  questionnaireRoutersConnection: QuestionnaireRoutersConnection;
  questionnaireSelectMenus: Array<QuestionnaireSelectMenu>;
  questionnaireSelectMenusAggregate: QuestionnaireSelectMenuAggregateSelection;
  questionnaireSelectMenusConnection: QuestionnaireSelectMenusConnection;
  questionnaireSetProperties: Array<QuestionnaireSetProperty>;
  questionnaireSetPropertiesAggregate: QuestionnaireSetPropertyAggregateSelection;
  questionnaireSetPropertiesConnection: QuestionnaireSetPropertiesConnection;
  questionnaireSteps: Array<QuestionnaireStep>;
  questionnaireStepsAggregate: QuestionnaireStepAggregateSelection;
  questionnaireStepsConnection: QuestionnaireStepsConnection;
  questionnaireSurveys: Array<QuestionnaireSurvey>;
  questionnaireSurveysAggregate: QuestionnaireSurveyAggregateSelection;
  questionnaireSurveysConnection: QuestionnaireSurveysConnection;
  questionnaireThirdParties: Array<QuestionnaireThirdParty>;
  questionnaireThirdPartiesAggregate: QuestionnaireThirdPartyAggregateSelection;
  questionnaireThirdPartiesConnection: QuestionnaireThirdPartiesConnection;
  questionnaireWelcomeSteps: Array<QuestionnaireWelcomeStep>;
  questionnaireWelcomeStepsAggregate: QuestionnaireWelcomeStepAggregateSelection;
  questionnaireWelcomeStepsConnection: QuestionnaireWelcomeStepsConnection;
  questionnaires: Array<Questionnaire>;
  questionnairesAggregate: QuestionnaireAggregateSelection;
  questionnairesConnection: QuestionnairesConnection;
  questions: Array<Question>;
  questionsAggregate: QuestionAggregateSelection;
  questionsConnection: QuestionsConnection;
  quotings: Array<Quoting>;
  quotingsAggregate: QuotingAggregateSelection;
  quotingsConnection: QuotingsConnection;
  radioQuestions: Array<RadioQuestion>;
  radioQuestionsAggregate: RadioQuestionAggregateSelection;
  radioQuestionsConnection: RadioQuestionsConnection;
  rangeQuestions: Array<RangeQuestion>;
  rangeQuestionsAggregate: RangeQuestionAggregateSelection;
  rangeQuestionsConnection: RangeQuestionsConnection;
  searchQuestion: Array<SearchQuestionResult>;
  searchQuestionResults: Array<SearchQuestionResult>;
  searchQuestionResultsAggregate: SearchQuestionResultAggregateSelection;
  searchQuestionResultsConnection: SearchQuestionResultsConnection;
  searchQuestionnaire: Array<Questionnaire>;
  selectQuestions: Array<SelectQuestion>;
  selectQuestionsAggregate: SelectQuestionAggregateSelection;
  selectQuestionsConnection: SelectQuestionsConnection;
  serializationNodes: Array<SerializationNode>;
  serializationNodesAggregate: SerializationNodeAggregateSelection;
  serializationNodesConnection: SerializationNodesConnection;
  serializationSockets: Array<SerializationSocket>;
  serializationSocketsAggregate: SerializationSocketAggregateSelection;
  serializationSocketsConnection: SerializationSocketsConnection;
  specialities: Array<Speciality>;
  specialitiesAggregate: SpecialityAggregateSelection;
  specialitiesConnection: SpecialitiesConnection;
  statAnswersByWorkflow?: Maybe<ExportAnswersByWorkflow>;
  statInterviewsByDoctors: Array<InterviewsByDoctors>;
  statInterviewsByLink: Array<InterviewsByLink>;
  statInterviewsByWorkflow: ExportInterviewsByWorkflow;
  textQuestions: Array<TextQuestion>;
  textQuestionsAggregate: TextQuestionAggregateSelection;
  textQuestionsConnection: TextQuestionsConnection;
  unserializationResponses: Array<UnserializationResponse>;
  unserializationResponsesAggregate: UnserializationResponseAggregateSelection;
  unserializationResponsesConnection: UnserializationResponsesConnection;
  users: Array<User>;
  usersAggregate: UserAggregateSelection;
  usersConnection: UsersConnection;
  versionnedGraphs: Array<VersionnedGraph>;
  versionnedGraphsAggregate: VersionnedGraphAggregateSelection;
  versionnedGraphsConnection: VersionnedGraphsConnection;
  workflowFromDoctor: Array<Workflow>;
  workflowFromInstitution: Array<Workflow>;
  workflowLinks: Array<WorkflowLink>;
  workflowLinksAggregate: WorkflowLinkAggregateSelection;
  workflowLinksConnection: WorkflowLinksConnection;
  workflows: Array<Workflow>;
  workflowsAggregate: WorkflowAggregateSelection;
  workflowsConnection: WorkflowsConnection;
};


export type QueryAiResponseArgs = {
  questionIndex: Scalars['Int']['input'];
  questionnaireId: Scalars['ID']['input'];
};


export type QueryAiResponsesArgs = {
  options?: InputMaybe<AiResponseOptions>;
  where?: InputMaybe<AiResponseWhere>;
};


export type QueryAiResponsesAggregateArgs = {
  where?: InputMaybe<AiResponseWhere>;
};


export type QueryAiResponsesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<AiResponseSort>>>;
  where?: InputMaybe<AiResponseWhere>;
};


export type QueryAlertGroupsArgs = {
  options?: InputMaybe<AlertGroupOptions>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type QueryAlertGroupsAggregateArgs = {
  where?: InputMaybe<AlertGroupWhere>;
};


export type QueryAlertGroupsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type QueryAlertsArgs = {
  options?: InputMaybe<AlertOptions>;
  where?: InputMaybe<AlertWhere>;
};


export type QueryAlertsAggregateArgs = {
  where?: InputMaybe<AlertWhere>;
};


export type QueryAlertsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<AlertSort>>>;
  where?: InputMaybe<AlertWhere>;
};


export type QueryAnswersArgs = {
  options?: InputMaybe<AnswerOptions>;
  where?: InputMaybe<AnswerWhere>;
};


export type QueryAnswersAggregateArgs = {
  where?: InputMaybe<AnswerWhere>;
};


export type QueryAnswersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<AnswerSort>>>;
  where?: InputMaybe<AnswerWhere>;
};


export type QueryBaseQuestionnairesArgs = {
  options?: InputMaybe<BaseQuestionnaireOptions>;
  where?: InputMaybe<BaseQuestionnaireWhere>;
};


export type QueryBaseQuestionnairesAggregateArgs = {
  where?: InputMaybe<BaseQuestionnaireWhere>;
};


export type QueryBaseQuestionnairesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<BaseQuestionnaireSort>>>;
  where?: InputMaybe<BaseQuestionnaireWhere>;
};


export type QueryCheckboxQuestionsArgs = {
  options?: InputMaybe<CheckboxQuestionOptions>;
  where?: InputMaybe<CheckboxQuestionWhere>;
};


export type QueryCheckboxQuestionsAggregateArgs = {
  where?: InputMaybe<CheckboxQuestionWhere>;
};


export type QueryCheckboxQuestionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<CheckboxQuestionSort>>>;
  where?: InputMaybe<CheckboxQuestionWhere>;
};


export type QueryConditionGroupsArgs = {
  options?: InputMaybe<ConditionGroupOptions>;
  where?: InputMaybe<ConditionGroupWhere>;
};


export type QueryConditionGroupsAggregateArgs = {
  where?: InputMaybe<ConditionGroupWhere>;
};


export type QueryConditionGroupsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<ConditionGroupSort>>>;
  where?: InputMaybe<ConditionGroupWhere>;
};


export type QueryConditionsArgs = {
  options?: InputMaybe<ConditionOptions>;
  where?: InputMaybe<ConditionWhere>;
};


export type QueryConditionsAggregateArgs = {
  where?: InputMaybe<ConditionWhere>;
};


export type QueryConditionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<ConditionSort>>>;
  where?: InputMaybe<ConditionWhere>;
};


export type QueryConfigurationsArgs = {
  options?: InputMaybe<ConfigurationOptions>;
  where?: InputMaybe<ConfigurationWhere>;
};


export type QueryConfigurationsAggregateArgs = {
  where?: InputMaybe<ConfigurationWhere>;
};


export type QueryConfigurationsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<ConfigurationSort>>>;
  where?: InputMaybe<ConfigurationWhere>;
};


export type QueryCooldownsArgs = {
  options?: InputMaybe<CooldownOptions>;
  where?: InputMaybe<CooldownWhere>;
};


export type QueryCooldownsAggregateArgs = {
  where?: InputMaybe<CooldownWhere>;
};


export type QueryCooldownsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<CooldownSort>>>;
  where?: InputMaybe<CooldownWhere>;
};


export type QueryCountQuestionnaireByDoctorArgs = {
  doctorId: Scalars['ID']['input'];
  questionnaireName: Scalars['String']['input'];
};


export type QueryDateQuestionsArgs = {
  options?: InputMaybe<DateQuestionOptions>;
  where?: InputMaybe<DateQuestionWhere>;
};


export type QueryDateQuestionsAggregateArgs = {
  where?: InputMaybe<DateQuestionWhere>;
};


export type QueryDateQuestionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<DateQuestionSort>>>;
  where?: InputMaybe<DateQuestionWhere>;
};


export type QueryDeleteInfosArgs = {
  options?: InputMaybe<DeleteInfoOptions>;
  where?: InputMaybe<DeleteInfoWhere>;
};


export type QueryDeleteInfosAggregateArgs = {
  where?: InputMaybe<DeleteInfoWhere>;
};


export type QueryDeleteInfosConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<DeleteInfoSort>>>;
  where?: InputMaybe<DeleteInfoWhere>;
};


export type QueryDevicesArgs = {
  options?: InputMaybe<DeviceOptions>;
  where?: InputMaybe<DeviceWhere>;
};


export type QueryDevicesAggregateArgs = {
  where?: InputMaybe<DeviceWhere>;
};


export type QueryDevicesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<DeviceSort>>>;
  where?: InputMaybe<DeviceWhere>;
};


export type QueryDoctorsArgs = {
  fulltext?: InputMaybe<DoctorFulltext>;
  options?: InputMaybe<DoctorOptions>;
  where?: InputMaybe<DoctorWhere>;
};


export type QueryDoctorsAggregateArgs = {
  fulltext?: InputMaybe<DoctorFulltext>;
  where?: InputMaybe<DoctorWhere>;
};


export type QueryDoctorsAutocompleteArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  phrase: Scalars['String']['input'];
  sort?: InputMaybe<Array<DoctorFulltextSort>>;
  where?: InputMaybe<DoctorFulltextWhere>;
};


export type QueryDoctorsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fulltext?: InputMaybe<DoctorFulltext>;
  sort?: InputMaybe<Array<InputMaybe<DoctorSort>>>;
  where?: InputMaybe<DoctorWhere>;
};


export type QueryDocumentsArgs = {
  options?: InputMaybe<DocumentOptions>;
  where?: InputMaybe<DocumentWhere>;
};


export type QueryDocumentsAggregateArgs = {
  where?: InputMaybe<DocumentWhere>;
};


export type QueryDocumentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<DocumentSort>>>;
  where?: InputMaybe<DocumentWhere>;
};


export type QueryEditorsArgs = {
  options?: InputMaybe<QueryOptions>;
  where?: InputMaybe<EditorWhere>;
};


export type QueryEvaluateStepArgs = {
  question: Scalars['ID']['input'];
  session: Scalars['ID']['input'];
};


export type QueryGetPatientSelectMenuChoiceArgs = {
  field?: InputMaybe<Scalars['String']['input']>;
  session: Scalars['String']['input'];
};


export type QueryGetQuestionFromWorkflowArgs = {
  institutionId: Scalars['ID']['input'];
  workflowId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryInstitutionsArgs = {
  fulltext?: InputMaybe<InstitutionFulltext>;
  options?: InputMaybe<InstitutionOptions>;
  where?: InputMaybe<InstitutionWhere>;
};


export type QueryInstitutionsAggregateArgs = {
  fulltext?: InputMaybe<InstitutionFulltext>;
  where?: InputMaybe<InstitutionWhere>;
};


export type QueryInstitutionsAutocompleteArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  phrase: Scalars['String']['input'];
  sort?: InputMaybe<Array<InstitutionFulltextSort>>;
  where?: InputMaybe<InstitutionFulltextWhere>;
};


export type QueryInstitutionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fulltext?: InputMaybe<InstitutionFulltext>;
  sort?: InputMaybe<Array<InputMaybe<InstitutionSort>>>;
  where?: InputMaybe<InstitutionWhere>;
};


export type QueryInterviewsArgs = {
  options?: InputMaybe<InterviewOptions>;
  where?: InputMaybe<InterviewWhere>;
};


export type QueryInterviewsAggregateArgs = {
  where?: InputMaybe<InterviewWhere>;
};


export type QueryInterviewsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<InterviewSort>>>;
  where?: InputMaybe<InterviewWhere>;
};


export type QueryInvoicesArgs = {
  options?: InputMaybe<InvoiceOptions>;
  where?: InputMaybe<InvoiceWhere>;
};


export type QueryInvoicesAggregateArgs = {
  where?: InputMaybe<InvoiceWhere>;
};


export type QueryInvoicesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<InvoiceSort>>>;
  where?: InputMaybe<InvoiceWhere>;
};


export type QueryIsThirdPartySessionArgs = {
  session: Scalars['ID']['input'];
};


export type QueryLinksArgs = {
  options?: InputMaybe<QueryOptions>;
  where?: InputMaybe<LinkWhere>;
};


export type QueryLoadQuestionnaireArgs = {
  id: Scalars['ID']['input'];
};


export type QueryLoadWorkflowArgs = {
  id: Scalars['ID']['input'];
};


export type QueryManagersArgs = {
  options?: InputMaybe<ManagerOptions>;
  where?: InputMaybe<ManagerWhere>;
};


export type QueryManagersAggregateArgs = {
  where?: InputMaybe<ManagerWhere>;
};


export type QueryManagersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<ManagerSort>>>;
  where?: InputMaybe<ManagerWhere>;
};


export type QueryNextStepArgs = {
  question: Scalars['ID']['input'];
  session: Scalars['ID']['input'];
};


export type QueryOwnersArgs = {
  options?: InputMaybe<QueryOptions>;
  where?: InputMaybe<OwnerWhere>;
};


export type QueryPatientAutocompleteArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  phrase: Scalars['String']['input'];
  sort?: InputMaybe<Array<PatientFulltextSort>>;
  where?: InputMaybe<PatientFulltextWhere>;
};


export type QueryPatientsArgs = {
  fulltext?: InputMaybe<PatientFulltext>;
  options?: InputMaybe<PatientOptions>;
  where?: InputMaybe<PatientWhere>;
};


export type QueryPatientsAggregateArgs = {
  fulltext?: InputMaybe<PatientFulltext>;
  where?: InputMaybe<PatientWhere>;
};


export type QueryPatientsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fulltext?: InputMaybe<PatientFulltext>;
  sort?: InputMaybe<Array<InputMaybe<PatientSort>>>;
  where?: InputMaybe<PatientWhere>;
};


export type QueryPdfDocumentsArgs = {
  options?: InputMaybe<PdfDocumentOptions>;
  where?: InputMaybe<PdfDocumentWhere>;
};


export type QueryPdfDocumentsAggregateArgs = {
  where?: InputMaybe<PdfDocumentWhere>;
};


export type QueryPdfDocumentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<PdfDocumentSort>>>;
  where?: InputMaybe<PdfDocumentWhere>;
};


export type QueryPostalAddressesArgs = {
  options?: InputMaybe<PostalAddressOptions>;
  where?: InputMaybe<PostalAddressWhere>;
};


export type QueryPostalAddressesAggregateArgs = {
  where?: InputMaybe<PostalAddressWhere>;
};


export type QueryPostalAddressesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<PostalAddressSort>>>;
  where?: InputMaybe<PostalAddressWhere>;
};


export type QueryPreviewExportArgs = {
  exportParams: ExportParams;
};


export type QueryQuestionItemsArgs = {
  options?: InputMaybe<QuestionItemOptions>;
  where?: InputMaybe<QuestionItemWhere>;
};


export type QueryQuestionItemsAggregateArgs = {
  where?: InputMaybe<QuestionItemWhere>;
};


export type QueryQuestionItemsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionItemSort>>>;
  where?: InputMaybe<QuestionItemWhere>;
};


export type QueryQuestionnaireAisArgs = {
  options?: InputMaybe<QuestionnaireAiOptions>;
  where?: InputMaybe<QuestionnaireAiWhere>;
};


export type QueryQuestionnaireAisAggregateArgs = {
  where?: InputMaybe<QuestionnaireAiWhere>;
};


export type QueryQuestionnaireAisConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireAiSort>>>;
  where?: InputMaybe<QuestionnaireAiWhere>;
};


export type QueryQuestionnaireAlertsArgs = {
  options?: InputMaybe<QuestionnaireAlertsOptions>;
  where?: InputMaybe<QuestionnaireAlertsWhere>;
};


export type QueryQuestionnaireAlertsAggregateArgs = {
  where?: InputMaybe<QuestionnaireAlertsWhere>;
};


export type QueryQuestionnaireAlertsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireAlertsSort>>>;
  where?: InputMaybe<QuestionnaireAlertsWhere>;
};


export type QueryQuestionnaireAppointmentDatesArgs = {
  options?: InputMaybe<QuestionnaireAppointmentDateOptions>;
  where?: InputMaybe<QuestionnaireAppointmentDateWhere>;
};


export type QueryQuestionnaireAppointmentDatesAggregateArgs = {
  where?: InputMaybe<QuestionnaireAppointmentDateWhere>;
};


export type QueryQuestionnaireAppointmentDatesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireAppointmentDateSort>>>;
  where?: InputMaybe<QuestionnaireAppointmentDateWhere>;
};


export type QueryQuestionnaireAutocompleteArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  phrase: Scalars['String']['input'];
  sort?: InputMaybe<Array<QuestionnaireFulltextSort>>;
  where?: InputMaybe<QuestionnaireFulltextWhere>;
};


export type QueryQuestionnaireConditionsArgs = {
  options?: InputMaybe<QuestionnaireConditionOptions>;
  where?: InputMaybe<QuestionnaireConditionWhere>;
};


export type QueryQuestionnaireConditionsAggregateArgs = {
  where?: InputMaybe<QuestionnaireConditionWhere>;
};


export type QueryQuestionnaireConditionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireConditionSort>>>;
  where?: InputMaybe<QuestionnaireConditionWhere>;
};


export type QueryQuestionnaireDocumentFillersArgs = {
  options?: InputMaybe<QuestionnaireDocumentFillerOptions>;
  where?: InputMaybe<QuestionnaireDocumentFillerWhere>;
};


export type QueryQuestionnaireDocumentFillersAggregateArgs = {
  where?: InputMaybe<QuestionnaireDocumentFillerWhere>;
};


export type QueryQuestionnaireDocumentFillersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireDocumentFillerSort>>>;
  where?: InputMaybe<QuestionnaireDocumentFillerWhere>;
};


export type QueryQuestionnaireDocumentsArgs = {
  options?: InputMaybe<QuestionnaireDocumentOptions>;
  where?: InputMaybe<QuestionnaireDocumentWhere>;
};


export type QueryQuestionnaireDocumentsAggregateArgs = {
  where?: InputMaybe<QuestionnaireDocumentWhere>;
};


export type QueryQuestionnaireDocumentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireDocumentSort>>>;
  where?: InputMaybe<QuestionnaireDocumentWhere>;
};


export type QueryQuestionnaireFromInstitutionArgs = {
  institutionId: Scalars['ID']['input'];
  searchText: Scalars['String']['input'];
  withTemplate?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryQuestionnaireIdentitiesArgs = {
  options?: InputMaybe<QuestionnaireIdentityOptions>;
  where?: InputMaybe<QuestionnaireIdentityWhere>;
};


export type QueryQuestionnaireIdentitiesAggregateArgs = {
  where?: InputMaybe<QuestionnaireIdentityWhere>;
};


export type QueryQuestionnaireIdentitiesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireIdentitySort>>>;
  where?: InputMaybe<QuestionnaireIdentityWhere>;
};


export type QueryQuestionnaireInfoStepsArgs = {
  options?: InputMaybe<QuestionnaireInfoStepOptions>;
  where?: InputMaybe<QuestionnaireInfoStepWhere>;
};


export type QueryQuestionnaireInfoStepsAggregateArgs = {
  where?: InputMaybe<QuestionnaireInfoStepWhere>;
};


export type QueryQuestionnaireInfoStepsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireInfoStepSort>>>;
  where?: InputMaybe<QuestionnaireInfoStepWhere>;
};


export type QueryQuestionnaireInterviewsArgs = {
  options?: InputMaybe<QuestionnaireInterviewOptions>;
  where?: InputMaybe<QuestionnaireInterviewWhere>;
};


export type QueryQuestionnaireInterviewsAggregateArgs = {
  where?: InputMaybe<QuestionnaireInterviewWhere>;
};


export type QueryQuestionnaireInterviewsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireInterviewSort>>>;
  where?: InputMaybe<QuestionnaireInterviewWhere>;
};


export type QueryQuestionnaireMenuEntriesArgs = {
  options?: InputMaybe<QuestionnaireMenuEntryOptions>;
  where?: InputMaybe<QuestionnaireMenuEntryWhere>;
};


export type QueryQuestionnaireMenuEntriesAggregateArgs = {
  where?: InputMaybe<QuestionnaireMenuEntryWhere>;
};


export type QueryQuestionnaireMenuEntriesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireMenuEntrySort>>>;
  where?: InputMaybe<QuestionnaireMenuEntryWhere>;
};


export type QueryQuestionnaireMenuItemsArgs = {
  options?: InputMaybe<QuestionnaireMenuItemOptions>;
  where?: InputMaybe<QuestionnaireMenuItemWhere>;
};


export type QueryQuestionnaireMenuItemsAggregateArgs = {
  where?: InputMaybe<QuestionnaireMenuItemWhere>;
};


export type QueryQuestionnaireMenuItemsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireMenuItemSort>>>;
  where?: InputMaybe<QuestionnaireMenuItemWhere>;
};


export type QueryQuestionnaireMenusArgs = {
  options?: InputMaybe<QuestionnaireMenuOptions>;
  where?: InputMaybe<QuestionnaireMenuWhere>;
};


export type QueryQuestionnaireMenusAggregateArgs = {
  where?: InputMaybe<QuestionnaireMenuWhere>;
};


export type QueryQuestionnaireMenusConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireMenuSort>>>;
  where?: InputMaybe<QuestionnaireMenuWhere>;
};


export type QueryQuestionnaireRoutersArgs = {
  options?: InputMaybe<QuestionnaireRouterOptions>;
  where?: InputMaybe<QuestionnaireRouterWhere>;
};


export type QueryQuestionnaireRoutersAggregateArgs = {
  where?: InputMaybe<QuestionnaireRouterWhere>;
};


export type QueryQuestionnaireRoutersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireRouterSort>>>;
  where?: InputMaybe<QuestionnaireRouterWhere>;
};


export type QueryQuestionnaireSelectMenusArgs = {
  options?: InputMaybe<QuestionnaireSelectMenuOptions>;
  where?: InputMaybe<QuestionnaireSelectMenuWhere>;
};


export type QueryQuestionnaireSelectMenusAggregateArgs = {
  where?: InputMaybe<QuestionnaireSelectMenuWhere>;
};


export type QueryQuestionnaireSelectMenusConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireSelectMenuSort>>>;
  where?: InputMaybe<QuestionnaireSelectMenuWhere>;
};


export type QueryQuestionnaireSetPropertiesArgs = {
  options?: InputMaybe<QuestionnaireSetPropertyOptions>;
  where?: InputMaybe<QuestionnaireSetPropertyWhere>;
};


export type QueryQuestionnaireSetPropertiesAggregateArgs = {
  where?: InputMaybe<QuestionnaireSetPropertyWhere>;
};


export type QueryQuestionnaireSetPropertiesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireSetPropertySort>>>;
  where?: InputMaybe<QuestionnaireSetPropertyWhere>;
};


export type QueryQuestionnaireStepsArgs = {
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QueryQuestionnaireStepsAggregateArgs = {
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QueryQuestionnaireStepsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireStepSort>>>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QueryQuestionnaireSurveysArgs = {
  options?: InputMaybe<QuestionnaireSurveyOptions>;
  where?: InputMaybe<QuestionnaireSurveyWhere>;
};


export type QueryQuestionnaireSurveysAggregateArgs = {
  where?: InputMaybe<QuestionnaireSurveyWhere>;
};


export type QueryQuestionnaireSurveysConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireSurveySort>>>;
  where?: InputMaybe<QuestionnaireSurveyWhere>;
};


export type QueryQuestionnaireThirdPartiesArgs = {
  options?: InputMaybe<QuestionnaireThirdPartyOptions>;
  where?: InputMaybe<QuestionnaireThirdPartyWhere>;
};


export type QueryQuestionnaireThirdPartiesAggregateArgs = {
  where?: InputMaybe<QuestionnaireThirdPartyWhere>;
};


export type QueryQuestionnaireThirdPartiesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireThirdPartySort>>>;
  where?: InputMaybe<QuestionnaireThirdPartyWhere>;
};


export type QueryQuestionnaireWelcomeStepsArgs = {
  options?: InputMaybe<QuestionnaireWelcomeStepOptions>;
  where?: InputMaybe<QuestionnaireWelcomeStepWhere>;
};


export type QueryQuestionnaireWelcomeStepsAggregateArgs = {
  where?: InputMaybe<QuestionnaireWelcomeStepWhere>;
};


export type QueryQuestionnaireWelcomeStepsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireWelcomeStepSort>>>;
  where?: InputMaybe<QuestionnaireWelcomeStepWhere>;
};


export type QueryQuestionnairesArgs = {
  fulltext?: InputMaybe<QuestionnaireFulltext>;
  options?: InputMaybe<QuestionnaireOptions>;
  where?: InputMaybe<QuestionnaireWhere>;
};


export type QueryQuestionnairesAggregateArgs = {
  fulltext?: InputMaybe<QuestionnaireFulltext>;
  where?: InputMaybe<QuestionnaireWhere>;
};


export type QueryQuestionnairesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fulltext?: InputMaybe<QuestionnaireFulltext>;
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireSort>>>;
  where?: InputMaybe<QuestionnaireWhere>;
};


export type QueryQuestionsArgs = {
  options?: InputMaybe<QuestionOptions>;
  where?: InputMaybe<QuestionWhere>;
};


export type QueryQuestionsAggregateArgs = {
  where?: InputMaybe<QuestionWhere>;
};


export type QueryQuestionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuestionSort>>>;
  where?: InputMaybe<QuestionWhere>;
};


export type QueryQuotingsArgs = {
  options?: InputMaybe<QuotingOptions>;
  where?: InputMaybe<QuotingWhere>;
};


export type QueryQuotingsAggregateArgs = {
  where?: InputMaybe<QuotingWhere>;
};


export type QueryQuotingsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<QuotingSort>>>;
  where?: InputMaybe<QuotingWhere>;
};


export type QueryRadioQuestionsArgs = {
  options?: InputMaybe<RadioQuestionOptions>;
  where?: InputMaybe<RadioQuestionWhere>;
};


export type QueryRadioQuestionsAggregateArgs = {
  where?: InputMaybe<RadioQuestionWhere>;
};


export type QueryRadioQuestionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<RadioQuestionSort>>>;
  where?: InputMaybe<RadioQuestionWhere>;
};


export type QueryRangeQuestionsArgs = {
  options?: InputMaybe<RangeQuestionOptions>;
  where?: InputMaybe<RangeQuestionWhere>;
};


export type QueryRangeQuestionsAggregateArgs = {
  where?: InputMaybe<RangeQuestionWhere>;
};


export type QueryRangeQuestionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<RangeQuestionSort>>>;
  where?: InputMaybe<RangeQuestionWhere>;
};


export type QuerySearchQuestionArgs = {
  term: Scalars['String']['input'];
};


export type QuerySearchQuestionResultsArgs = {
  options?: InputMaybe<SearchQuestionResultOptions>;
  where?: InputMaybe<SearchQuestionResultWhere>;
};


export type QuerySearchQuestionResultsAggregateArgs = {
  where?: InputMaybe<SearchQuestionResultWhere>;
};


export type QuerySearchQuestionResultsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<SearchQuestionResultSort>>>;
  where?: InputMaybe<SearchQuestionResultWhere>;
};


export type QuerySearchQuestionnaireArgs = {
  institutionId: Scalars['String']['input'];
  term: Scalars['String']['input'];
  workflowId?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySelectQuestionsArgs = {
  options?: InputMaybe<SelectQuestionOptions>;
  where?: InputMaybe<SelectQuestionWhere>;
};


export type QuerySelectQuestionsAggregateArgs = {
  where?: InputMaybe<SelectQuestionWhere>;
};


export type QuerySelectQuestionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<SelectQuestionSort>>>;
  where?: InputMaybe<SelectQuestionWhere>;
};


export type QuerySerializationNodesArgs = {
  options?: InputMaybe<SerializationNodeOptions>;
  where?: InputMaybe<SerializationNodeWhere>;
};


export type QuerySerializationNodesAggregateArgs = {
  where?: InputMaybe<SerializationNodeWhere>;
};


export type QuerySerializationNodesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<SerializationNodeSort>>>;
  where?: InputMaybe<SerializationNodeWhere>;
};


export type QuerySerializationSocketsArgs = {
  options?: InputMaybe<SerializationSocketOptions>;
  where?: InputMaybe<SerializationSocketWhere>;
};


export type QuerySerializationSocketsAggregateArgs = {
  where?: InputMaybe<SerializationSocketWhere>;
};


export type QuerySerializationSocketsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<SerializationSocketSort>>>;
  where?: InputMaybe<SerializationSocketWhere>;
};


export type QuerySpecialitiesArgs = {
  options?: InputMaybe<SpecialityOptions>;
  where?: InputMaybe<SpecialityWhere>;
};


export type QuerySpecialitiesAggregateArgs = {
  where?: InputMaybe<SpecialityWhere>;
};


export type QuerySpecialitiesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<SpecialitySort>>>;
  where?: InputMaybe<SpecialityWhere>;
};


export type QueryStatAnswersByWorkflowArgs = {
  aggregationFunction: Scalars['String']['input'];
  answerFilters?: InputMaybe<AnswerFiltersParams>;
  filterByDoctor?: InputMaybe<Scalars['Boolean']['input']>;
  from?: InputMaybe<Scalars['Date']['input']>;
  institutionId: Scalars['ID']['input'];
  to?: InputMaybe<Scalars['Date']['input']>;
  useAppointmentDate?: InputMaybe<Scalars['Boolean']['input']>;
  workflowId?: InputMaybe<Scalars['ID']['input']>;
  xUnit: Scalars['String']['input'];
  yUnit: Scalars['String']['input'];
};


export type QueryStatInterviewsByDoctorsArgs = {
  from?: InputMaybe<Scalars['Date']['input']>;
  opened?: InputMaybe<Scalars['Boolean']['input']>;
  to?: InputMaybe<Scalars['Date']['input']>;
  useAppointmentDate?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryStatInterviewsByLinkArgs = {
  filterByDoctor?: InputMaybe<Scalars['Boolean']['input']>;
  from?: InputMaybe<Scalars['Date']['input']>;
  institutionId: Scalars['ID']['input'];
  to?: InputMaybe<Scalars['Date']['input']>;
  useAppointmentDate?: InputMaybe<Scalars['Boolean']['input']>;
  workflowId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryStatInterviewsByWorkflowArgs = {
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  filterByDoctor?: InputMaybe<Scalars['Boolean']['input']>;
  from?: InputMaybe<Scalars['Date']['input']>;
  institutionId: Scalars['ID']['input'];
  to?: InputMaybe<Scalars['Date']['input']>;
  useAppointmentDate?: InputMaybe<Scalars['Boolean']['input']>;
  workflowId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryTextQuestionsArgs = {
  options?: InputMaybe<TextQuestionOptions>;
  where?: InputMaybe<TextQuestionWhere>;
};


export type QueryTextQuestionsAggregateArgs = {
  where?: InputMaybe<TextQuestionWhere>;
};


export type QueryTextQuestionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<TextQuestionSort>>>;
  where?: InputMaybe<TextQuestionWhere>;
};


export type QueryUnserializationResponsesArgs = {
  options?: InputMaybe<UnserializationResponseOptions>;
  where?: InputMaybe<UnserializationResponseWhere>;
};


export type QueryUnserializationResponsesAggregateArgs = {
  where?: InputMaybe<UnserializationResponseWhere>;
};


export type QueryUnserializationResponsesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<UnserializationResponseSort>>>;
  where?: InputMaybe<UnserializationResponseWhere>;
};


export type QueryUsersArgs = {
  options?: InputMaybe<UserOptions>;
  where?: InputMaybe<UserWhere>;
};


export type QueryUsersAggregateArgs = {
  where?: InputMaybe<UserWhere>;
};


export type QueryUsersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<UserSort>>>;
  where?: InputMaybe<UserWhere>;
};


export type QueryVersionnedGraphsArgs = {
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QueryVersionnedGraphsAggregateArgs = {
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QueryVersionnedGraphsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<VersionnedGraphSort>>>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QueryWorkflowFromDoctorArgs = {
  searchText: Scalars['String']['input'];
};


export type QueryWorkflowFromInstitutionArgs = {
  institutionId: Scalars['ID']['input'];
  searchText: Scalars['String']['input'];
  withTemplate?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryWorkflowLinksArgs = {
  options?: InputMaybe<WorkflowLinkOptions>;
  where?: InputMaybe<WorkflowLinkWhere>;
};


export type QueryWorkflowLinksAggregateArgs = {
  where?: InputMaybe<WorkflowLinkWhere>;
};


export type QueryWorkflowLinksConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<WorkflowLinkSort>>>;
  where?: InputMaybe<WorkflowLinkWhere>;
};


export type QueryWorkflowsArgs = {
  options?: InputMaybe<WorkflowOptions>;
  where?: InputMaybe<WorkflowWhere>;
};


export type QueryWorkflowsAggregateArgs = {
  where?: InputMaybe<WorkflowWhere>;
};


export type QueryWorkflowsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<WorkflowSort>>>;
  where?: InputMaybe<WorkflowWhere>;
};

/** Input type for options that can be specified on a query operation. */
export type QueryOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type Question = {
  alerts?: Maybe<AlertGroup>;
  alertsConnection: QuestionAlertsConnection;
  answers: Array<Answer>;
  answersConnection: QuestionAnswersConnection;
  cooldown?: Maybe<Cooldown>;
  field?: Maybe<Scalars['String']['output']>;
  graph: VersionnedGraph;
  graphConnection: QuestionnaireStepGraphConnection;
  hint?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type QuestionAlertsArgs = {
  options?: InputMaybe<AlertGroupOptions>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type QuestionAlertsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};


export type QuestionAnswersArgs = {
  options?: InputMaybe<AnswerOptions>;
  where?: InputMaybe<AnswerWhere>;
};


export type QuestionAnswersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionAnswersConnectionSort>>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};


export type QuestionGraphArgs = {
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionNextsArgs = {
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionPrevsArgs = {
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionAggregateSelection = {
  __typename?: 'QuestionAggregateSelection';
  count: Scalars['Int']['output'];
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  id: IdAggregateSelection;
  image: StringAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionAlertsAggregateInput = {
  AND?: InputMaybe<Array<QuestionAlertsAggregateInput>>;
  NOT?: InputMaybe<QuestionAlertsAggregateInput>;
  OR?: InputMaybe<Array<QuestionAlertsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionAlertsConnection = {
  __typename?: 'QuestionAlertsConnection';
  edges: Array<QuestionAlertsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionAlertsConnectionWhere = {
  AND?: InputMaybe<Array<QuestionAlertsConnectionWhere>>;
  NOT?: InputMaybe<QuestionAlertsConnectionWhere>;
  OR?: InputMaybe<Array<QuestionAlertsConnectionWhere>>;
  node?: InputMaybe<AlertGroupWhere>;
};

export type QuestionAlertsDeleteFieldInput = {
  delete?: InputMaybe<AlertGroupDeleteInput>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};

export type QuestionAlertsDisconnectFieldInput = {
  disconnect?: InputMaybe<AlertGroupDisconnectInput>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};

export type QuestionAlertsRelationship = {
  __typename?: 'QuestionAlertsRelationship';
  cursor: Scalars['String']['output'];
  node: AlertGroup;
};

export type QuestionAnswersAggregateInput = {
  AND?: InputMaybe<Array<QuestionAnswersAggregateInput>>;
  NOT?: InputMaybe<QuestionAnswersAggregateInput>;
  OR?: InputMaybe<Array<QuestionAnswersAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionAnswersNodeAggregationWhereInput>;
};

export type QuestionAnswersConnection = {
  __typename?: 'QuestionAnswersConnection';
  edges: Array<QuestionAnswersRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionAnswersConnectionSort = {
  node?: InputMaybe<AnswerSort>;
};

export type QuestionAnswersConnectionWhere = {
  AND?: InputMaybe<Array<QuestionAnswersConnectionWhere>>;
  NOT?: InputMaybe<QuestionAnswersConnectionWhere>;
  OR?: InputMaybe<Array<QuestionAnswersConnectionWhere>>;
  node?: InputMaybe<AnswerWhere>;
};

export type QuestionAnswersDeleteFieldInput = {
  delete?: InputMaybe<AnswerDeleteInput>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};

export type QuestionAnswersDisconnectFieldInput = {
  disconnect?: InputMaybe<AnswerDisconnectInput>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};

export type QuestionAnswersNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionAnswersNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionAnswersNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionAnswersNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  field_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  field_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  hint_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionAnswersRelationship = {
  __typename?: 'QuestionAnswersRelationship';
  cursor: Scalars['String']['output'];
  node: Answer;
};

export type QuestionEdge = {
  __typename?: 'QuestionEdge';
  cursor: Scalars['String']['output'];
  node: Question;
};

export type QuestionGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionGraphNodeAggregationWhereInput>;
};

export type QuestionGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export enum QuestionImplementation {
  CheckboxQuestion = 'CheckboxQuestion',
  DateQuestion = 'DateQuestion',
  RadioQuestion = 'RadioQuestion',
  RangeQuestion = 'RangeQuestion',
  SelectQuestion = 'SelectQuestion',
  TextQuestion = 'TextQuestion'
}

export type QuestionItem = {
  __typename?: 'QuestionItem';
  alert?: Maybe<AlertLevel>;
  id: Scalars['ID']['output'];
  label: Scalars['String']['output'];
  medicalLabel?: Maybe<Scalars['String']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  score?: Maybe<Scalars['Int']['output']>;
};

export type QuestionItemAggregateSelection = {
  __typename?: 'QuestionItemAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  label: StringAggregateSelection;
  medicalLabel: StringAggregateSelection;
  order: IntAggregateSelection;
  score: IntAggregateSelection;
};

export type QuestionItemConnectOrCreateWhere = {
  node: QuestionItemUniqueWhere;
};

export type QuestionItemConnectWhere = {
  node: QuestionItemWhere;
};

export type QuestionItemCreateInput = {
  alert?: InputMaybe<AlertLevel>;
  label: Scalars['String']['input'];
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  score?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionItemEdge = {
  __typename?: 'QuestionItemEdge';
  cursor: Scalars['String']['output'];
  node: QuestionItem;
};

export type QuestionItemInput = {
  alert?: InputMaybe<AlertLevel>;
  label: Scalars['String']['input'];
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  score?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionItemOnCreateInput = {
  alert?: InputMaybe<AlertLevel>;
  label: Scalars['String']['input'];
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  score?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionItemOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionItemSort objects to sort QuestionItems by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionItemSort>>;
};

/** Fields to sort QuestionItems by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionItemSort object. */
export type QuestionItemSort = {
  alert?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  label?: InputMaybe<SortDirection>;
  medicalLabel?: InputMaybe<SortDirection>;
  order?: InputMaybe<SortDirection>;
  score?: InputMaybe<SortDirection>;
};

export type QuestionItemUniqueWhere = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type QuestionItemUpdateInput = {
  alert?: InputMaybe<AlertLevel>;
  label?: InputMaybe<Scalars['String']['input']>;
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  order_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  order_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  score?: InputMaybe<Scalars['Int']['input']>;
  score_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  score_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionItemWhere = {
  AND?: InputMaybe<Array<QuestionItemWhere>>;
  NOT?: InputMaybe<QuestionItemWhere>;
  OR?: InputMaybe<Array<QuestionItemWhere>>;
  alert?: InputMaybe<AlertLevel>;
  alert_IN?: InputMaybe<Array<InputMaybe<AlertLevel>>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  label_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  label_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  label_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  label_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  medicalLabel_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  medicalLabel_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  medicalLabel_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  medicalLabel_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  order_GT?: InputMaybe<Scalars['Int']['input']>;
  order_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  order_LT?: InputMaybe<Scalars['Int']['input']>;
  order_LTE?: InputMaybe<Scalars['Int']['input']>;
  score?: InputMaybe<Scalars['Int']['input']>;
  score_GT?: InputMaybe<Scalars['Int']['input']>;
  score_GTE?: InputMaybe<Scalars['Int']['input']>;
  score_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  score_LT?: InputMaybe<Scalars['Int']['input']>;
  score_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionItemsConnection = {
  __typename?: 'QuestionItemsConnection';
  edges: Array<QuestionItemEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<QuestionNextsEdgeAggregationWhereInput>;
  node?: InputMaybe<QuestionNextsNodeAggregationWhereInput>;
};

export type QuestionNextsEdgeAggregationWhereInput = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   */
  Socket?: InputMaybe<SocketAggregationWhereInput>;
};

export type QuestionNextsEdgeSort = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   */
  Socket?: InputMaybe<SocketSort>;
};

export type QuestionNextsEdgeWhere = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   */
  Socket?: InputMaybe<SocketWhere>;
};

export type QuestionNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionSort objects to sort Questions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<InputMaybe<QuestionSort>>>;
};

export type QuestionPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<QuestionPrevsEdgeAggregationWhereInput>;
  node?: InputMaybe<QuestionPrevsNodeAggregationWhereInput>;
};

export type QuestionPrevsEdgeAggregationWhereInput = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   */
  Socket?: InputMaybe<SocketAggregationWhereInput>;
};

export type QuestionPrevsEdgeSort = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   */
  Socket?: InputMaybe<SocketSort>;
};

export type QuestionPrevsEdgeWhere = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   */
  Socket?: InputMaybe<SocketWhere>;
};

export type QuestionPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

/** Fields to sort Questions by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionSort object. */
export type QuestionSort = {
  field?: InputMaybe<SortDirection>;
  hint?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  image?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type QuestionWhere = {
  AND?: InputMaybe<Array<QuestionWhere>>;
  NOT?: InputMaybe<QuestionWhere>;
  OR?: InputMaybe<Array<QuestionWhere>>;
  alerts?: InputMaybe<AlertGroupWhere>;
  alertsAggregate?: InputMaybe<QuestionAlertsAggregateInput>;
  alertsConnection?: InputMaybe<QuestionAlertsConnectionWhere>;
  alertsConnection_NOT?: InputMaybe<QuestionAlertsConnectionWhere>;
  alerts_NOT?: InputMaybe<AlertGroupWhere>;
  answersAggregate?: InputMaybe<QuestionAnswersAggregateInput>;
  /** Return Questions where all of the related QuestionAnswersConnections match this filter */
  answersConnection_ALL?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return Questions where none of the related QuestionAnswersConnections match this filter */
  answersConnection_NONE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return Questions where one of the related QuestionAnswersConnections match this filter */
  answersConnection_SINGLE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return Questions where some of the related QuestionAnswersConnections match this filter */
  answersConnection_SOME?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return Questions where all of the related Answers match this filter */
  answers_ALL?: InputMaybe<AnswerWhere>;
  /** Return Questions where none of the related Answers match this filter */
  answers_NONE?: InputMaybe<AnswerWhere>;
  /** Return Questions where one of the related Answers match this filter */
  answers_SINGLE?: InputMaybe<AnswerWhere>;
  /** Return Questions where some of the related Answers match this filter */
  answers_SOME?: InputMaybe<AnswerWhere>;
  field?: InputMaybe<Scalars['String']['input']>;
  field_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  field_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  field_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  field_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  hint?: InputMaybe<Scalars['String']['input']>;
  hint_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  hint_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hint_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  image_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  image_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  image_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  image_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionNextsAggregateInput>;
  /** Return Questions where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return Questions where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return Questions where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return Questions where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return Questions where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return Questions where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return Questions where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return Questions where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionPrevsAggregateInput>;
  /** Return Questions where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return Questions where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return Questions where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return Questions where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return Questions where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return Questions where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return Questions where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return Questions where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  typename_IN?: InputMaybe<Array<QuestionImplementation>>;
};

export type Questionnaire = BaseQuestionnaire & {
  __typename?: 'Questionnaire';
  id: Scalars['ID']['output'];
  latest: VersionnedGraph;
  name: Scalars['String']['output'];
  nameNormalized: Scalars['String']['output'];
  owner?: Maybe<Owner>;
  ownerConnection: BaseQuestionnaireOwnerConnection;
  versions: Array<VersionnedGraph>;
  versionsAggregate?: Maybe<QuestionnaireVersionnedGraphVersionsAggregationSelection>;
  versionsConnection: BaseQuestionnaireVersionsConnection;
};


export type QuestionnaireOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QueryOptions>;
  where?: InputMaybe<OwnerWhere>;
};


export type QuestionnaireOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BaseQuestionnaireOwnerConnectionWhere>;
};


export type QuestionnaireVersionsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireVersionsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireVersionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<BaseQuestionnaireVersionsConnectionSort>>;
  where?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
};

export type QuestionnaireAggregateSelection = {
  __typename?: 'QuestionnaireAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type QuestionnaireAi = QuestionnaireStep & {
  __typename?: 'QuestionnaireAi';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireAiVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  maxQuestions?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireAiQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireAiQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
  prompt: Scalars['String']['output'];
};


export type QuestionnaireAiGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireAiGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireAiGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireAiNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireAiNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireAiNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireAiPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireAiPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireAiPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireAiAggregateSelection = {
  __typename?: 'QuestionnaireAiAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  maxQuestions: IntAggregateSelection;
  name: StringAggregateSelection;
  prompt: StringAggregateSelection;
};

export type QuestionnaireAiConnectInput = {
  graph?: InputMaybe<QuestionnaireAiGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireAiNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireAiPrevsConnectFieldInput>>;
};

export type QuestionnaireAiCreateInput = {
  graph?: InputMaybe<QuestionnaireAiGraphFieldInput>;
  maxQuestions?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireAiNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireAiPrevsFieldInput>;
  prompt: Scalars['String']['input'];
};

export type QuestionnaireAiDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireAiNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireAiPrevsDeleteFieldInput>>;
};

export type QuestionnaireAiDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireAiNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireAiPrevsDisconnectFieldInput>>;
};

export type QuestionnaireAiEdge = {
  __typename?: 'QuestionnaireAiEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireAi;
};

export type QuestionnaireAiGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireAiGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireAiGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireAiGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireAiGraphNodeAggregationWhereInput>;
};

export type QuestionnaireAiGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireAiGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireAiGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireAiGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireAiGraphCreateFieldInput>;
};

export type QuestionnaireAiGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireAiGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireAiGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireAiGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireAiGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireAiGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireAiGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireAiGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireAiGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireAiNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireAiNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireAiNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireAiNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireAiNextsNodeAggregationWhereInput>;
};

export type QuestionnaireAiNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireAiNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireAiNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireAiNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireAiNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireAiNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireAiNextsCreateFieldInput>>;
};

export type QuestionnaireAiNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireAiNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireAiNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireAiNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireAiNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireAiNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireAiNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireAiNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireAiNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireAiNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireAiNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireAiOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireAiSort objects to sort QuestionnaireAis by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireAiSort>>;
};

export type QuestionnaireAiPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireAiPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireAiPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireAiPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireAiPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireAiPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireAiPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireAiPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireAiPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireAiPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireAiPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireAiPrevsCreateFieldInput>>;
};

export type QuestionnaireAiPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireAiPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireAiPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireAiPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireAiPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireAiPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireAiPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireAiPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireAiPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireAiPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireAiPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireAiQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireAiQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireAiQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireAiQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireAiQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireAiQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireAiQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireAiQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireAiQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireAiQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireAiQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireAiQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireAiQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireAiQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireAiQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireAiQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireAiRelationInput = {
  graph?: InputMaybe<QuestionnaireAiGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireAiNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireAiPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireAis by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireAiSort object. */
export type QuestionnaireAiSort = {
  id?: InputMaybe<SortDirection>;
  maxQuestions?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  prompt?: InputMaybe<SortDirection>;
};

export type QuestionnaireAiUpdateInput = {
  graph?: InputMaybe<QuestionnaireAiGraphUpdateFieldInput>;
  maxQuestions?: InputMaybe<Scalars['Int']['input']>;
  maxQuestions_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  maxQuestions_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireAiNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireAiPrevsUpdateFieldInput>>;
  prompt?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireAiVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireAiVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireAiVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireAiVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireAiVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireAiWhere = {
  AND?: InputMaybe<Array<QuestionnaireAiWhere>>;
  NOT?: InputMaybe<QuestionnaireAiWhere>;
  OR?: InputMaybe<Array<QuestionnaireAiWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireAiGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  maxQuestions?: InputMaybe<Scalars['Int']['input']>;
  maxQuestions_GT?: InputMaybe<Scalars['Int']['input']>;
  maxQuestions_GTE?: InputMaybe<Scalars['Int']['input']>;
  maxQuestions_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  maxQuestions_LT?: InputMaybe<Scalars['Int']['input']>;
  maxQuestions_LTE?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireAiNextsAggregateInput>;
  /** Return QuestionnaireAis where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireAis where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireAis where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireAis where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireAis where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAis where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAis where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAis where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireAiPrevsAggregateInput>;
  /** Return QuestionnaireAis where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireAis where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireAis where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireAis where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireAis where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAis where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAis where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAis where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  prompt_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  prompt_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  prompt_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  prompt_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireAisConnection = {
  __typename?: 'QuestionnaireAisConnection';
  edges: Array<QuestionnaireAiEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireAlerts = {
  __typename?: 'QuestionnaireAlerts';
  alert: AlertLevel;
  questionnaire: BaseQuestionnaire;
};

export type QuestionnaireAlertsAggregateSelection = {
  __typename?: 'QuestionnaireAlertsAggregateSelection';
  count: Scalars['Int']['output'];
};

export type QuestionnaireAlertsConnection = {
  __typename?: 'QuestionnaireAlertsConnection';
  edges: Array<QuestionnaireAlertsEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireAlertsCreateInput = {
  alert: AlertLevel;
};

export type QuestionnaireAlertsEdge = {
  __typename?: 'QuestionnaireAlertsEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireAlerts;
};

export type QuestionnaireAlertsOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireAlertsSort objects to sort QuestionnaireAlerts by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireAlertsSort>>;
};

/** Fields to sort QuestionnaireAlerts by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireAlertsSort object. */
export type QuestionnaireAlertsSort = {
  alert?: InputMaybe<SortDirection>;
};

export type QuestionnaireAlertsUpdateInput = {
  alert?: InputMaybe<AlertLevel>;
};

export type QuestionnaireAlertsWhere = {
  AND?: InputMaybe<Array<QuestionnaireAlertsWhere>>;
  NOT?: InputMaybe<QuestionnaireAlertsWhere>;
  OR?: InputMaybe<Array<QuestionnaireAlertsWhere>>;
  alert?: InputMaybe<AlertLevel>;
  alert_IN?: InputMaybe<Array<AlertLevel>>;
};

export type QuestionnaireAppointmentDate = QuestionnaireStep & {
  __typename?: 'QuestionnaireAppointmentDate';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireAppointmentDateVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireAppointmentDateQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireAppointmentDateQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type QuestionnaireAppointmentDateGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireAppointmentDateGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireAppointmentDateGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireAppointmentDateNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireAppointmentDateNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireAppointmentDateNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireAppointmentDatePrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireAppointmentDatePrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireAppointmentDatePrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireAppointmentDateAggregateSelection = {
  __typename?: 'QuestionnaireAppointmentDateAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireAppointmentDateConnectInput = {
  graph?: InputMaybe<QuestionnaireAppointmentDateGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireAppointmentDateNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsConnectFieldInput>>;
};

export type QuestionnaireAppointmentDateCreateInput = {
  graph?: InputMaybe<QuestionnaireAppointmentDateGraphFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireAppointmentDateNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireAppointmentDatePrevsFieldInput>;
};

export type QuestionnaireAppointmentDateDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireAppointmentDateNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsDeleteFieldInput>>;
};

export type QuestionnaireAppointmentDateDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireAppointmentDateNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsDisconnectFieldInput>>;
};

export type QuestionnaireAppointmentDateEdge = {
  __typename?: 'QuestionnaireAppointmentDateEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireAppointmentDate;
};

export type QuestionnaireAppointmentDateGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireAppointmentDateGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireAppointmentDateGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireAppointmentDateGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireAppointmentDateGraphNodeAggregationWhereInput>;
};

export type QuestionnaireAppointmentDateGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireAppointmentDateGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireAppointmentDateGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireAppointmentDateGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireAppointmentDateGraphCreateFieldInput>;
};

export type QuestionnaireAppointmentDateGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireAppointmentDateGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireAppointmentDateGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireAppointmentDateGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireAppointmentDateGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireAppointmentDateGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireAppointmentDateGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireAppointmentDateGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireAppointmentDateGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireAppointmentDateNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireAppointmentDateNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireAppointmentDateNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireAppointmentDateNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireAppointmentDateNextsNodeAggregationWhereInput>;
};

export type QuestionnaireAppointmentDateNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireAppointmentDateNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireAppointmentDateNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireAppointmentDateNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireAppointmentDateNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireAppointmentDateNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireAppointmentDateNextsCreateFieldInput>>;
};

export type QuestionnaireAppointmentDateNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireAppointmentDateNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireAppointmentDateNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireAppointmentDateNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireAppointmentDateNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireAppointmentDateNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireAppointmentDateNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireAppointmentDateNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireAppointmentDateNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireAppointmentDateNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireAppointmentDateNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireAppointmentDateOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireAppointmentDateSort objects to sort QuestionnaireAppointmentDates by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireAppointmentDateSort>>;
};

export type QuestionnaireAppointmentDatePrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireAppointmentDatePrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireAppointmentDatePrevsNodeAggregationWhereInput>;
};

export type QuestionnaireAppointmentDatePrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireAppointmentDatePrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireAppointmentDatePrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireAppointmentDatePrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireAppointmentDatePrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsCreateFieldInput>>;
};

export type QuestionnaireAppointmentDatePrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireAppointmentDatePrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireAppointmentDatePrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireAppointmentDatePrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireAppointmentDatePrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireAppointmentDateQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireAppointmentDateQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireAppointmentDateQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireAppointmentDateQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireAppointmentDateQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireAppointmentDateQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireAppointmentDateQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireAppointmentDateQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireAppointmentDateQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireAppointmentDateQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireAppointmentDateQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireAppointmentDateQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireAppointmentDateQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireAppointmentDateQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireAppointmentDateQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireAppointmentDateQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireAppointmentDateRelationInput = {
  graph?: InputMaybe<QuestionnaireAppointmentDateGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireAppointmentDateNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireAppointmentDates by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireAppointmentDateSort object. */
export type QuestionnaireAppointmentDateSort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type QuestionnaireAppointmentDateUpdateInput = {
  graph?: InputMaybe<QuestionnaireAppointmentDateGraphUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireAppointmentDateNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireAppointmentDatePrevsUpdateFieldInput>>;
};

export type QuestionnaireAppointmentDateVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireAppointmentDateVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireAppointmentDateVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireAppointmentDateVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireAppointmentDateVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireAppointmentDateWhere = {
  AND?: InputMaybe<Array<QuestionnaireAppointmentDateWhere>>;
  NOT?: InputMaybe<QuestionnaireAppointmentDateWhere>;
  OR?: InputMaybe<Array<QuestionnaireAppointmentDateWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireAppointmentDateGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireAppointmentDateNextsAggregateInput>;
  /** Return QuestionnaireAppointmentDates where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireAppointmentDates where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireAppointmentDates where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireAppointmentDates where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireAppointmentDates where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAppointmentDates where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAppointmentDates where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAppointmentDates where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireAppointmentDatePrevsAggregateInput>;
  /** Return QuestionnaireAppointmentDates where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireAppointmentDates where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireAppointmentDates where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireAppointmentDates where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireAppointmentDates where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAppointmentDates where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAppointmentDates where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireAppointmentDates where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type QuestionnaireAppointmentDatesConnection = {
  __typename?: 'QuestionnaireAppointmentDatesConnection';
  edges: Array<QuestionnaireAppointmentDateEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireCondition = QuestionnaireStep & {
  __typename?: 'QuestionnaireCondition';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireConditionVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  hint?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireConditionQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireConditionQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
  showToDoctor?: Maybe<Scalars['Boolean']['output']>;
};


export type QuestionnaireConditionGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireConditionGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireConditionGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireConditionNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireConditionNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireConditionNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireConditionPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireConditionPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireConditionPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireConditionAggregateSelection = {
  __typename?: 'QuestionnaireConditionAggregateSelection';
  count: Scalars['Int']['output'];
  hint: StringAggregateSelection;
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireConditionConnectInput = {
  graph?: InputMaybe<QuestionnaireConditionGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireConditionNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireConditionPrevsConnectFieldInput>>;
};

export type QuestionnaireConditionCreateInput = {
  graph?: InputMaybe<QuestionnaireConditionGraphFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireConditionNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireConditionPrevsFieldInput>;
  showToDoctor?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuestionnaireConditionDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireConditionNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireConditionPrevsDeleteFieldInput>>;
};

export type QuestionnaireConditionDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireConditionNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireConditionPrevsDisconnectFieldInput>>;
};

export type QuestionnaireConditionEdge = {
  __typename?: 'QuestionnaireConditionEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireCondition;
};

export type QuestionnaireConditionGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireConditionGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireConditionGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireConditionGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireConditionGraphNodeAggregationWhereInput>;
};

export type QuestionnaireConditionGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireConditionGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireConditionGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireConditionGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireConditionGraphCreateFieldInput>;
};

export type QuestionnaireConditionGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireConditionGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireConditionGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireConditionGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireConditionGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireConditionGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireConditionGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireConditionGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireConditionGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireConditionNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireConditionNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireConditionNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireConditionNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireConditionNextsNodeAggregationWhereInput>;
};

export type QuestionnaireConditionNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireConditionNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireConditionNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireConditionNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireConditionNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireConditionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireConditionNextsCreateFieldInput>>;
};

export type QuestionnaireConditionNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireConditionNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireConditionNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireConditionNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireConditionNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireConditionNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireConditionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireConditionNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireConditionNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireConditionNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireConditionNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireConditionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireConditionSort objects to sort QuestionnaireConditions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireConditionSort>>;
};

export type QuestionnaireConditionPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireConditionPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireConditionPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireConditionPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireConditionPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireConditionPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireConditionPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireConditionPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireConditionPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireConditionPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireConditionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireConditionPrevsCreateFieldInput>>;
};

export type QuestionnaireConditionPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireConditionPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireConditionPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireConditionPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireConditionPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireConditionPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireConditionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireConditionPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireConditionPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireConditionPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireConditionPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireConditionQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireConditionQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireConditionQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireConditionQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireConditionQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireConditionQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireConditionQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireConditionQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireConditionQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireConditionQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireConditionQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireConditionQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireConditionQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireConditionQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireConditionQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireConditionQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireConditionRelationInput = {
  graph?: InputMaybe<QuestionnaireConditionGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireConditionNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireConditionPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireConditions by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireConditionSort object. */
export type QuestionnaireConditionSort = {
  hint?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  showToDoctor?: InputMaybe<SortDirection>;
};

export type QuestionnaireConditionUpdateInput = {
  graph?: InputMaybe<QuestionnaireConditionGraphUpdateFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireConditionNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireConditionPrevsUpdateFieldInput>>;
  showToDoctor?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuestionnaireConditionVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireConditionVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireConditionVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireConditionVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireConditionVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireConditionWhere = {
  AND?: InputMaybe<Array<QuestionnaireConditionWhere>>;
  NOT?: InputMaybe<QuestionnaireConditionWhere>;
  OR?: InputMaybe<Array<QuestionnaireConditionWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireConditionGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  hint?: InputMaybe<Scalars['String']['input']>;
  hint_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  hint_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hint_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireConditionNextsAggregateInput>;
  /** Return QuestionnaireConditions where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireConditions where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireConditions where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireConditions where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireConditions where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireConditions where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireConditions where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireConditions where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireConditionPrevsAggregateInput>;
  /** Return QuestionnaireConditions where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireConditions where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireConditions where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireConditions where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireConditions where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireConditions where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireConditions where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireConditions where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  showToDoctor?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuestionnaireConditionsConnection = {
  __typename?: 'QuestionnaireConditionsConnection';
  edges: Array<QuestionnaireConditionEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireConnectInput = {
  owner?: InputMaybe<QuestionnaireOwnerConnectInput>;
  versions?: InputMaybe<Array<QuestionnaireVersionsConnectFieldInput>>;
};

export type QuestionnaireConnectOrCreateInput = {
  owner?: InputMaybe<QuestionnaireOwnerConnectOrCreateInput>;
};

export type QuestionnaireConnectOrCreateWhere = {
  node: QuestionnaireUniqueWhere;
};

export type QuestionnaireConnectWhere = {
  node: QuestionnaireWhere;
};

export type QuestionnaireCreateInput = {
  name: Scalars['String']['input'];
  owner?: InputMaybe<QuestionnaireOwnerCreateInput>;
  versions?: InputMaybe<QuestionnaireVersionsFieldInput>;
};

export type QuestionnaireDeleteInput = {
  owner?: InputMaybe<QuestionnaireOwnerDeleteInput>;
  versions?: InputMaybe<Array<BaseQuestionnaireVersionsDeleteFieldInput>>;
};

export type QuestionnaireDisconnectInput = {
  owner?: InputMaybe<QuestionnaireOwnerDisconnectInput>;
  versions?: InputMaybe<Array<BaseQuestionnaireVersionsDisconnectFieldInput>>;
};

export type QuestionnaireDocument = QuestionnaireStep & {
  __typename?: 'QuestionnaireDocument';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireDocumentVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireDocumentQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireDocumentQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type QuestionnaireDocumentGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireDocumentGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireDocumentGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireDocumentNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireDocumentNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireDocumentNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireDocumentPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireDocumentPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireDocumentPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireDocumentAggregateSelection = {
  __typename?: 'QuestionnaireDocumentAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireDocumentConnectInput = {
  graph?: InputMaybe<QuestionnaireDocumentGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireDocumentNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireDocumentPrevsConnectFieldInput>>;
};

export type QuestionnaireDocumentCreateInput = {
  graph?: InputMaybe<QuestionnaireDocumentGraphFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireDocumentNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireDocumentPrevsFieldInput>;
};

export type QuestionnaireDocumentDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireDocumentNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireDocumentPrevsDeleteFieldInput>>;
};

export type QuestionnaireDocumentDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireDocumentNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireDocumentPrevsDisconnectFieldInput>>;
};

export type QuestionnaireDocumentEdge = {
  __typename?: 'QuestionnaireDocumentEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireDocument;
};

export type QuestionnaireDocumentFiller = QuestionnaireStep & {
  __typename?: 'QuestionnaireDocumentFiller';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireDocumentFillerVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  mapping?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireDocumentFillerQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  pdf?: Maybe<PdfDocument>;
  pdfAggregate?: Maybe<QuestionnaireDocumentFillerPdfDocumentPdfAggregationSelection>;
  pdfConnection: QuestionnaireDocumentFillerPdfConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireDocumentFillerQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type QuestionnaireDocumentFillerGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireDocumentFillerGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireDocumentFillerGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireDocumentFillerNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireDocumentFillerNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireDocumentFillerNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireDocumentFillerPdfArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<PdfDocumentOptions>;
  where?: InputMaybe<PdfDocumentWhere>;
};


export type QuestionnaireDocumentFillerPdfAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<PdfDocumentWhere>;
};


export type QuestionnaireDocumentFillerPdfConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireDocumentFillerPdfConnectionSort>>;
  where?: InputMaybe<QuestionnaireDocumentFillerPdfConnectionWhere>;
};


export type QuestionnaireDocumentFillerPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireDocumentFillerPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireDocumentFillerPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireDocumentFillerAggregateSelection = {
  __typename?: 'QuestionnaireDocumentFillerAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  mapping: StringAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireDocumentFillerConnectInput = {
  graph?: InputMaybe<QuestionnaireDocumentFillerGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireDocumentFillerNextsConnectFieldInput>>;
  pdf?: InputMaybe<QuestionnaireDocumentFillerPdfConnectFieldInput>;
  prevs?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsConnectFieldInput>>;
};

export type QuestionnaireDocumentFillerConnectOrCreateInput = {
  pdf?: InputMaybe<QuestionnaireDocumentFillerPdfConnectOrCreateFieldInput>;
};

export type QuestionnaireDocumentFillerCreateInput = {
  graph?: InputMaybe<QuestionnaireDocumentFillerGraphFieldInput>;
  mapping?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireDocumentFillerNextsFieldInput>;
  pdf?: InputMaybe<QuestionnaireDocumentFillerPdfFieldInput>;
  prevs?: InputMaybe<QuestionnaireDocumentFillerPrevsFieldInput>;
};

export type QuestionnaireDocumentFillerDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireDocumentFillerNextsDeleteFieldInput>>;
  pdf?: InputMaybe<QuestionnaireDocumentFillerPdfDeleteFieldInput>;
  prevs?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsDeleteFieldInput>>;
};

export type QuestionnaireDocumentFillerDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireDocumentFillerNextsDisconnectFieldInput>>;
  pdf?: InputMaybe<QuestionnaireDocumentFillerPdfDisconnectFieldInput>;
  prevs?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsDisconnectFieldInput>>;
};

export type QuestionnaireDocumentFillerEdge = {
  __typename?: 'QuestionnaireDocumentFillerEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireDocumentFiller;
};

export type QuestionnaireDocumentFillerGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentFillerGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentFillerGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentFillerGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireDocumentFillerGraphNodeAggregationWhereInput>;
};

export type QuestionnaireDocumentFillerGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireDocumentFillerGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireDocumentFillerGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireDocumentFillerGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireDocumentFillerGraphCreateFieldInput>;
};

export type QuestionnaireDocumentFillerGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentFillerGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentFillerGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentFillerGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireDocumentFillerGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireDocumentFillerGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireDocumentFillerGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireDocumentFillerGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireDocumentFillerGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireDocumentFillerNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentFillerNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentFillerNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentFillerNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireDocumentFillerNextsNodeAggregationWhereInput>;
};

export type QuestionnaireDocumentFillerNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireDocumentFillerNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireDocumentFillerNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireDocumentFillerNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireDocumentFillerNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireDocumentFillerNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireDocumentFillerNextsCreateFieldInput>>;
};

export type QuestionnaireDocumentFillerNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentFillerNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentFillerNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentFillerNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireDocumentFillerNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireDocumentFillerNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireDocumentFillerNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireDocumentFillerNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireDocumentFillerNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireDocumentFillerNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireDocumentFillerNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireDocumentFillerOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireDocumentFillerSort objects to sort QuestionnaireDocumentFillers by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireDocumentFillerSort>>;
};

export type QuestionnaireDocumentFillerPdfDocumentPdfAggregationSelection = {
  __typename?: 'QuestionnaireDocumentFillerPDFDocumentPdfAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireDocumentFillerPdfDocumentPdfNodeAggregateSelection>;
};

export type QuestionnaireDocumentFillerPdfDocumentPdfNodeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentFillerPDFDocumentPdfNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireDocumentFillerPdfAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentFillerPdfAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentFillerPdfAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentFillerPdfAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireDocumentFillerPdfNodeAggregationWhereInput>;
};

export type QuestionnaireDocumentFillerPdfConnectFieldInput = {
  connect?: InputMaybe<PdfDocumentConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<PdfDocumentConnectWhere>;
};

export type QuestionnaireDocumentFillerPdfConnectOrCreateFieldInput = {
  onCreate: QuestionnaireDocumentFillerPdfConnectOrCreateFieldInputOnCreate;
  where: PdfDocumentConnectOrCreateWhere;
};

export type QuestionnaireDocumentFillerPdfConnectOrCreateFieldInputOnCreate = {
  node: PdfDocumentOnCreateInput;
};

export type QuestionnaireDocumentFillerPdfConnection = {
  __typename?: 'QuestionnaireDocumentFillerPdfConnection';
  edges: Array<QuestionnaireDocumentFillerPdfRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireDocumentFillerPdfConnectionSort = {
  node?: InputMaybe<PdfDocumentSort>;
};

export type QuestionnaireDocumentFillerPdfConnectionWhere = {
  AND?: InputMaybe<Array<QuestionnaireDocumentFillerPdfConnectionWhere>>;
  NOT?: InputMaybe<QuestionnaireDocumentFillerPdfConnectionWhere>;
  OR?: InputMaybe<Array<QuestionnaireDocumentFillerPdfConnectionWhere>>;
  node?: InputMaybe<PdfDocumentWhere>;
};

export type QuestionnaireDocumentFillerPdfCreateFieldInput = {
  node: PdfDocumentCreateInput;
};

export type QuestionnaireDocumentFillerPdfDeleteFieldInput = {
  delete?: InputMaybe<PdfDocumentDeleteInput>;
  where?: InputMaybe<QuestionnaireDocumentFillerPdfConnectionWhere>;
};

export type QuestionnaireDocumentFillerPdfDisconnectFieldInput = {
  disconnect?: InputMaybe<PdfDocumentDisconnectInput>;
  where?: InputMaybe<QuestionnaireDocumentFillerPdfConnectionWhere>;
};

export type QuestionnaireDocumentFillerPdfFieldInput = {
  connect?: InputMaybe<QuestionnaireDocumentFillerPdfConnectFieldInput>;
  connectOrCreate?: InputMaybe<QuestionnaireDocumentFillerPdfConnectOrCreateFieldInput>;
  create?: InputMaybe<QuestionnaireDocumentFillerPdfCreateFieldInput>;
};

export type QuestionnaireDocumentFillerPdfNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentFillerPdfNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentFillerPdfNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentFillerPdfNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireDocumentFillerPdfRelationship = {
  __typename?: 'QuestionnaireDocumentFillerPdfRelationship';
  cursor: Scalars['String']['output'];
  node: PdfDocument;
};

export type QuestionnaireDocumentFillerPdfUpdateConnectionInput = {
  node?: InputMaybe<PdfDocumentUpdateInput>;
};

export type QuestionnaireDocumentFillerPdfUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireDocumentFillerPdfConnectFieldInput>;
  connectOrCreate?: InputMaybe<QuestionnaireDocumentFillerPdfConnectOrCreateFieldInput>;
  create?: InputMaybe<QuestionnaireDocumentFillerPdfCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireDocumentFillerPdfDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireDocumentFillerPdfDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireDocumentFillerPdfUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireDocumentFillerPdfConnectionWhere>;
};

export type QuestionnaireDocumentFillerPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentFillerPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireDocumentFillerPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireDocumentFillerPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireDocumentFillerPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireDocumentFillerPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireDocumentFillerPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireDocumentFillerPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsCreateFieldInput>>;
};

export type QuestionnaireDocumentFillerPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentFillerPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireDocumentFillerPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireDocumentFillerPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireDocumentFillerPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireDocumentFillerQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireDocumentFillerQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireDocumentFillerQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireDocumentFillerQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireDocumentFillerQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentFillerQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireDocumentFillerQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentFillerQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireDocumentFillerQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireDocumentFillerQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireDocumentFillerQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireDocumentFillerQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireDocumentFillerQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentFillerQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireDocumentFillerQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentFillerQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireDocumentFillerRelationInput = {
  graph?: InputMaybe<QuestionnaireDocumentFillerGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireDocumentFillerNextsCreateFieldInput>>;
  pdf?: InputMaybe<QuestionnaireDocumentFillerPdfCreateFieldInput>;
  prevs?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireDocumentFillers by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireDocumentFillerSort object. */
export type QuestionnaireDocumentFillerSort = {
  id?: InputMaybe<SortDirection>;
  mapping?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type QuestionnaireDocumentFillerUpdateInput = {
  graph?: InputMaybe<QuestionnaireDocumentFillerGraphUpdateFieldInput>;
  mapping?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireDocumentFillerNextsUpdateFieldInput>>;
  pdf?: InputMaybe<QuestionnaireDocumentFillerPdfUpdateFieldInput>;
  prevs?: InputMaybe<Array<QuestionnaireDocumentFillerPrevsUpdateFieldInput>>;
};

export type QuestionnaireDocumentFillerVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireDocumentFillerVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireDocumentFillerVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireDocumentFillerVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentFillerVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireDocumentFillerWhere = {
  AND?: InputMaybe<Array<QuestionnaireDocumentFillerWhere>>;
  NOT?: InputMaybe<QuestionnaireDocumentFillerWhere>;
  OR?: InputMaybe<Array<QuestionnaireDocumentFillerWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireDocumentFillerGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  mapping?: InputMaybe<Scalars['String']['input']>;
  mapping_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  mapping_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  mapping_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  mapping_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireDocumentFillerNextsAggregateInput>;
  /** Return QuestionnaireDocumentFillers where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireDocumentFillers where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireDocumentFillers where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireDocumentFillers where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireDocumentFillers where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocumentFillers where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocumentFillers where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocumentFillers where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  pdf?: InputMaybe<PdfDocumentWhere>;
  pdfAggregate?: InputMaybe<QuestionnaireDocumentFillerPdfAggregateInput>;
  pdfConnection?: InputMaybe<QuestionnaireDocumentFillerPdfConnectionWhere>;
  pdfConnection_NOT?: InputMaybe<QuestionnaireDocumentFillerPdfConnectionWhere>;
  pdf_NOT?: InputMaybe<PdfDocumentWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireDocumentFillerPrevsAggregateInput>;
  /** Return QuestionnaireDocumentFillers where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireDocumentFillers where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireDocumentFillers where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireDocumentFillers where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireDocumentFillers where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocumentFillers where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocumentFillers where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocumentFillers where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type QuestionnaireDocumentFillersConnection = {
  __typename?: 'QuestionnaireDocumentFillersConnection';
  edges: Array<QuestionnaireDocumentFillerEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireDocumentGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireDocumentGraphNodeAggregationWhereInput>;
};

export type QuestionnaireDocumentGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireDocumentGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireDocumentGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireDocumentGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireDocumentGraphCreateFieldInput>;
};

export type QuestionnaireDocumentGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireDocumentGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireDocumentGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireDocumentGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireDocumentGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireDocumentGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireDocumentNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireDocumentNextsNodeAggregationWhereInput>;
};

export type QuestionnaireDocumentNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireDocumentNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireDocumentNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireDocumentNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireDocumentNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireDocumentNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireDocumentNextsCreateFieldInput>>;
};

export type QuestionnaireDocumentNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireDocumentNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireDocumentNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireDocumentNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireDocumentNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireDocumentNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireDocumentNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireDocumentNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireDocumentOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireDocumentSort objects to sort QuestionnaireDocuments by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireDocumentSort>>;
};

export type QuestionnaireDocumentPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireDocumentPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireDocumentPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireDocumentPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireDocumentPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireDocumentPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireDocumentPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireDocumentPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireDocumentPrevsCreateFieldInput>>;
};

export type QuestionnaireDocumentPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireDocumentPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireDocumentPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireDocumentPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireDocumentPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireDocumentPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireDocumentPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireDocumentPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireDocumentPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireDocumentPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireDocumentPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireDocumentQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireDocumentQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireDocumentQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireDocumentQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireDocumentQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireDocumentQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireDocumentQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireDocumentQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireDocumentQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireDocumentQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireDocumentQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireDocumentQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireDocumentRelationInput = {
  graph?: InputMaybe<QuestionnaireDocumentGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireDocumentNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireDocumentPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireDocuments by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireDocumentSort object. */
export type QuestionnaireDocumentSort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type QuestionnaireDocumentUpdateInput = {
  graph?: InputMaybe<QuestionnaireDocumentGraphUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireDocumentNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireDocumentPrevsUpdateFieldInput>>;
};

export type QuestionnaireDocumentVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireDocumentVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireDocumentVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireDocumentVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireDocumentVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireDocumentWhere = {
  AND?: InputMaybe<Array<QuestionnaireDocumentWhere>>;
  NOT?: InputMaybe<QuestionnaireDocumentWhere>;
  OR?: InputMaybe<Array<QuestionnaireDocumentWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireDocumentGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireDocumentNextsAggregateInput>;
  /** Return QuestionnaireDocuments where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireDocuments where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireDocuments where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireDocuments where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireDocuments where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocuments where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocuments where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocuments where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireDocumentPrevsAggregateInput>;
  /** Return QuestionnaireDocuments where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireDocuments where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireDocuments where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireDocuments where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireDocuments where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocuments where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocuments where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireDocuments where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type QuestionnaireDocumentsConnection = {
  __typename?: 'QuestionnaireDocumentsConnection';
  edges: Array<QuestionnaireDocumentEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireEdge = {
  __typename?: 'QuestionnaireEdge';
  cursor: Scalars['String']['output'];
  node: Questionnaire;
};

export type QuestionnaireFulltext = {
  QuestionnaireAutocomplete?: InputMaybe<QuestionnaireQuestionnaireAutocompleteFulltext>;
};

/** The result of a fulltext search on an index of Questionnaire */
export type QuestionnaireFulltextResult = {
  __typename?: 'QuestionnaireFulltextResult';
  questionnaire: Questionnaire;
  score: Scalars['Float']['output'];
};

/** The input for sorting a fulltext query on an index of Questionnaire */
export type QuestionnaireFulltextSort = {
  questionnaire?: InputMaybe<QuestionnaireSort>;
  score?: InputMaybe<SortDirection>;
};

/** The input for filtering a fulltext query on an index of Questionnaire */
export type QuestionnaireFulltextWhere = {
  questionnaire?: InputMaybe<QuestionnaireWhere>;
  score?: InputMaybe<FloatWhere>;
};

export type QuestionnaireIdentitiesConnection = {
  __typename?: 'QuestionnaireIdentitiesConnection';
  edges: Array<QuestionnaireIdentityEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireIdentity = QuestionnaireStep & {
  __typename?: 'QuestionnaireIdentity';
  fields?: Maybe<Array<IdentityField>>;
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireIdentityVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireIdentityQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireIdentityQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
  withAuthentication?: Maybe<Scalars['Boolean']['output']>;
};


export type QuestionnaireIdentityGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireIdentityGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireIdentityGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireIdentityNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireIdentityNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireIdentityNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireIdentityPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireIdentityPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireIdentityPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireIdentityAggregateSelection = {
  __typename?: 'QuestionnaireIdentityAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireIdentityConnectInput = {
  graph?: InputMaybe<QuestionnaireIdentityGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireIdentityNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireIdentityPrevsConnectFieldInput>>;
};

export type QuestionnaireIdentityCreateInput = {
  fields?: InputMaybe<Array<IdentityField>>;
  graph?: InputMaybe<QuestionnaireIdentityGraphFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireIdentityNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireIdentityPrevsFieldInput>;
  withAuthentication?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuestionnaireIdentityDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireIdentityNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireIdentityPrevsDeleteFieldInput>>;
};

export type QuestionnaireIdentityDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireIdentityNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireIdentityPrevsDisconnectFieldInput>>;
};

export type QuestionnaireIdentityEdge = {
  __typename?: 'QuestionnaireIdentityEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireIdentity;
};

export type QuestionnaireIdentityGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireIdentityGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireIdentityGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireIdentityGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireIdentityGraphNodeAggregationWhereInput>;
};

export type QuestionnaireIdentityGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireIdentityGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireIdentityGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireIdentityGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireIdentityGraphCreateFieldInput>;
};

export type QuestionnaireIdentityGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireIdentityGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireIdentityGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireIdentityGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireIdentityGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireIdentityGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireIdentityGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireIdentityGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireIdentityGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireIdentityNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireIdentityNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireIdentityNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireIdentityNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireIdentityNextsNodeAggregationWhereInput>;
};

export type QuestionnaireIdentityNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireIdentityNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireIdentityNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireIdentityNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireIdentityNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireIdentityNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireIdentityNextsCreateFieldInput>>;
};

export type QuestionnaireIdentityNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireIdentityNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireIdentityNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireIdentityNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireIdentityNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireIdentityNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireIdentityNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireIdentityNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireIdentityNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireIdentityNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireIdentityNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireIdentityOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireIdentitySort objects to sort QuestionnaireIdentities by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireIdentitySort>>;
};

export type QuestionnaireIdentityPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireIdentityPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireIdentityPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireIdentityPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireIdentityPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireIdentityPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireIdentityPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireIdentityPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireIdentityPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireIdentityPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireIdentityPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireIdentityPrevsCreateFieldInput>>;
};

export type QuestionnaireIdentityPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireIdentityPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireIdentityPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireIdentityPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireIdentityPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireIdentityPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireIdentityPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireIdentityPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireIdentityPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireIdentityPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireIdentityPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireIdentityQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireIdentityQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireIdentityQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireIdentityQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireIdentityQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireIdentityQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireIdentityQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireIdentityQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireIdentityQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireIdentityQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireIdentityQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireIdentityQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireIdentityQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireIdentityQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireIdentityQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireIdentityQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireIdentityRelationInput = {
  graph?: InputMaybe<QuestionnaireIdentityGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireIdentityNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireIdentityPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireIdentities by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireIdentitySort object. */
export type QuestionnaireIdentitySort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  withAuthentication?: InputMaybe<SortDirection>;
};

export type QuestionnaireIdentityUpdateInput = {
  fields?: InputMaybe<Array<IdentityField>>;
  graph?: InputMaybe<QuestionnaireIdentityGraphUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireIdentityNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireIdentityPrevsUpdateFieldInput>>;
  withAuthentication?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuestionnaireIdentityVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireIdentityVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireIdentityVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireIdentityVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireIdentityVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireIdentityWhere = {
  AND?: InputMaybe<Array<QuestionnaireIdentityWhere>>;
  NOT?: InputMaybe<QuestionnaireIdentityWhere>;
  OR?: InputMaybe<Array<QuestionnaireIdentityWhere>>;
  fields?: InputMaybe<Array<IdentityField>>;
  fields_INCLUDES?: InputMaybe<IdentityField>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireIdentityGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireIdentityNextsAggregateInput>;
  /** Return QuestionnaireIdentities where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireIdentities where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireIdentities where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireIdentities where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireIdentities where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireIdentities where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireIdentities where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireIdentities where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireIdentityPrevsAggregateInput>;
  /** Return QuestionnaireIdentities where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireIdentities where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireIdentities where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireIdentities where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireIdentities where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireIdentities where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireIdentities where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireIdentities where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  withAuthentication?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuestionnaireInfoStep = QuestionnaireStep & {
  __typename?: 'QuestionnaireInfoStep';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireInfoStepVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireInfoStepQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireInfoStepQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
  showReceiveByEmail?: Maybe<Scalars['Boolean']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};


export type QuestionnaireInfoStepGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireInfoStepGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireInfoStepGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireInfoStepNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireInfoStepNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireInfoStepNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireInfoStepPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireInfoStepPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireInfoStepPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireInfoStepAggregateSelection = {
  __typename?: 'QuestionnaireInfoStepAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  text: StringAggregateSelection;
};

export type QuestionnaireInfoStepConnectInput = {
  graph?: InputMaybe<QuestionnaireInfoStepGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireInfoStepNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireInfoStepPrevsConnectFieldInput>>;
};

export type QuestionnaireInfoStepCreateInput = {
  graph?: InputMaybe<QuestionnaireInfoStepGraphFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireInfoStepNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireInfoStepPrevsFieldInput>;
  showReceiveByEmail?: InputMaybe<Scalars['Boolean']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireInfoStepDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireInfoStepNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireInfoStepPrevsDeleteFieldInput>>;
};

export type QuestionnaireInfoStepDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireInfoStepNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireInfoStepPrevsDisconnectFieldInput>>;
};

export type QuestionnaireInfoStepEdge = {
  __typename?: 'QuestionnaireInfoStepEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireInfoStep;
};

export type QuestionnaireInfoStepGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireInfoStepGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireInfoStepGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireInfoStepGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireInfoStepGraphNodeAggregationWhereInput>;
};

export type QuestionnaireInfoStepGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireInfoStepGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireInfoStepGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireInfoStepGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireInfoStepGraphCreateFieldInput>;
};

export type QuestionnaireInfoStepGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireInfoStepGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireInfoStepGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireInfoStepGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireInfoStepGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireInfoStepGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireInfoStepGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireInfoStepGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireInfoStepGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireInfoStepNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireInfoStepNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireInfoStepNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireInfoStepNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireInfoStepNextsNodeAggregationWhereInput>;
};

export type QuestionnaireInfoStepNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireInfoStepNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireInfoStepNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireInfoStepNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireInfoStepNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireInfoStepNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireInfoStepNextsCreateFieldInput>>;
};

export type QuestionnaireInfoStepNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireInfoStepNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireInfoStepNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireInfoStepNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireInfoStepNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireInfoStepNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireInfoStepNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireInfoStepNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireInfoStepNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireInfoStepNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireInfoStepNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireInfoStepOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireInfoStepSort objects to sort QuestionnaireInfoSteps by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireInfoStepSort>>;
};

export type QuestionnaireInfoStepPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireInfoStepPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireInfoStepPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireInfoStepPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireInfoStepPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireInfoStepPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireInfoStepPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireInfoStepPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireInfoStepPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireInfoStepPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireInfoStepPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireInfoStepPrevsCreateFieldInput>>;
};

export type QuestionnaireInfoStepPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireInfoStepPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireInfoStepPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireInfoStepPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireInfoStepPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireInfoStepPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireInfoStepPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireInfoStepPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireInfoStepPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireInfoStepPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireInfoStepPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireInfoStepQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireInfoStepQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireInfoStepQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireInfoStepQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireInfoStepQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireInfoStepQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireInfoStepQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireInfoStepQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireInfoStepQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireInfoStepQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireInfoStepQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireInfoStepQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireInfoStepQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireInfoStepQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireInfoStepQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireInfoStepQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireInfoStepRelationInput = {
  graph?: InputMaybe<QuestionnaireInfoStepGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireInfoStepNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireInfoStepPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireInfoSteps by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireInfoStepSort object. */
export type QuestionnaireInfoStepSort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  showReceiveByEmail?: InputMaybe<SortDirection>;
  text?: InputMaybe<SortDirection>;
};

export type QuestionnaireInfoStepUpdateInput = {
  graph?: InputMaybe<QuestionnaireInfoStepGraphUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireInfoStepNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireInfoStepPrevsUpdateFieldInput>>;
  showReceiveByEmail?: InputMaybe<Scalars['Boolean']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireInfoStepVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireInfoStepVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireInfoStepVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireInfoStepVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireInfoStepVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireInfoStepWhere = {
  AND?: InputMaybe<Array<QuestionnaireInfoStepWhere>>;
  NOT?: InputMaybe<QuestionnaireInfoStepWhere>;
  OR?: InputMaybe<Array<QuestionnaireInfoStepWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireInfoStepGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireInfoStepNextsAggregateInput>;
  /** Return QuestionnaireInfoSteps where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireInfoSteps where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireInfoSteps where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireInfoSteps where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireInfoSteps where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInfoSteps where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInfoSteps where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInfoSteps where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireInfoStepPrevsAggregateInput>;
  /** Return QuestionnaireInfoSteps where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireInfoSteps where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireInfoSteps where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireInfoSteps where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireInfoSteps where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInfoSteps where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInfoSteps where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInfoSteps where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  showReceiveByEmail?: InputMaybe<Scalars['Boolean']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  text_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  text_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  text_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  text_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireInfoStepsConnection = {
  __typename?: 'QuestionnaireInfoStepsConnection';
  edges: Array<QuestionnaireInfoStepEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireInterview = QuestionnaireStep & {
  __typename?: 'QuestionnaireInterview';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireInterviewVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  isExportQuestionnaireNameVisible?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireInterviewQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireInterviewQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
  questionnaire?: Maybe<Questionnaire>;
  questionnaireAggregate?: Maybe<QuestionnaireInterviewQuestionnaireQuestionnaireAggregationSelection>;
  questionnaireConnection: QuestionnaireInterviewQuestionnaireConnection;
};


export type QuestionnaireInterviewGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireInterviewGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireInterviewGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireInterviewNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireInterviewNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireInterviewNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireInterviewPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireInterviewPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireInterviewPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};


export type QuestionnaireInterviewQuestionnaireArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireOptions>;
  where?: InputMaybe<QuestionnaireWhere>;
};


export type QuestionnaireInterviewQuestionnaireAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireWhere>;
};


export type QuestionnaireInterviewQuestionnaireConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireInterviewQuestionnaireConnectionSort>>;
  where?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectionWhere>;
};

export type QuestionnaireInterviewAggregateSelection = {
  __typename?: 'QuestionnaireInterviewAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireInterviewConnectInput = {
  graph?: InputMaybe<QuestionnaireInterviewGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireInterviewNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireInterviewPrevsConnectFieldInput>>;
  questionnaire?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectFieldInput>;
};

export type QuestionnaireInterviewConnectOrCreateInput = {
  questionnaire?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectOrCreateFieldInput>;
};

export type QuestionnaireInterviewCreateInput = {
  graph?: InputMaybe<QuestionnaireInterviewGraphFieldInput>;
  isExportQuestionnaireNameVisible?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireInterviewNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireInterviewPrevsFieldInput>;
  questionnaire?: InputMaybe<QuestionnaireInterviewQuestionnaireFieldInput>;
};

export type QuestionnaireInterviewDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireInterviewNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireInterviewPrevsDeleteFieldInput>>;
  questionnaire?: InputMaybe<QuestionnaireInterviewQuestionnaireDeleteFieldInput>;
};

export type QuestionnaireInterviewDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireInterviewNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireInterviewPrevsDisconnectFieldInput>>;
  questionnaire?: InputMaybe<QuestionnaireInterviewQuestionnaireDisconnectFieldInput>;
};

export type QuestionnaireInterviewEdge = {
  __typename?: 'QuestionnaireInterviewEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireInterview;
};

export type QuestionnaireInterviewGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireInterviewGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireInterviewGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireInterviewGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireInterviewGraphNodeAggregationWhereInput>;
};

export type QuestionnaireInterviewGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireInterviewGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireInterviewGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireInterviewGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireInterviewGraphCreateFieldInput>;
};

export type QuestionnaireInterviewGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireInterviewGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireInterviewGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireInterviewGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireInterviewGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireInterviewGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireInterviewGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireInterviewGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireInterviewGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireInterviewNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireInterviewNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireInterviewNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireInterviewNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireInterviewNextsNodeAggregationWhereInput>;
};

export type QuestionnaireInterviewNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireInterviewNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireInterviewNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireInterviewNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireInterviewNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireInterviewNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireInterviewNextsCreateFieldInput>>;
};

export type QuestionnaireInterviewNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireInterviewNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireInterviewNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireInterviewNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireInterviewNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireInterviewNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireInterviewNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireInterviewNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireInterviewNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireInterviewNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireInterviewNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireInterviewOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireInterviewSort objects to sort QuestionnaireInterviews by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireInterviewSort>>;
};

export type QuestionnaireInterviewPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireInterviewPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireInterviewPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireInterviewPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireInterviewPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireInterviewPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireInterviewPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireInterviewPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireInterviewPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireInterviewPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireInterviewPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireInterviewPrevsCreateFieldInput>>;
};

export type QuestionnaireInterviewPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireInterviewPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireInterviewPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireInterviewPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireInterviewPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireInterviewPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireInterviewPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireInterviewPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireInterviewPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireInterviewPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireInterviewPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireInterviewQuestionnaireAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireInterviewQuestionnaireAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireInterviewQuestionnaireAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireInterviewQuestionnaireAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireInterviewQuestionnaireNodeAggregationWhereInput>;
};

export type QuestionnaireInterviewQuestionnaireConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<QuestionnaireConnectWhere>;
};

export type QuestionnaireInterviewQuestionnaireConnectOrCreateFieldInput = {
  onCreate: QuestionnaireInterviewQuestionnaireConnectOrCreateFieldInputOnCreate;
  where: QuestionnaireConnectOrCreateWhere;
};

export type QuestionnaireInterviewQuestionnaireConnectOrCreateFieldInputOnCreate = {
  node: QuestionnaireOnCreateInput;
};

export type QuestionnaireInterviewQuestionnaireConnection = {
  __typename?: 'QuestionnaireInterviewQuestionnaireConnection';
  edges: Array<QuestionnaireInterviewQuestionnaireRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireInterviewQuestionnaireConnectionSort = {
  node?: InputMaybe<QuestionnaireSort>;
};

export type QuestionnaireInterviewQuestionnaireConnectionWhere = {
  AND?: InputMaybe<Array<QuestionnaireInterviewQuestionnaireConnectionWhere>>;
  NOT?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectionWhere>;
  OR?: InputMaybe<Array<QuestionnaireInterviewQuestionnaireConnectionWhere>>;
  node?: InputMaybe<QuestionnaireWhere>;
};

export type QuestionnaireInterviewQuestionnaireCreateFieldInput = {
  node: QuestionnaireCreateInput;
};

export type QuestionnaireInterviewQuestionnaireDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireDeleteInput>;
  where?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectionWhere>;
};

export type QuestionnaireInterviewQuestionnaireDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireDisconnectInput>;
  where?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectionWhere>;
};

export type QuestionnaireInterviewQuestionnaireFieldInput = {
  connect?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectFieldInput>;
  connectOrCreate?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectOrCreateFieldInput>;
  create?: InputMaybe<QuestionnaireInterviewQuestionnaireCreateFieldInput>;
};

export type QuestionnaireInterviewQuestionnaireNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireInterviewQuestionnaireNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireInterviewQuestionnaireNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireInterviewQuestionnaireNodeAggregationWhereInput>>;
  nameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireInterviewQuestionnaireQuestionnaireAggregationSelection = {
  __typename?: 'QuestionnaireInterviewQuestionnaireQuestionnaireAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireInterviewQuestionnaireQuestionnaireNodeAggregateSelection>;
};

export type QuestionnaireInterviewQuestionnaireQuestionnaireNodeAggregateSelection = {
  __typename?: 'QuestionnaireInterviewQuestionnaireQuestionnaireNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type QuestionnaireInterviewQuestionnaireRelationship = {
  __typename?: 'QuestionnaireInterviewQuestionnaireRelationship';
  cursor: Scalars['String']['output'];
  node: Questionnaire;
};

export type QuestionnaireInterviewQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireInterviewQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireInterviewQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireInterviewQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireInterviewQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireInterviewQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireInterviewQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireInterviewQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireInterviewQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireInterviewQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireInterviewQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireInterviewQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireInterviewQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireInterviewQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireInterviewQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireInterviewQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireInterviewQuestionnaireUpdateConnectionInput = {
  node?: InputMaybe<QuestionnaireUpdateInput>;
};

export type QuestionnaireInterviewQuestionnaireUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectFieldInput>;
  connectOrCreate?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectOrCreateFieldInput>;
  create?: InputMaybe<QuestionnaireInterviewQuestionnaireCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireInterviewQuestionnaireDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireInterviewQuestionnaireDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireInterviewQuestionnaireUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectionWhere>;
};

export type QuestionnaireInterviewRelationInput = {
  graph?: InputMaybe<QuestionnaireInterviewGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireInterviewNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireInterviewPrevsCreateFieldInput>>;
  questionnaire?: InputMaybe<QuestionnaireInterviewQuestionnaireCreateFieldInput>;
};

/** Fields to sort QuestionnaireInterviews by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireInterviewSort object. */
export type QuestionnaireInterviewSort = {
  id?: InputMaybe<SortDirection>;
  isExportQuestionnaireNameVisible?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type QuestionnaireInterviewUpdateInput = {
  graph?: InputMaybe<QuestionnaireInterviewGraphUpdateFieldInput>;
  isExportQuestionnaireNameVisible?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireInterviewNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireInterviewPrevsUpdateFieldInput>>;
  questionnaire?: InputMaybe<QuestionnaireInterviewQuestionnaireUpdateFieldInput>;
};

export type QuestionnaireInterviewVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireInterviewVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireInterviewVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireInterviewVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireInterviewVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireInterviewWhere = {
  AND?: InputMaybe<Array<QuestionnaireInterviewWhere>>;
  NOT?: InputMaybe<QuestionnaireInterviewWhere>;
  OR?: InputMaybe<Array<QuestionnaireInterviewWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireInterviewGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  isExportQuestionnaireNameVisible?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireInterviewNextsAggregateInput>;
  /** Return QuestionnaireInterviews where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireInterviews where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireInterviews where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireInterviews where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireInterviews where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInterviews where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInterviews where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInterviews where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireInterviewPrevsAggregateInput>;
  /** Return QuestionnaireInterviews where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireInterviews where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireInterviews where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireInterviews where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireInterviews where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInterviews where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInterviews where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireInterviews where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  questionnaire?: InputMaybe<QuestionnaireWhere>;
  questionnaireAggregate?: InputMaybe<QuestionnaireInterviewQuestionnaireAggregateInput>;
  questionnaireConnection?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectionWhere>;
  questionnaireConnection_NOT?: InputMaybe<QuestionnaireInterviewQuestionnaireConnectionWhere>;
  questionnaire_NOT?: InputMaybe<QuestionnaireWhere>;
};

export type QuestionnaireInterviewsConnection = {
  __typename?: 'QuestionnaireInterviewsConnection';
  edges: Array<QuestionnaireInterviewEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireMenu = QuestionnaireStep & {
  __typename?: 'QuestionnaireMenu';
  choices: Array<QuestionnaireMenuItem>;
  choicesAggregate?: Maybe<QuestionnaireMenuQuestionnaireMenuItemChoicesAggregationSelection>;
  choicesConnection: QuestionnaireMenuChoicesConnection;
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireMenuVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  medicalLabel?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireMenuQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireMenuQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
  showToDoctor?: Maybe<Scalars['Boolean']['output']>;
};


export type QuestionnaireMenuChoicesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireMenuItemOptions>;
  where?: InputMaybe<QuestionnaireMenuItemWhere>;
};


export type QuestionnaireMenuChoicesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireMenuItemWhere>;
};


export type QuestionnaireMenuChoicesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireMenuChoicesConnectionSort>>;
  where?: InputMaybe<QuestionnaireMenuChoicesConnectionWhere>;
};


export type QuestionnaireMenuGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireMenuGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireMenuGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireMenuNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireMenuNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireMenuNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireMenuPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireMenuPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireMenuPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireMenuAggregateSelection = {
  __typename?: 'QuestionnaireMenuAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  medicalLabel: StringAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireMenuChoicesAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireMenuChoicesAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireMenuChoicesAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireMenuChoicesAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireMenuChoicesNodeAggregationWhereInput>;
};

export type QuestionnaireMenuChoicesConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<QuestionnaireMenuItemConnectWhere>;
};

export type QuestionnaireMenuChoicesConnection = {
  __typename?: 'QuestionnaireMenuChoicesConnection';
  edges: Array<QuestionnaireMenuChoicesRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireMenuChoicesConnectionSort = {
  node?: InputMaybe<QuestionnaireMenuItemSort>;
};

export type QuestionnaireMenuChoicesConnectionWhere = {
  AND?: InputMaybe<Array<QuestionnaireMenuChoicesConnectionWhere>>;
  NOT?: InputMaybe<QuestionnaireMenuChoicesConnectionWhere>;
  OR?: InputMaybe<Array<QuestionnaireMenuChoicesConnectionWhere>>;
  node?: InputMaybe<QuestionnaireMenuItemWhere>;
};

export type QuestionnaireMenuChoicesCreateFieldInput = {
  node: QuestionnaireMenuItemCreateInput;
};

export type QuestionnaireMenuChoicesDeleteFieldInput = {
  where?: InputMaybe<QuestionnaireMenuChoicesConnectionWhere>;
};

export type QuestionnaireMenuChoicesDisconnectFieldInput = {
  where?: InputMaybe<QuestionnaireMenuChoicesConnectionWhere>;
};

export type QuestionnaireMenuChoicesFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireMenuChoicesConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireMenuChoicesCreateFieldInput>>;
};

export type QuestionnaireMenuChoicesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireMenuChoicesNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireMenuChoicesNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireMenuChoicesNodeAggregationWhereInput>>;
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  iconFontFamily_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  iconFontFamily_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  iconFontFamily_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  iconFontFamily_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  iconFontFamily_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  iconFontPackage_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  iconFontPackage_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  iconFontPackage_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  iconFontPackage_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  iconFontPackage_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  iconFontPackage_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  iconFontPackage_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  iconFontPackage_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  iconFontPackage_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  iconFontPackage_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  iconFontPackage_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  iconFontPackage_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  iconFontPackage_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  iconFontPackage_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  iconFontPackage_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  iconName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  iconName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  iconName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  iconName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  iconName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  iconName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  iconName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  iconName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  iconName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  iconName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  iconName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  iconName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  iconName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  iconName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  iconName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  iconPrefix_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  iconPrefix_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  iconPrefix_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  iconPrefix_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  iconPrefix_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  iconPrefix_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  iconPrefix_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  iconPrefix_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  iconPrefix_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  iconPrefix_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  iconPrefix_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  iconPrefix_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  iconPrefix_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  iconPrefix_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  iconPrefix_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  icon_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  icon_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  icon_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  icon_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  icon_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  icon_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  icon_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  icon_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  icon_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  icon_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  icon_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  icon_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  icon_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  icon_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  icon_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  icon_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  icon_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  icon_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  icon_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  icon_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
  label_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  label_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireMenuChoicesRelationship = {
  __typename?: 'QuestionnaireMenuChoicesRelationship';
  cursor: Scalars['String']['output'];
  node: QuestionnaireMenuItem;
};

export type QuestionnaireMenuChoicesUpdateConnectionInput = {
  node?: InputMaybe<QuestionnaireMenuItemUpdateInput>;
};

export type QuestionnaireMenuChoicesUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireMenuChoicesConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireMenuChoicesCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireMenuChoicesDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireMenuChoicesDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireMenuChoicesUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireMenuChoicesConnectionWhere>;
};

export type QuestionnaireMenuConnectInput = {
  choices?: InputMaybe<Array<QuestionnaireMenuChoicesConnectFieldInput>>;
  graph?: InputMaybe<QuestionnaireMenuGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireMenuNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireMenuPrevsConnectFieldInput>>;
};

export type QuestionnaireMenuCreateInput = {
  choices?: InputMaybe<QuestionnaireMenuChoicesFieldInput>;
  graph?: InputMaybe<QuestionnaireMenuGraphFieldInput>;
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireMenuNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireMenuPrevsFieldInput>;
  showToDoctor?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuestionnaireMenuDeleteInput = {
  choices?: InputMaybe<Array<QuestionnaireMenuChoicesDeleteFieldInput>>;
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireMenuNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireMenuPrevsDeleteFieldInput>>;
};

export type QuestionnaireMenuDisconnectInput = {
  choices?: InputMaybe<Array<QuestionnaireMenuChoicesDisconnectFieldInput>>;
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireMenuNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireMenuPrevsDisconnectFieldInput>>;
};

export type QuestionnaireMenuEdge = {
  __typename?: 'QuestionnaireMenuEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireMenu;
};

export type QuestionnaireMenuEntriesConnection = {
  __typename?: 'QuestionnaireMenuEntriesConnection';
  edges: Array<QuestionnaireMenuEntryEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireMenuEntry = {
  __typename?: 'QuestionnaireMenuEntry';
  keywords?: Maybe<Scalars['String']['output']>;
  label: Scalars['String']['output'];
  order?: Maybe<Scalars['Int']['output']>;
  questionnaires: Array<Questionnaire>;
  questionnairesAggregate?: Maybe<QuestionnaireMenuEntryQuestionnaireQuestionnairesAggregationSelection>;
  questionnairesConnection: QuestionnaireMenuEntryQuestionnairesConnection;
};


export type QuestionnaireMenuEntryQuestionnairesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireOptions>;
  where?: InputMaybe<QuestionnaireWhere>;
};


export type QuestionnaireMenuEntryQuestionnairesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireWhere>;
};


export type QuestionnaireMenuEntryQuestionnairesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesConnectionSort>>;
  where?: InputMaybe<QuestionnaireMenuEntryQuestionnairesConnectionWhere>;
};

export type QuestionnaireMenuEntryAggregateSelection = {
  __typename?: 'QuestionnaireMenuEntryAggregateSelection';
  count: Scalars['Int']['output'];
  keywords: StringAggregateSelection;
  label: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type QuestionnaireMenuEntryConnectInput = {
  questionnaires?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesConnectFieldInput>>;
};

export type QuestionnaireMenuEntryConnectOrCreateInput = {
  questionnaires?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesConnectOrCreateFieldInput>>;
};

export type QuestionnaireMenuEntryConnectWhere = {
  node: QuestionnaireMenuEntryWhere;
};

export type QuestionnaireMenuEntryCreateInput = {
  keywords?: InputMaybe<Scalars['String']['input']>;
  label: Scalars['String']['input'];
  order?: InputMaybe<Scalars['Int']['input']>;
  questionnaires?: InputMaybe<QuestionnaireMenuEntryQuestionnairesFieldInput>;
};

export type QuestionnaireMenuEntryDeleteInput = {
  questionnaires?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesDeleteFieldInput>>;
};

export type QuestionnaireMenuEntryDisconnectInput = {
  questionnaires?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesDisconnectFieldInput>>;
};

export type QuestionnaireMenuEntryEdge = {
  __typename?: 'QuestionnaireMenuEntryEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireMenuEntry;
};

export type QuestionnaireMenuEntryOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireMenuEntrySort objects to sort QuestionnaireMenuEntries by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireMenuEntrySort>>;
};

export type QuestionnaireMenuEntryQuestionnaireQuestionnairesAggregationSelection = {
  __typename?: 'QuestionnaireMenuEntryQuestionnaireQuestionnairesAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireMenuEntryQuestionnaireQuestionnairesNodeAggregateSelection>;
};

export type QuestionnaireMenuEntryQuestionnaireQuestionnairesNodeAggregateSelection = {
  __typename?: 'QuestionnaireMenuEntryQuestionnaireQuestionnairesNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type QuestionnaireMenuEntryQuestionnairesAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireMenuEntryQuestionnairesAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireMenuEntryQuestionnairesNodeAggregationWhereInput>;
};

export type QuestionnaireMenuEntryQuestionnairesConnectFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<QuestionnaireConnectWhere>;
};

export type QuestionnaireMenuEntryQuestionnairesConnectOrCreateFieldInput = {
  onCreate: QuestionnaireMenuEntryQuestionnairesConnectOrCreateFieldInputOnCreate;
  where: QuestionnaireConnectOrCreateWhere;
};

export type QuestionnaireMenuEntryQuestionnairesConnectOrCreateFieldInputOnCreate = {
  node: QuestionnaireOnCreateInput;
};

export type QuestionnaireMenuEntryQuestionnairesConnection = {
  __typename?: 'QuestionnaireMenuEntryQuestionnairesConnection';
  edges: Array<QuestionnaireMenuEntryQuestionnairesRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireMenuEntryQuestionnairesConnectionSort = {
  node?: InputMaybe<QuestionnaireSort>;
};

export type QuestionnaireMenuEntryQuestionnairesConnectionWhere = {
  AND?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesConnectionWhere>>;
  NOT?: InputMaybe<QuestionnaireMenuEntryQuestionnairesConnectionWhere>;
  OR?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesConnectionWhere>>;
  node?: InputMaybe<QuestionnaireWhere>;
};

export type QuestionnaireMenuEntryQuestionnairesCreateFieldInput = {
  node: QuestionnaireCreateInput;
};

export type QuestionnaireMenuEntryQuestionnairesDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireDeleteInput>;
  where?: InputMaybe<QuestionnaireMenuEntryQuestionnairesConnectionWhere>;
};

export type QuestionnaireMenuEntryQuestionnairesDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireDisconnectInput>;
  where?: InputMaybe<QuestionnaireMenuEntryQuestionnairesConnectionWhere>;
};

export type QuestionnaireMenuEntryQuestionnairesFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesCreateFieldInput>>;
};

export type QuestionnaireMenuEntryQuestionnairesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireMenuEntryQuestionnairesNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesNodeAggregationWhereInput>>;
  nameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireMenuEntryQuestionnairesRelationship = {
  __typename?: 'QuestionnaireMenuEntryQuestionnairesRelationship';
  cursor: Scalars['String']['output'];
  node: Questionnaire;
};

export type QuestionnaireMenuEntryQuestionnairesUpdateConnectionInput = {
  node?: InputMaybe<QuestionnaireUpdateInput>;
};

export type QuestionnaireMenuEntryQuestionnairesUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireMenuEntryQuestionnairesUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireMenuEntryQuestionnairesConnectionWhere>;
};

export type QuestionnaireMenuEntryRelationInput = {
  questionnaires?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesCreateFieldInput>>;
};

/** Fields to sort QuestionnaireMenuEntries by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireMenuEntrySort object. */
export type QuestionnaireMenuEntrySort = {
  keywords?: InputMaybe<SortDirection>;
  label?: InputMaybe<SortDirection>;
  order?: InputMaybe<SortDirection>;
};

export type QuestionnaireMenuEntryUpdateInput = {
  keywords?: InputMaybe<Scalars['String']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  order_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  order_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  questionnaires?: InputMaybe<Array<QuestionnaireMenuEntryQuestionnairesUpdateFieldInput>>;
};

export type QuestionnaireMenuEntryWhere = {
  AND?: InputMaybe<Array<QuestionnaireMenuEntryWhere>>;
  NOT?: InputMaybe<QuestionnaireMenuEntryWhere>;
  OR?: InputMaybe<Array<QuestionnaireMenuEntryWhere>>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  keywords_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  keywords_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  keywords_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  keywords_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  label_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  label_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  label_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  label_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  order_GT?: InputMaybe<Scalars['Int']['input']>;
  order_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  order_LT?: InputMaybe<Scalars['Int']['input']>;
  order_LTE?: InputMaybe<Scalars['Int']['input']>;
  questionnairesAggregate?: InputMaybe<QuestionnaireMenuEntryQuestionnairesAggregateInput>;
  /** Return QuestionnaireMenuEntries where all of the related QuestionnaireMenuEntryQuestionnairesConnections match this filter */
  questionnairesConnection_ALL?: InputMaybe<QuestionnaireMenuEntryQuestionnairesConnectionWhere>;
  /** Return QuestionnaireMenuEntries where none of the related QuestionnaireMenuEntryQuestionnairesConnections match this filter */
  questionnairesConnection_NONE?: InputMaybe<QuestionnaireMenuEntryQuestionnairesConnectionWhere>;
  /** Return QuestionnaireMenuEntries where one of the related QuestionnaireMenuEntryQuestionnairesConnections match this filter */
  questionnairesConnection_SINGLE?: InputMaybe<QuestionnaireMenuEntryQuestionnairesConnectionWhere>;
  /** Return QuestionnaireMenuEntries where some of the related QuestionnaireMenuEntryQuestionnairesConnections match this filter */
  questionnairesConnection_SOME?: InputMaybe<QuestionnaireMenuEntryQuestionnairesConnectionWhere>;
  /** Return QuestionnaireMenuEntries where all of the related Questionnaires match this filter */
  questionnaires_ALL?: InputMaybe<QuestionnaireWhere>;
  /** Return QuestionnaireMenuEntries where none of the related Questionnaires match this filter */
  questionnaires_NONE?: InputMaybe<QuestionnaireWhere>;
  /** Return QuestionnaireMenuEntries where one of the related Questionnaires match this filter */
  questionnaires_SINGLE?: InputMaybe<QuestionnaireWhere>;
  /** Return QuestionnaireMenuEntries where some of the related Questionnaires match this filter */
  questionnaires_SOME?: InputMaybe<QuestionnaireWhere>;
};

export type QuestionnaireMenuGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireMenuGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireMenuGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireMenuGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireMenuGraphNodeAggregationWhereInput>;
};

export type QuestionnaireMenuGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireMenuGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireMenuGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireMenuGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireMenuGraphCreateFieldInput>;
};

export type QuestionnaireMenuGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireMenuGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireMenuGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireMenuGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireMenuGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireMenuGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireMenuGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireMenuGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireMenuGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireMenuItem = {
  __typename?: 'QuestionnaireMenuItem';
  description?: Maybe<Scalars['String']['output']>;
  icon: Scalars['Int']['output'];
  iconFontFamily: Scalars['String']['output'];
  iconFontPackage: Scalars['String']['output'];
  iconName?: Maybe<Scalars['String']['output']>;
  iconPrefix?: Maybe<Scalars['String']['output']>;
  label: Scalars['String']['output'];
  medicalLabel?: Maybe<Scalars['String']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
};

export type QuestionnaireMenuItemAggregateSelection = {
  __typename?: 'QuestionnaireMenuItemAggregateSelection';
  count: Scalars['Int']['output'];
  description: StringAggregateSelection;
  icon: IntAggregateSelection;
  iconFontFamily: StringAggregateSelection;
  iconFontPackage: StringAggregateSelection;
  iconName: StringAggregateSelection;
  iconPrefix: StringAggregateSelection;
  label: StringAggregateSelection;
  medicalLabel: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type QuestionnaireMenuItemConnectWhere = {
  node: QuestionnaireMenuItemWhere;
};

export type QuestionnaireMenuItemCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  icon: Scalars['Int']['input'];
  iconFontFamily: Scalars['String']['input'];
  iconFontPackage: Scalars['String']['input'];
  iconName?: InputMaybe<Scalars['String']['input']>;
  iconPrefix?: InputMaybe<Scalars['String']['input']>;
  label: Scalars['String']['input'];
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireMenuItemEdge = {
  __typename?: 'QuestionnaireMenuItemEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireMenuItem;
};

export type QuestionnaireMenuItemInput = {
  keywords?: InputMaybe<Scalars['String']['input']>;
  label: Scalars['String']['input'];
  order?: InputMaybe<Scalars['Int']['input']>;
  questionnaireIds: Array<Scalars['ID']['input']>;
};

export type QuestionnaireMenuItemOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireMenuItemSort objects to sort QuestionnaireMenuItems by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireMenuItemSort>>;
};

/** Fields to sort QuestionnaireMenuItems by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireMenuItemSort object. */
export type QuestionnaireMenuItemSort = {
  description?: InputMaybe<SortDirection>;
  icon?: InputMaybe<SortDirection>;
  iconFontFamily?: InputMaybe<SortDirection>;
  iconFontPackage?: InputMaybe<SortDirection>;
  iconName?: InputMaybe<SortDirection>;
  iconPrefix?: InputMaybe<SortDirection>;
  label?: InputMaybe<SortDirection>;
  medicalLabel?: InputMaybe<SortDirection>;
  order?: InputMaybe<SortDirection>;
};

export type QuestionnaireMenuItemUpdateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  icon?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily?: InputMaybe<Scalars['String']['input']>;
  iconFontPackage?: InputMaybe<Scalars['String']['input']>;
  iconName?: InputMaybe<Scalars['String']['input']>;
  iconPrefix?: InputMaybe<Scalars['String']['input']>;
  icon_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  icon_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  order_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  order_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireMenuItemWhere = {
  AND?: InputMaybe<Array<QuestionnaireMenuItemWhere>>;
  NOT?: InputMaybe<QuestionnaireMenuItemWhere>;
  OR?: InputMaybe<Array<QuestionnaireMenuItemWhere>>;
  description?: InputMaybe<Scalars['String']['input']>;
  description_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  description_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  description_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  description_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  icon?: InputMaybe<Scalars['Int']['input']>;
  iconFontFamily?: InputMaybe<Scalars['String']['input']>;
  iconFontFamily_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  iconFontFamily_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  iconFontFamily_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  iconFontFamily_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  iconFontPackage?: InputMaybe<Scalars['String']['input']>;
  iconFontPackage_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  iconFontPackage_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  iconFontPackage_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  iconFontPackage_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  iconName?: InputMaybe<Scalars['String']['input']>;
  iconName_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  iconName_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  iconName_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  iconName_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  iconPrefix?: InputMaybe<Scalars['String']['input']>;
  iconPrefix_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  iconPrefix_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  iconPrefix_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  iconPrefix_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  icon_GT?: InputMaybe<Scalars['Int']['input']>;
  icon_GTE?: InputMaybe<Scalars['Int']['input']>;
  icon_IN?: InputMaybe<Array<Scalars['Int']['input']>>;
  icon_LT?: InputMaybe<Scalars['Int']['input']>;
  icon_LTE?: InputMaybe<Scalars['Int']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  label_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  label_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  label_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  label_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  medicalLabel_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  medicalLabel_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  medicalLabel_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  medicalLabel_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  order_GT?: InputMaybe<Scalars['Int']['input']>;
  order_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  order_LT?: InputMaybe<Scalars['Int']['input']>;
  order_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireMenuItemsConnection = {
  __typename?: 'QuestionnaireMenuItemsConnection';
  edges: Array<QuestionnaireMenuItemEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireMenuNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireMenuNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireMenuNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireMenuNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireMenuNextsNodeAggregationWhereInput>;
};

export type QuestionnaireMenuNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireMenuNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireMenuNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireMenuNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireMenuNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireMenuNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireMenuNextsCreateFieldInput>>;
};

export type QuestionnaireMenuNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireMenuNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireMenuNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireMenuNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireMenuNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireMenuNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireMenuNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireMenuNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireMenuNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireMenuNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireMenuNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireMenuOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireMenuSort objects to sort QuestionnaireMenus by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireMenuSort>>;
};

export type QuestionnaireMenuPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireMenuPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireMenuPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireMenuPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireMenuPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireMenuPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireMenuPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireMenuPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireMenuPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireMenuPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireMenuPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireMenuPrevsCreateFieldInput>>;
};

export type QuestionnaireMenuPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireMenuPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireMenuPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireMenuPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireMenuPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireMenuPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireMenuPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireMenuPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireMenuPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireMenuPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireMenuPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireMenuQuestionnaireMenuItemChoicesAggregationSelection = {
  __typename?: 'QuestionnaireMenuQuestionnaireMenuItemChoicesAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireMenuQuestionnaireMenuItemChoicesNodeAggregateSelection>;
};

export type QuestionnaireMenuQuestionnaireMenuItemChoicesNodeAggregateSelection = {
  __typename?: 'QuestionnaireMenuQuestionnaireMenuItemChoicesNodeAggregateSelection';
  description: StringAggregateSelection;
  icon: IntAggregateSelection;
  iconFontFamily: StringAggregateSelection;
  iconFontPackage: StringAggregateSelection;
  iconName: StringAggregateSelection;
  iconPrefix: StringAggregateSelection;
  label: StringAggregateSelection;
  medicalLabel: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type QuestionnaireMenuQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireMenuQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireMenuQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireMenuQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireMenuQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireMenuQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireMenuQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireMenuQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireMenuQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireMenuQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireMenuQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireMenuQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireMenuQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireMenuQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireMenuQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireMenuQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireMenuRelationInput = {
  choices?: InputMaybe<Array<QuestionnaireMenuChoicesCreateFieldInput>>;
  graph?: InputMaybe<QuestionnaireMenuGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireMenuNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireMenuPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireMenus by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireMenuSort object. */
export type QuestionnaireMenuSort = {
  id?: InputMaybe<SortDirection>;
  medicalLabel?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  showToDoctor?: InputMaybe<SortDirection>;
};

export type QuestionnaireMenuUpdateInput = {
  choices?: InputMaybe<Array<QuestionnaireMenuChoicesUpdateFieldInput>>;
  graph?: InputMaybe<QuestionnaireMenuGraphUpdateFieldInput>;
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireMenuNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireMenuPrevsUpdateFieldInput>>;
  showToDoctor?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuestionnaireMenuVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireMenuVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireMenuVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireMenuVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireMenuVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireMenuWhere = {
  AND?: InputMaybe<Array<QuestionnaireMenuWhere>>;
  NOT?: InputMaybe<QuestionnaireMenuWhere>;
  OR?: InputMaybe<Array<QuestionnaireMenuWhere>>;
  choicesAggregate?: InputMaybe<QuestionnaireMenuChoicesAggregateInput>;
  /** Return QuestionnaireMenus where all of the related QuestionnaireMenuChoicesConnections match this filter */
  choicesConnection_ALL?: InputMaybe<QuestionnaireMenuChoicesConnectionWhere>;
  /** Return QuestionnaireMenus where none of the related QuestionnaireMenuChoicesConnections match this filter */
  choicesConnection_NONE?: InputMaybe<QuestionnaireMenuChoicesConnectionWhere>;
  /** Return QuestionnaireMenus where one of the related QuestionnaireMenuChoicesConnections match this filter */
  choicesConnection_SINGLE?: InputMaybe<QuestionnaireMenuChoicesConnectionWhere>;
  /** Return QuestionnaireMenus where some of the related QuestionnaireMenuChoicesConnections match this filter */
  choicesConnection_SOME?: InputMaybe<QuestionnaireMenuChoicesConnectionWhere>;
  /** Return QuestionnaireMenus where all of the related QuestionnaireMenuItems match this filter */
  choices_ALL?: InputMaybe<QuestionnaireMenuItemWhere>;
  /** Return QuestionnaireMenus where none of the related QuestionnaireMenuItems match this filter */
  choices_NONE?: InputMaybe<QuestionnaireMenuItemWhere>;
  /** Return QuestionnaireMenus where one of the related QuestionnaireMenuItems match this filter */
  choices_SINGLE?: InputMaybe<QuestionnaireMenuItemWhere>;
  /** Return QuestionnaireMenus where some of the related QuestionnaireMenuItems match this filter */
  choices_SOME?: InputMaybe<QuestionnaireMenuItemWhere>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireMenuGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  medicalLabel_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  medicalLabel_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  medicalLabel_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  medicalLabel_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireMenuNextsAggregateInput>;
  /** Return QuestionnaireMenus where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireMenus where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireMenus where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireMenus where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireMenus where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireMenus where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireMenus where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireMenus where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireMenuPrevsAggregateInput>;
  /** Return QuestionnaireMenus where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireMenus where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireMenus where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireMenus where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireMenus where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireMenus where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireMenus where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireMenus where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  showToDoctor?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuestionnaireMenusConnection = {
  __typename?: 'QuestionnaireMenusConnection';
  edges: Array<QuestionnaireMenuEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireOnCreateInput = {
  name: Scalars['String']['input'];
};

export type QuestionnaireOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireSort objects to sort Questionnaires by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireSort>>;
};

export type QuestionnaireOwnerConnectInput = {
  Doctor?: InputMaybe<QuestionnaireOwnerDoctorConnectFieldInput>;
  Institution?: InputMaybe<QuestionnaireOwnerInstitutionConnectFieldInput>;
};

export type QuestionnaireOwnerConnectOrCreateInput = {
  Doctor?: InputMaybe<QuestionnaireOwnerDoctorConnectOrCreateFieldInput>;
  Institution?: InputMaybe<QuestionnaireOwnerInstitutionConnectOrCreateFieldInput>;
};

export type QuestionnaireOwnerCreateFieldInput = {
  Doctor?: InputMaybe<QuestionnaireOwnerDoctorCreateFieldInput>;
  Institution?: InputMaybe<QuestionnaireOwnerInstitutionCreateFieldInput>;
};

export type QuestionnaireOwnerCreateInput = {
  Doctor?: InputMaybe<QuestionnaireOwnerDoctorFieldInput>;
  Institution?: InputMaybe<QuestionnaireOwnerInstitutionFieldInput>;
};

export type QuestionnaireOwnerDeleteInput = {
  Doctor?: InputMaybe<BaseQuestionnaireOwnerDoctorDeleteFieldInput>;
  Institution?: InputMaybe<BaseQuestionnaireOwnerInstitutionDeleteFieldInput>;
};

export type QuestionnaireOwnerDisconnectInput = {
  Doctor?: InputMaybe<BaseQuestionnaireOwnerDoctorDisconnectFieldInput>;
  Institution?: InputMaybe<BaseQuestionnaireOwnerInstitutionDisconnectFieldInput>;
};

export type QuestionnaireOwnerDoctorConnectFieldInput = {
  connect?: InputMaybe<DoctorConnectInput>;
  where?: InputMaybe<DoctorConnectWhere>;
};

export type QuestionnaireOwnerDoctorConnectOrCreateFieldInput = {
  onCreate: QuestionnaireOwnerDoctorConnectOrCreateFieldInputOnCreate;
  where: DoctorConnectOrCreateWhere;
};

export type QuestionnaireOwnerDoctorConnectOrCreateFieldInputOnCreate = {
  node: DoctorOnCreateInput;
};

export type QuestionnaireOwnerDoctorCreateFieldInput = {
  node: DoctorCreateInput;
};

export type QuestionnaireOwnerDoctorFieldInput = {
  connect?: InputMaybe<QuestionnaireOwnerDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<QuestionnaireOwnerDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<QuestionnaireOwnerDoctorCreateFieldInput>;
};

export type QuestionnaireOwnerDoctorUpdateConnectionInput = {
  node?: InputMaybe<DoctorUpdateInput>;
};

export type QuestionnaireOwnerDoctorUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireOwnerDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<QuestionnaireOwnerDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<QuestionnaireOwnerDoctorCreateFieldInput>;
  delete?: InputMaybe<BaseQuestionnaireOwnerDoctorDeleteFieldInput>;
  disconnect?: InputMaybe<BaseQuestionnaireOwnerDoctorDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireOwnerDoctorUpdateConnectionInput>;
  where?: InputMaybe<BaseQuestionnaireOwnerDoctorConnectionWhere>;
};

export type QuestionnaireOwnerInstitutionConnectFieldInput = {
  connect?: InputMaybe<InstitutionConnectInput>;
  where?: InputMaybe<InstitutionConnectWhere>;
};

export type QuestionnaireOwnerInstitutionConnectOrCreateFieldInput = {
  onCreate: QuestionnaireOwnerInstitutionConnectOrCreateFieldInputOnCreate;
  where: InstitutionConnectOrCreateWhere;
};

export type QuestionnaireOwnerInstitutionConnectOrCreateFieldInputOnCreate = {
  node: InstitutionOnCreateInput;
};

export type QuestionnaireOwnerInstitutionCreateFieldInput = {
  node: InstitutionCreateInput;
};

export type QuestionnaireOwnerInstitutionFieldInput = {
  connect?: InputMaybe<QuestionnaireOwnerInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<QuestionnaireOwnerInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<QuestionnaireOwnerInstitutionCreateFieldInput>;
};

export type QuestionnaireOwnerInstitutionUpdateConnectionInput = {
  node?: InputMaybe<InstitutionUpdateInput>;
};

export type QuestionnaireOwnerInstitutionUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireOwnerInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<QuestionnaireOwnerInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<QuestionnaireOwnerInstitutionCreateFieldInput>;
  delete?: InputMaybe<BaseQuestionnaireOwnerInstitutionDeleteFieldInput>;
  disconnect?: InputMaybe<BaseQuestionnaireOwnerInstitutionDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireOwnerInstitutionUpdateConnectionInput>;
  where?: InputMaybe<BaseQuestionnaireOwnerInstitutionConnectionWhere>;
};

export type QuestionnaireOwnerUpdateInput = {
  Doctor?: InputMaybe<QuestionnaireOwnerDoctorUpdateFieldInput>;
  Institution?: InputMaybe<QuestionnaireOwnerInstitutionUpdateFieldInput>;
};

export type QuestionnaireQuestionnaireAutocompleteFulltext = {
  phrase: Scalars['String']['input'];
};

export type QuestionnaireRelationInput = {
  owner?: InputMaybe<QuestionnaireOwnerCreateFieldInput>;
  versions?: InputMaybe<Array<QuestionnaireVersionsCreateFieldInput>>;
};

export type QuestionnaireRouter = QuestionnaireStep & {
  __typename?: 'QuestionnaireRouter';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireRouterVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireRouterQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireRouterQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
  routes: Array<ConditionGroup>;
  routesAggregate?: Maybe<QuestionnaireRouterConditionGroupRoutesAggregationSelection>;
  routesConnection: QuestionnaireRouterRoutesConnection;
};


export type QuestionnaireRouterGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireRouterGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireRouterGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireRouterNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireRouterNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireRouterNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireRouterPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireRouterPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireRouterPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};


export type QuestionnaireRouterRoutesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<ConditionGroupOptions>;
  where?: InputMaybe<ConditionGroupWhere>;
};


export type QuestionnaireRouterRoutesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<ConditionGroupWhere>;
};


export type QuestionnaireRouterRoutesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireRouterRoutesConnectionSort>>;
  where?: InputMaybe<QuestionnaireRouterRoutesConnectionWhere>;
};

export type QuestionnaireRouterAggregateSelection = {
  __typename?: 'QuestionnaireRouterAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireRouterConditionGroupRoutesAggregationSelection = {
  __typename?: 'QuestionnaireRouterConditionGroupRoutesAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireRouterConditionGroupRoutesNodeAggregateSelection>;
};

export type QuestionnaireRouterConditionGroupRoutesNodeAggregateSelection = {
  __typename?: 'QuestionnaireRouterConditionGroupRoutesNodeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireRouterConnectInput = {
  graph?: InputMaybe<QuestionnaireRouterGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireRouterNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireRouterPrevsConnectFieldInput>>;
  routes?: InputMaybe<Array<QuestionnaireRouterRoutesConnectFieldInput>>;
};

export type QuestionnaireRouterCreateInput = {
  graph?: InputMaybe<QuestionnaireRouterGraphFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireRouterNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireRouterPrevsFieldInput>;
  routes?: InputMaybe<QuestionnaireRouterRoutesFieldInput>;
};

export type QuestionnaireRouterDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireRouterNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireRouterPrevsDeleteFieldInput>>;
  routes?: InputMaybe<Array<QuestionnaireRouterRoutesDeleteFieldInput>>;
};

export type QuestionnaireRouterDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireRouterNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireRouterPrevsDisconnectFieldInput>>;
  routes?: InputMaybe<Array<QuestionnaireRouterRoutesDisconnectFieldInput>>;
};

export type QuestionnaireRouterEdge = {
  __typename?: 'QuestionnaireRouterEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireRouter;
};

export type QuestionnaireRouterGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireRouterGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireRouterGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireRouterGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireRouterGraphNodeAggregationWhereInput>;
};

export type QuestionnaireRouterGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireRouterGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireRouterGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireRouterGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireRouterGraphCreateFieldInput>;
};

export type QuestionnaireRouterGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireRouterGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireRouterGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireRouterGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireRouterGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireRouterGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireRouterGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireRouterGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireRouterGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireRouterNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireRouterNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireRouterNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireRouterNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireRouterNextsNodeAggregationWhereInput>;
};

export type QuestionnaireRouterNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireRouterNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireRouterNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireRouterNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireRouterNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireRouterNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireRouterNextsCreateFieldInput>>;
};

export type QuestionnaireRouterNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireRouterNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireRouterNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireRouterNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireRouterNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireRouterNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireRouterNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireRouterNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireRouterNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireRouterNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireRouterNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireRouterOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireRouterSort objects to sort QuestionnaireRouters by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireRouterSort>>;
};

export type QuestionnaireRouterPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireRouterPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireRouterPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireRouterPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireRouterPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireRouterPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireRouterPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireRouterPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireRouterPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireRouterPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireRouterPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireRouterPrevsCreateFieldInput>>;
};

export type QuestionnaireRouterPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireRouterPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireRouterPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireRouterPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireRouterPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireRouterPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireRouterPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireRouterPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireRouterPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireRouterPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireRouterPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireRouterQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireRouterQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireRouterQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireRouterQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireRouterQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireRouterQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireRouterQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireRouterQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireRouterQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireRouterQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireRouterQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireRouterQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireRouterQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireRouterQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireRouterQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireRouterQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireRouterRelationInput = {
  graph?: InputMaybe<QuestionnaireRouterGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireRouterNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireRouterPrevsCreateFieldInput>>;
  routes?: InputMaybe<Array<QuestionnaireRouterRoutesCreateFieldInput>>;
};

export type QuestionnaireRouterRoutesAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireRouterRoutesAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireRouterRoutesAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireRouterRoutesAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireRouterRoutesNodeAggregationWhereInput>;
};

export type QuestionnaireRouterRoutesConnectFieldInput = {
  connect?: InputMaybe<Array<ConditionGroupConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<ConditionGroupConnectWhere>;
};

export type QuestionnaireRouterRoutesConnection = {
  __typename?: 'QuestionnaireRouterRoutesConnection';
  edges: Array<QuestionnaireRouterRoutesRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireRouterRoutesConnectionSort = {
  node?: InputMaybe<ConditionGroupSort>;
};

export type QuestionnaireRouterRoutesConnectionWhere = {
  AND?: InputMaybe<Array<QuestionnaireRouterRoutesConnectionWhere>>;
  NOT?: InputMaybe<QuestionnaireRouterRoutesConnectionWhere>;
  OR?: InputMaybe<Array<QuestionnaireRouterRoutesConnectionWhere>>;
  node?: InputMaybe<ConditionGroupWhere>;
};

export type QuestionnaireRouterRoutesCreateFieldInput = {
  node: ConditionGroupCreateInput;
};

export type QuestionnaireRouterRoutesDeleteFieldInput = {
  delete?: InputMaybe<ConditionGroupDeleteInput>;
  where?: InputMaybe<QuestionnaireRouterRoutesConnectionWhere>;
};

export type QuestionnaireRouterRoutesDisconnectFieldInput = {
  disconnect?: InputMaybe<ConditionGroupDisconnectInput>;
  where?: InputMaybe<QuestionnaireRouterRoutesConnectionWhere>;
};

export type QuestionnaireRouterRoutesFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireRouterRoutesConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireRouterRoutesCreateFieldInput>>;
};

export type QuestionnaireRouterRoutesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireRouterRoutesNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireRouterRoutesNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireRouterRoutesNodeAggregationWhereInput>>;
  label_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  label_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireRouterRoutesRelationship = {
  __typename?: 'QuestionnaireRouterRoutesRelationship';
  cursor: Scalars['String']['output'];
  node: ConditionGroup;
};

export type QuestionnaireRouterRoutesUpdateConnectionInput = {
  node?: InputMaybe<ConditionGroupUpdateInput>;
};

export type QuestionnaireRouterRoutesUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireRouterRoutesConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireRouterRoutesCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireRouterRoutesDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireRouterRoutesDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireRouterRoutesUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireRouterRoutesConnectionWhere>;
};

/** Fields to sort QuestionnaireRouters by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireRouterSort object. */
export type QuestionnaireRouterSort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type QuestionnaireRouterUpdateInput = {
  graph?: InputMaybe<QuestionnaireRouterGraphUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireRouterNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireRouterPrevsUpdateFieldInput>>;
  routes?: InputMaybe<Array<QuestionnaireRouterRoutesUpdateFieldInput>>;
};

export type QuestionnaireRouterVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireRouterVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireRouterVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireRouterVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireRouterVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireRouterWhere = {
  AND?: InputMaybe<Array<QuestionnaireRouterWhere>>;
  NOT?: InputMaybe<QuestionnaireRouterWhere>;
  OR?: InputMaybe<Array<QuestionnaireRouterWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireRouterGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireRouterNextsAggregateInput>;
  /** Return QuestionnaireRouters where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireRouters where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireRouters where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireRouters where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireRouters where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireRouters where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireRouters where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireRouters where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireRouterPrevsAggregateInput>;
  /** Return QuestionnaireRouters where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireRouters where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireRouters where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireRouters where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireRouters where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireRouters where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireRouters where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireRouters where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  routesAggregate?: InputMaybe<QuestionnaireRouterRoutesAggregateInput>;
  /** Return QuestionnaireRouters where all of the related QuestionnaireRouterRoutesConnections match this filter */
  routesConnection_ALL?: InputMaybe<QuestionnaireRouterRoutesConnectionWhere>;
  /** Return QuestionnaireRouters where none of the related QuestionnaireRouterRoutesConnections match this filter */
  routesConnection_NONE?: InputMaybe<QuestionnaireRouterRoutesConnectionWhere>;
  /** Return QuestionnaireRouters where one of the related QuestionnaireRouterRoutesConnections match this filter */
  routesConnection_SINGLE?: InputMaybe<QuestionnaireRouterRoutesConnectionWhere>;
  /** Return QuestionnaireRouters where some of the related QuestionnaireRouterRoutesConnections match this filter */
  routesConnection_SOME?: InputMaybe<QuestionnaireRouterRoutesConnectionWhere>;
  /** Return QuestionnaireRouters where all of the related ConditionGroups match this filter */
  routes_ALL?: InputMaybe<ConditionGroupWhere>;
  /** Return QuestionnaireRouters where none of the related ConditionGroups match this filter */
  routes_NONE?: InputMaybe<ConditionGroupWhere>;
  /** Return QuestionnaireRouters where one of the related ConditionGroups match this filter */
  routes_SINGLE?: InputMaybe<ConditionGroupWhere>;
  /** Return QuestionnaireRouters where some of the related ConditionGroups match this filter */
  routes_SOME?: InputMaybe<ConditionGroupWhere>;
};

export type QuestionnaireRoutersConnection = {
  __typename?: 'QuestionnaireRoutersConnection';
  edges: Array<QuestionnaireRouterEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireSelectMenu = QuestionnaireStep & {
  __typename?: 'QuestionnaireSelectMenu';
  entries: Array<QuestionnaireMenuEntry>;
  entriesAggregate?: Maybe<QuestionnaireSelectMenuQuestionnaireMenuEntryEntriesAggregationSelection>;
  entriesConnection: QuestionnaireSelectMenuEntriesConnection;
  field?: Maybe<Scalars['String']['output']>;
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireSelectMenuVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireSelectMenuQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  placeholder?: Maybe<Scalars['String']['output']>;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireSelectMenuQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type QuestionnaireSelectMenuEntriesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireMenuEntryOptions>;
  where?: InputMaybe<QuestionnaireMenuEntryWhere>;
};


export type QuestionnaireSelectMenuEntriesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireMenuEntryWhere>;
};


export type QuestionnaireSelectMenuEntriesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireSelectMenuEntriesConnectionSort>>;
  where?: InputMaybe<QuestionnaireSelectMenuEntriesConnectionWhere>;
};


export type QuestionnaireSelectMenuGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireSelectMenuGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireSelectMenuGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireSelectMenuNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSelectMenuNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSelectMenuNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireSelectMenuPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSelectMenuPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSelectMenuPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSelectMenuAggregateSelection = {
  __typename?: 'QuestionnaireSelectMenuAggregateSelection';
  count: Scalars['Int']['output'];
  field: StringAggregateSelection;
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  placeholder: StringAggregateSelection;
};

export type QuestionnaireSelectMenuConnectInput = {
  entries?: InputMaybe<Array<QuestionnaireSelectMenuEntriesConnectFieldInput>>;
  graph?: InputMaybe<QuestionnaireSelectMenuGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSelectMenuNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSelectMenuPrevsConnectFieldInput>>;
};

export type QuestionnaireSelectMenuCreateInput = {
  entries?: InputMaybe<QuestionnaireSelectMenuEntriesFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<QuestionnaireSelectMenuGraphFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireSelectMenuNextsFieldInput>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  prevs?: InputMaybe<QuestionnaireSelectMenuPrevsFieldInput>;
};

export type QuestionnaireSelectMenuDeleteInput = {
  entries?: InputMaybe<Array<QuestionnaireSelectMenuEntriesDeleteFieldInput>>;
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSelectMenuNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSelectMenuPrevsDeleteFieldInput>>;
};

export type QuestionnaireSelectMenuDisconnectInput = {
  entries?: InputMaybe<Array<QuestionnaireSelectMenuEntriesDisconnectFieldInput>>;
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSelectMenuNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSelectMenuPrevsDisconnectFieldInput>>;
};

export type QuestionnaireSelectMenuEdge = {
  __typename?: 'QuestionnaireSelectMenuEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireSelectMenu;
};

export type QuestionnaireSelectMenuEntriesAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireSelectMenuEntriesAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireSelectMenuEntriesAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireSelectMenuEntriesAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireSelectMenuEntriesNodeAggregationWhereInput>;
};

export type QuestionnaireSelectMenuEntriesConnectFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireMenuEntryConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<QuestionnaireMenuEntryConnectWhere>;
};

export type QuestionnaireSelectMenuEntriesConnection = {
  __typename?: 'QuestionnaireSelectMenuEntriesConnection';
  edges: Array<QuestionnaireSelectMenuEntriesRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireSelectMenuEntriesConnectionSort = {
  node?: InputMaybe<QuestionnaireMenuEntrySort>;
};

export type QuestionnaireSelectMenuEntriesConnectionWhere = {
  AND?: InputMaybe<Array<QuestionnaireSelectMenuEntriesConnectionWhere>>;
  NOT?: InputMaybe<QuestionnaireSelectMenuEntriesConnectionWhere>;
  OR?: InputMaybe<Array<QuestionnaireSelectMenuEntriesConnectionWhere>>;
  node?: InputMaybe<QuestionnaireMenuEntryWhere>;
};

export type QuestionnaireSelectMenuEntriesCreateFieldInput = {
  node: QuestionnaireMenuEntryCreateInput;
};

export type QuestionnaireSelectMenuEntriesDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireMenuEntryDeleteInput>;
  where?: InputMaybe<QuestionnaireSelectMenuEntriesConnectionWhere>;
};

export type QuestionnaireSelectMenuEntriesDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireMenuEntryDisconnectInput>;
  where?: InputMaybe<QuestionnaireSelectMenuEntriesConnectionWhere>;
};

export type QuestionnaireSelectMenuEntriesFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSelectMenuEntriesConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSelectMenuEntriesCreateFieldInput>>;
};

export type QuestionnaireSelectMenuEntriesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireSelectMenuEntriesNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireSelectMenuEntriesNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireSelectMenuEntriesNodeAggregationWhereInput>>;
  keywords_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  keywords_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  keywords_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  keywords_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  keywords_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  keywords_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  keywords_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  keywords_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  keywords_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  keywords_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  keywords_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  keywords_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  keywords_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  keywords_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  keywords_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  label_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  label_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireSelectMenuEntriesRelationship = {
  __typename?: 'QuestionnaireSelectMenuEntriesRelationship';
  cursor: Scalars['String']['output'];
  node: QuestionnaireMenuEntry;
};

export type QuestionnaireSelectMenuEntriesUpdateConnectionInput = {
  node?: InputMaybe<QuestionnaireMenuEntryUpdateInput>;
};

export type QuestionnaireSelectMenuEntriesUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSelectMenuEntriesConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSelectMenuEntriesCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireSelectMenuEntriesDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireSelectMenuEntriesDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireSelectMenuEntriesUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireSelectMenuEntriesConnectionWhere>;
};

export type QuestionnaireSelectMenuGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireSelectMenuGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireSelectMenuGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireSelectMenuGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireSelectMenuGraphNodeAggregationWhereInput>;
};

export type QuestionnaireSelectMenuGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireSelectMenuGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireSelectMenuGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireSelectMenuGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireSelectMenuGraphCreateFieldInput>;
};

export type QuestionnaireSelectMenuGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireSelectMenuGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireSelectMenuGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireSelectMenuGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireSelectMenuGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireSelectMenuGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireSelectMenuGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireSelectMenuGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireSelectMenuGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireSelectMenuNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireSelectMenuNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireSelectMenuNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireSelectMenuNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireSelectMenuNextsNodeAggregationWhereInput>;
};

export type QuestionnaireSelectMenuNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireSelectMenuNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireSelectMenuNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireSelectMenuNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireSelectMenuNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSelectMenuNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSelectMenuNextsCreateFieldInput>>;
};

export type QuestionnaireSelectMenuNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireSelectMenuNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireSelectMenuNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireSelectMenuNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireSelectMenuNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireSelectMenuNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSelectMenuNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSelectMenuNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireSelectMenuNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireSelectMenuNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireSelectMenuNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireSelectMenuOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireSelectMenuSort objects to sort QuestionnaireSelectMenus by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireSelectMenuSort>>;
};

export type QuestionnaireSelectMenuPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireSelectMenuPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireSelectMenuPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireSelectMenuPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireSelectMenuPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireSelectMenuPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireSelectMenuPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireSelectMenuPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSelectMenuPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSelectMenuPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSelectMenuPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSelectMenuPrevsCreateFieldInput>>;
};

export type QuestionnaireSelectMenuPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireSelectMenuPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireSelectMenuPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireSelectMenuPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireSelectMenuPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireSelectMenuPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSelectMenuPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSelectMenuPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireSelectMenuPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireSelectMenuPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireSelectMenuPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSelectMenuQuestionnaireMenuEntryEntriesAggregationSelection = {
  __typename?: 'QuestionnaireSelectMenuQuestionnaireMenuEntryEntriesAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireSelectMenuQuestionnaireMenuEntryEntriesNodeAggregateSelection>;
};

export type QuestionnaireSelectMenuQuestionnaireMenuEntryEntriesNodeAggregateSelection = {
  __typename?: 'QuestionnaireSelectMenuQuestionnaireMenuEntryEntriesNodeAggregateSelection';
  keywords: StringAggregateSelection;
  label: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type QuestionnaireSelectMenuQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireSelectMenuQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireSelectMenuQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireSelectMenuQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireSelectMenuQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireSelectMenuQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireSelectMenuQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireSelectMenuQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireSelectMenuQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireSelectMenuQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireSelectMenuQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireSelectMenuQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireSelectMenuQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireSelectMenuQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireSelectMenuQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireSelectMenuQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireSelectMenuRelationInput = {
  entries?: InputMaybe<Array<QuestionnaireSelectMenuEntriesCreateFieldInput>>;
  graph?: InputMaybe<QuestionnaireSelectMenuGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSelectMenuNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSelectMenuPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireSelectMenus by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireSelectMenuSort object. */
export type QuestionnaireSelectMenuSort = {
  field?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  placeholder?: InputMaybe<SortDirection>;
};

export type QuestionnaireSelectMenuUpdateInput = {
  entries?: InputMaybe<Array<QuestionnaireSelectMenuEntriesUpdateFieldInput>>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<QuestionnaireSelectMenuGraphUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireSelectMenuNextsUpdateFieldInput>>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  prevs?: InputMaybe<Array<QuestionnaireSelectMenuPrevsUpdateFieldInput>>;
};

export type QuestionnaireSelectMenuVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireSelectMenuVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireSelectMenuVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireSelectMenuVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireSelectMenuVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireSelectMenuWhere = {
  AND?: InputMaybe<Array<QuestionnaireSelectMenuWhere>>;
  NOT?: InputMaybe<QuestionnaireSelectMenuWhere>;
  OR?: InputMaybe<Array<QuestionnaireSelectMenuWhere>>;
  entriesAggregate?: InputMaybe<QuestionnaireSelectMenuEntriesAggregateInput>;
  /** Return QuestionnaireSelectMenus where all of the related QuestionnaireSelectMenuEntriesConnections match this filter */
  entriesConnection_ALL?: InputMaybe<QuestionnaireSelectMenuEntriesConnectionWhere>;
  /** Return QuestionnaireSelectMenus where none of the related QuestionnaireSelectMenuEntriesConnections match this filter */
  entriesConnection_NONE?: InputMaybe<QuestionnaireSelectMenuEntriesConnectionWhere>;
  /** Return QuestionnaireSelectMenus where one of the related QuestionnaireSelectMenuEntriesConnections match this filter */
  entriesConnection_SINGLE?: InputMaybe<QuestionnaireSelectMenuEntriesConnectionWhere>;
  /** Return QuestionnaireSelectMenus where some of the related QuestionnaireSelectMenuEntriesConnections match this filter */
  entriesConnection_SOME?: InputMaybe<QuestionnaireSelectMenuEntriesConnectionWhere>;
  /** Return QuestionnaireSelectMenus where all of the related QuestionnaireMenuEntries match this filter */
  entries_ALL?: InputMaybe<QuestionnaireMenuEntryWhere>;
  /** Return QuestionnaireSelectMenus where none of the related QuestionnaireMenuEntries match this filter */
  entries_NONE?: InputMaybe<QuestionnaireMenuEntryWhere>;
  /** Return QuestionnaireSelectMenus where one of the related QuestionnaireMenuEntries match this filter */
  entries_SINGLE?: InputMaybe<QuestionnaireMenuEntryWhere>;
  /** Return QuestionnaireSelectMenus where some of the related QuestionnaireMenuEntries match this filter */
  entries_SOME?: InputMaybe<QuestionnaireMenuEntryWhere>;
  field?: InputMaybe<Scalars['String']['input']>;
  field_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  field_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  field_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  field_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireSelectMenuGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireSelectMenuNextsAggregateInput>;
  /** Return QuestionnaireSelectMenus where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSelectMenus where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSelectMenus where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSelectMenus where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSelectMenus where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSelectMenus where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSelectMenus where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSelectMenus where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  placeholder_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  placeholder_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  placeholder_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  placeholder_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  prevsAggregate?: InputMaybe<QuestionnaireSelectMenuPrevsAggregateInput>;
  /** Return QuestionnaireSelectMenus where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSelectMenus where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSelectMenus where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSelectMenus where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSelectMenus where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSelectMenus where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSelectMenus where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSelectMenus where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type QuestionnaireSelectMenusConnection = {
  __typename?: 'QuestionnaireSelectMenusConnection';
  edges: Array<QuestionnaireSelectMenuEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireSetPropertiesConnection = {
  __typename?: 'QuestionnaireSetPropertiesConnection';
  edges: Array<QuestionnaireSetPropertyEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireSetProperty = QuestionnaireStep & {
  __typename?: 'QuestionnaireSetProperty';
  field?: Maybe<Scalars['String']['output']>;
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireSetPropertyVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireSetPropertyQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireSetPropertyQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
  value?: Maybe<Scalars['String']['output']>;
};


export type QuestionnaireSetPropertyGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireSetPropertyGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireSetPropertyGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireSetPropertyNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSetPropertyNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSetPropertyNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireSetPropertyPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSetPropertyPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSetPropertyPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSetPropertyAggregateSelection = {
  __typename?: 'QuestionnaireSetPropertyAggregateSelection';
  count: Scalars['Int']['output'];
  field: StringAggregateSelection;
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  value: StringAggregateSelection;
};

export type QuestionnaireSetPropertyConnectInput = {
  graph?: InputMaybe<QuestionnaireSetPropertyGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSetPropertyNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSetPropertyPrevsConnectFieldInput>>;
};

export type QuestionnaireSetPropertyCreateInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<QuestionnaireSetPropertyGraphFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireSetPropertyNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireSetPropertyPrevsFieldInput>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireSetPropertyDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSetPropertyNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSetPropertyPrevsDeleteFieldInput>>;
};

export type QuestionnaireSetPropertyDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSetPropertyNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSetPropertyPrevsDisconnectFieldInput>>;
};

export type QuestionnaireSetPropertyEdge = {
  __typename?: 'QuestionnaireSetPropertyEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireSetProperty;
};

export type QuestionnaireSetPropertyGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireSetPropertyGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireSetPropertyGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireSetPropertyGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireSetPropertyGraphNodeAggregationWhereInput>;
};

export type QuestionnaireSetPropertyGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireSetPropertyGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireSetPropertyGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireSetPropertyGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireSetPropertyGraphCreateFieldInput>;
};

export type QuestionnaireSetPropertyGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireSetPropertyGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireSetPropertyGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireSetPropertyGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireSetPropertyGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireSetPropertyGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireSetPropertyGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireSetPropertyGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireSetPropertyGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireSetPropertyNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireSetPropertyNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireSetPropertyNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireSetPropertyNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireSetPropertyNextsNodeAggregationWhereInput>;
};

export type QuestionnaireSetPropertyNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireSetPropertyNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireSetPropertyNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireSetPropertyNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireSetPropertyNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSetPropertyNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSetPropertyNextsCreateFieldInput>>;
};

export type QuestionnaireSetPropertyNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireSetPropertyNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireSetPropertyNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireSetPropertyNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireSetPropertyNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireSetPropertyNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSetPropertyNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSetPropertyNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireSetPropertyNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireSetPropertyNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireSetPropertyNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireSetPropertyOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireSetPropertySort objects to sort QuestionnaireSetProperties by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireSetPropertySort>>;
};

export type QuestionnaireSetPropertyPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireSetPropertyPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireSetPropertyPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireSetPropertyPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireSetPropertyPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireSetPropertyPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireSetPropertyPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireSetPropertyPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSetPropertyPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSetPropertyPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSetPropertyPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSetPropertyPrevsCreateFieldInput>>;
};

export type QuestionnaireSetPropertyPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireSetPropertyPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireSetPropertyPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireSetPropertyPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireSetPropertyPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireSetPropertyPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSetPropertyPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSetPropertyPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireSetPropertyPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireSetPropertyPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireSetPropertyPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSetPropertyQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireSetPropertyQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireSetPropertyQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireSetPropertyQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireSetPropertyQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireSetPropertyQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireSetPropertyQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireSetPropertyQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireSetPropertyQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireSetPropertyQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireSetPropertyQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireSetPropertyQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireSetPropertyQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireSetPropertyQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireSetPropertyQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireSetPropertyQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireSetPropertyRelationInput = {
  graph?: InputMaybe<QuestionnaireSetPropertyGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSetPropertyNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSetPropertyPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireSetProperties by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireSetPropertySort object. */
export type QuestionnaireSetPropertySort = {
  field?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  value?: InputMaybe<SortDirection>;
};

export type QuestionnaireSetPropertyUpdateInput = {
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<QuestionnaireSetPropertyGraphUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireSetPropertyNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSetPropertyPrevsUpdateFieldInput>>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireSetPropertyVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireSetPropertyVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireSetPropertyVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireSetPropertyVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireSetPropertyVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireSetPropertyWhere = {
  AND?: InputMaybe<Array<QuestionnaireSetPropertyWhere>>;
  NOT?: InputMaybe<QuestionnaireSetPropertyWhere>;
  OR?: InputMaybe<Array<QuestionnaireSetPropertyWhere>>;
  field?: InputMaybe<Scalars['String']['input']>;
  field_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  field_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  field_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  field_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireSetPropertyGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireSetPropertyNextsAggregateInput>;
  /** Return QuestionnaireSetProperties where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSetProperties where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSetProperties where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSetProperties where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSetProperties where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSetProperties where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSetProperties where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSetProperties where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireSetPropertyPrevsAggregateInput>;
  /** Return QuestionnaireSetProperties where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSetProperties where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSetProperties where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSetProperties where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSetProperties where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSetProperties where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSetProperties where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSetProperties where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  value?: InputMaybe<Scalars['String']['input']>;
  value_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  value_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  value_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  value_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

/** Fields to sort Questionnaires by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireSort object. */
export type QuestionnaireSort = {
  id?: InputMaybe<SortDirection>;
  latest?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  nameNormalized?: InputMaybe<SortDirection>;
};

export type QuestionnaireStep = {
  graph: VersionnedGraph;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type QuestionnaireStepGraphArgs = {
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireStepGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireStepNextsArgs = {
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireStepNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireStepPrevsArgs = {
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireStepPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireStepAggregateSelection = {
  __typename?: 'QuestionnaireStepAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireStepConnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireStepNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireStepPrevsConnectFieldInput>>;
};

export type QuestionnaireStepConnectWhere = {
  node: QuestionnaireStepWhere;
};

export type QuestionnaireStepCreateInput = {
  CheckboxQuestion?: InputMaybe<CheckboxQuestionCreateInput>;
  DateQuestion?: InputMaybe<DateQuestionCreateInput>;
  QuestionnaireAi?: InputMaybe<QuestionnaireAiCreateInput>;
  QuestionnaireAppointmentDate?: InputMaybe<QuestionnaireAppointmentDateCreateInput>;
  QuestionnaireCondition?: InputMaybe<QuestionnaireConditionCreateInput>;
  QuestionnaireDocument?: InputMaybe<QuestionnaireDocumentCreateInput>;
  QuestionnaireDocumentFiller?: InputMaybe<QuestionnaireDocumentFillerCreateInput>;
  QuestionnaireIdentity?: InputMaybe<QuestionnaireIdentityCreateInput>;
  QuestionnaireInfoStep?: InputMaybe<QuestionnaireInfoStepCreateInput>;
  QuestionnaireInterview?: InputMaybe<QuestionnaireInterviewCreateInput>;
  QuestionnaireMenu?: InputMaybe<QuestionnaireMenuCreateInput>;
  QuestionnaireRouter?: InputMaybe<QuestionnaireRouterCreateInput>;
  QuestionnaireSelectMenu?: InputMaybe<QuestionnaireSelectMenuCreateInput>;
  QuestionnaireSetProperty?: InputMaybe<QuestionnaireSetPropertyCreateInput>;
  QuestionnaireSurvey?: InputMaybe<QuestionnaireSurveyCreateInput>;
  QuestionnaireThirdParty?: InputMaybe<QuestionnaireThirdPartyCreateInput>;
  QuestionnaireWelcomeStep?: InputMaybe<QuestionnaireWelcomeStepCreateInput>;
  RadioQuestion?: InputMaybe<RadioQuestionCreateInput>;
  RangeQuestion?: InputMaybe<RangeQuestionCreateInput>;
  SelectQuestion?: InputMaybe<SelectQuestionCreateInput>;
  TextQuestion?: InputMaybe<TextQuestionCreateInput>;
};

export type QuestionnaireStepDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireStepNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireStepPrevsDeleteFieldInput>>;
};

export type QuestionnaireStepDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireStepNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireStepPrevsDisconnectFieldInput>>;
};

export type QuestionnaireStepEdge = {
  __typename?: 'QuestionnaireStepEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireStep;
};

export type QuestionnaireStepGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireStepGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireStepGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireStepGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireStepGraphNodeAggregationWhereInput>;
};

export type QuestionnaireStepGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireStepGraphConnection = {
  __typename?: 'QuestionnaireStepGraphConnection';
  edges: Array<QuestionnaireStepGraphRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireStepGraphConnectionSort = {
  node?: InputMaybe<VersionnedGraphSort>;
};

export type QuestionnaireStepGraphConnectionWhere = {
  AND?: InputMaybe<Array<QuestionnaireStepGraphConnectionWhere>>;
  NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  OR?: InputMaybe<Array<QuestionnaireStepGraphConnectionWhere>>;
  node?: InputMaybe<VersionnedGraphWhere>;
};

export type QuestionnaireStepGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireStepGraphDeleteFieldInput = {
  delete?: InputMaybe<VersionnedGraphDeleteInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireStepGraphDisconnectFieldInput = {
  disconnect?: InputMaybe<VersionnedGraphDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireStepGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireStepGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireStepGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireStepGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireStepGraphRelationship = {
  __typename?: 'QuestionnaireStepGraphRelationship';
  cursor: Scalars['String']['output'];
  node: VersionnedGraph;
};

export type QuestionnaireStepGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireStepGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireStepGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireStepGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireStepGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export enum QuestionnaireStepImplementation {
  CheckboxQuestion = 'CheckboxQuestion',
  DateQuestion = 'DateQuestion',
  QuestionnaireAi = 'QuestionnaireAi',
  QuestionnaireAppointmentDate = 'QuestionnaireAppointmentDate',
  QuestionnaireCondition = 'QuestionnaireCondition',
  QuestionnaireDocument = 'QuestionnaireDocument',
  QuestionnaireDocumentFiller = 'QuestionnaireDocumentFiller',
  QuestionnaireIdentity = 'QuestionnaireIdentity',
  QuestionnaireInfoStep = 'QuestionnaireInfoStep',
  QuestionnaireInterview = 'QuestionnaireInterview',
  QuestionnaireMenu = 'QuestionnaireMenu',
  QuestionnaireRouter = 'QuestionnaireRouter',
  QuestionnaireSelectMenu = 'QuestionnaireSelectMenu',
  QuestionnaireSetProperty = 'QuestionnaireSetProperty',
  QuestionnaireSurvey = 'QuestionnaireSurvey',
  QuestionnaireThirdParty = 'QuestionnaireThirdParty',
  QuestionnaireWelcomeStep = 'QuestionnaireWelcomeStep',
  RadioQuestion = 'RadioQuestion',
  RangeQuestion = 'RangeQuestion',
  SelectQuestion = 'SelectQuestion',
  TextQuestion = 'TextQuestion'
}

export type QuestionnaireStepNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireStepNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireStepNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireStepNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<QuestionnaireStepNextsEdgeAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireStepNextsNodeAggregationWhereInput>;
};

export type QuestionnaireStepNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<QuestionnaireStepNextsEdgeCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireStepNextsConnection = {
  __typename?: 'QuestionnaireStepNextsConnection';
  edges: Array<QuestionnaireStepNextsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireStepNextsConnectionSort = {
  edge?: InputMaybe<QuestionNextsEdgeSort>;
  node?: InputMaybe<QuestionnaireStepSort>;
};

export type QuestionnaireStepNextsConnectionWhere = {
  AND?: InputMaybe<Array<QuestionnaireStepNextsConnectionWhere>>;
  NOT?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  OR?: InputMaybe<Array<QuestionnaireStepNextsConnectionWhere>>;
  edge?: InputMaybe<QuestionNextsEdgeWhere>;
  node?: InputMaybe<QuestionnaireStepWhere>;
};

export type QuestionnaireStepNextsCreateFieldInput = {
  edge?: InputMaybe<QuestionnaireStepNextsEdgeCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireStepNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireStepNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireStepNextsEdgeAggregationWhereInput = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   * * QuestionnaireWelcomeStep
   * * QuestionnaireInfoStep
   * * QuestionnaireCondition
   * * QuestionnaireAppointmentDate
   * * QuestionnaireDocument
   * * QuestionnaireIdentity
   * * QuestionnaireRouter
   * * QuestionnaireMenu
   * * QuestionnaireInterview
   * * QuestionnaireSelectMenu
   * * QuestionnaireSurvey
   * * QuestionnaireThirdParty
   * * QuestionnaireSetProperty
   * * QuestionnaireDocumentFiller
   * * QuestionnaireAi
   */
  Socket?: InputMaybe<SocketAggregationWhereInput>;
};

export type QuestionnaireStepNextsEdgeCreateInput = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   * * QuestionnaireWelcomeStep
   * * QuestionnaireInfoStep
   * * QuestionnaireCondition
   * * QuestionnaireAppointmentDate
   * * QuestionnaireDocument
   * * QuestionnaireIdentity
   * * QuestionnaireRouter
   * * QuestionnaireMenu
   * * QuestionnaireInterview
   * * QuestionnaireSelectMenu
   * * QuestionnaireSurvey
   * * QuestionnaireThirdParty
   * * QuestionnaireSetProperty
   * * QuestionnaireDocumentFiller
   * * QuestionnaireAi
   */
  Socket?: InputMaybe<SocketCreateInput>;
};

export type QuestionnaireStepNextsEdgeUpdateInput = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   * * QuestionnaireWelcomeStep
   * * QuestionnaireInfoStep
   * * QuestionnaireCondition
   * * QuestionnaireAppointmentDate
   * * QuestionnaireDocument
   * * QuestionnaireIdentity
   * * QuestionnaireRouter
   * * QuestionnaireMenu
   * * QuestionnaireInterview
   * * QuestionnaireSelectMenu
   * * QuestionnaireSurvey
   * * QuestionnaireThirdParty
   * * QuestionnaireSetProperty
   * * QuestionnaireDocumentFiller
   * * QuestionnaireAi
   */
  Socket?: InputMaybe<SocketUpdateInput>;
};

export type QuestionnaireStepNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireStepNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireStepNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireStepNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireStepNextsRelationship = {
  __typename?: 'QuestionnaireStepNextsRelationship';
  cursor: Scalars['String']['output'];
  node: QuestionnaireStep;
  properties: QuestionnaireStepNextsRelationshipProperties;
};

export type QuestionnaireStepNextsRelationshipProperties = Socket;

export type QuestionnaireStepNextsUpdateConnectionInput = {
  edge?: InputMaybe<QuestionnaireStepNextsEdgeUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireStepNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireStepNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireStepNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireStepNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireStepNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireStepNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireStepOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireStepSort objects to sort QuestionnaireSteps by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<InputMaybe<QuestionnaireStepSort>>>;
};

export type QuestionnaireStepPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireStepPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireStepPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireStepPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<QuestionnaireStepPrevsEdgeAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireStepPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireStepPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<QuestionnaireStepPrevsEdgeCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireStepPrevsConnection = {
  __typename?: 'QuestionnaireStepPrevsConnection';
  edges: Array<QuestionnaireStepPrevsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireStepPrevsConnectionSort = {
  edge?: InputMaybe<QuestionPrevsEdgeSort>;
  node?: InputMaybe<QuestionnaireStepSort>;
};

export type QuestionnaireStepPrevsConnectionWhere = {
  AND?: InputMaybe<Array<QuestionnaireStepPrevsConnectionWhere>>;
  NOT?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  OR?: InputMaybe<Array<QuestionnaireStepPrevsConnectionWhere>>;
  edge?: InputMaybe<QuestionPrevsEdgeWhere>;
  node?: InputMaybe<QuestionnaireStepWhere>;
};

export type QuestionnaireStepPrevsCreateFieldInput = {
  edge?: InputMaybe<QuestionnaireStepPrevsEdgeCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireStepPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireStepPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireStepPrevsEdgeAggregationWhereInput = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   * * QuestionnaireWelcomeStep
   * * QuestionnaireInfoStep
   * * QuestionnaireCondition
   * * QuestionnaireAppointmentDate
   * * QuestionnaireDocument
   * * QuestionnaireIdentity
   * * QuestionnaireRouter
   * * QuestionnaireMenu
   * * QuestionnaireInterview
   * * QuestionnaireSelectMenu
   * * QuestionnaireSurvey
   * * QuestionnaireThirdParty
   * * QuestionnaireSetProperty
   * * QuestionnaireDocumentFiller
   * * QuestionnaireAi
   */
  Socket?: InputMaybe<SocketAggregationWhereInput>;
};

export type QuestionnaireStepPrevsEdgeCreateInput = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   * * QuestionnaireWelcomeStep
   * * QuestionnaireInfoStep
   * * QuestionnaireCondition
   * * QuestionnaireAppointmentDate
   * * QuestionnaireDocument
   * * QuestionnaireIdentity
   * * QuestionnaireRouter
   * * QuestionnaireMenu
   * * QuestionnaireInterview
   * * QuestionnaireSelectMenu
   * * QuestionnaireSurvey
   * * QuestionnaireThirdParty
   * * QuestionnaireSetProperty
   * * QuestionnaireDocumentFiller
   * * QuestionnaireAi
   */
  Socket?: InputMaybe<SocketCreateInput>;
};

export type QuestionnaireStepPrevsEdgeUpdateInput = {
  /**
   * Relationship properties when source node is of type:
   * * TextQuestion
   * * SelectQuestion
   * * RangeQuestion
   * * CheckboxQuestion
   * * RadioQuestion
   * * DateQuestion
   * * QuestionnaireWelcomeStep
   * * QuestionnaireInfoStep
   * * QuestionnaireCondition
   * * QuestionnaireAppointmentDate
   * * QuestionnaireDocument
   * * QuestionnaireIdentity
   * * QuestionnaireRouter
   * * QuestionnaireMenu
   * * QuestionnaireInterview
   * * QuestionnaireSelectMenu
   * * QuestionnaireSurvey
   * * QuestionnaireThirdParty
   * * QuestionnaireSetProperty
   * * QuestionnaireDocumentFiller
   * * QuestionnaireAi
   */
  Socket?: InputMaybe<SocketUpdateInput>;
};

export type QuestionnaireStepPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireStepPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireStepPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireStepPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireStepPrevsRelationship = {
  __typename?: 'QuestionnaireStepPrevsRelationship';
  cursor: Scalars['String']['output'];
  node: QuestionnaireStep;
  properties: QuestionnaireStepPrevsRelationshipProperties;
};

export type QuestionnaireStepPrevsRelationshipProperties = Socket;

export type QuestionnaireStepPrevsUpdateConnectionInput = {
  edge?: InputMaybe<QuestionnaireStepPrevsEdgeUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireStepPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireStepPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireStepPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireStepPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireStepPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireStepPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

/** Fields to sort QuestionnaireSteps by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireStepSort object. */
export type QuestionnaireStepSort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type QuestionnaireStepUpdateInput = {
  graph?: InputMaybe<QuestionnaireStepGraphUpdateFieldInput>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nexts?: InputMaybe<Array<QuestionnaireStepNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireStepPrevsUpdateFieldInput>>;
};

export type QuestionnaireStepWhere = {
  AND?: InputMaybe<Array<QuestionnaireStepWhere>>;
  NOT?: InputMaybe<QuestionnaireStepWhere>;
  OR?: InputMaybe<Array<QuestionnaireStepWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireStepGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireStepNextsAggregateInput>;
  /** Return QuestionnaireSteps where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSteps where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSteps where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSteps where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSteps where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSteps where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSteps where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSteps where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireStepPrevsAggregateInput>;
  /** Return QuestionnaireSteps where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSteps where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSteps where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSteps where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSteps where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSteps where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSteps where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSteps where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  typename_IN?: InputMaybe<Array<QuestionnaireStepImplementation>>;
};

export type QuestionnaireStepsConnection = {
  __typename?: 'QuestionnaireStepsConnection';
  edges: Array<QuestionnaireStepEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireSurvey = QuestionnaireStep & {
  __typename?: 'QuestionnaireSurvey';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireSurveyVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireSurveyQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireSurveyQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type QuestionnaireSurveyGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireSurveyGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireSurveyGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireSurveyNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSurveyNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSurveyNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireSurveyPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSurveyPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireSurveyPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSurveyAggregateSelection = {
  __typename?: 'QuestionnaireSurveyAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireSurveyConnectInput = {
  graph?: InputMaybe<QuestionnaireSurveyGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSurveyNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSurveyPrevsConnectFieldInput>>;
};

export type QuestionnaireSurveyCreateInput = {
  graph?: InputMaybe<QuestionnaireSurveyGraphFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireSurveyNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireSurveyPrevsFieldInput>;
};

export type QuestionnaireSurveyDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSurveyNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSurveyPrevsDeleteFieldInput>>;
};

export type QuestionnaireSurveyDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSurveyNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSurveyPrevsDisconnectFieldInput>>;
};

export type QuestionnaireSurveyEdge = {
  __typename?: 'QuestionnaireSurveyEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireSurvey;
};

export type QuestionnaireSurveyGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireSurveyGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireSurveyGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireSurveyGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireSurveyGraphNodeAggregationWhereInput>;
};

export type QuestionnaireSurveyGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireSurveyGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireSurveyGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireSurveyGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireSurveyGraphCreateFieldInput>;
};

export type QuestionnaireSurveyGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireSurveyGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireSurveyGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireSurveyGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireSurveyGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireSurveyGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireSurveyGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireSurveyGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireSurveyGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireSurveyNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireSurveyNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireSurveyNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireSurveyNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireSurveyNextsNodeAggregationWhereInput>;
};

export type QuestionnaireSurveyNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireSurveyNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireSurveyNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireSurveyNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireSurveyNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSurveyNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSurveyNextsCreateFieldInput>>;
};

export type QuestionnaireSurveyNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireSurveyNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireSurveyNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireSurveyNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireSurveyNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireSurveyNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSurveyNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSurveyNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireSurveyNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireSurveyNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireSurveyNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireSurveyOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireSurveySort objects to sort QuestionnaireSurveys by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireSurveySort>>;
};

export type QuestionnaireSurveyPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireSurveyPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireSurveyPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireSurveyPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireSurveyPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireSurveyPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireSurveyPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireSurveyPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSurveyPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSurveyPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSurveyPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSurveyPrevsCreateFieldInput>>;
};

export type QuestionnaireSurveyPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireSurveyPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireSurveyPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireSurveyPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireSurveyPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireSurveyPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireSurveyPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireSurveyPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireSurveyPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireSurveyPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireSurveyPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireSurveyQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireSurveyQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireSurveyQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireSurveyQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireSurveyQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireSurveyQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireSurveyQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireSurveyQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireSurveyQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireSurveyQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireSurveyQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireSurveyQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireSurveyQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireSurveyQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireSurveyQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireSurveyQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireSurveyRelationInput = {
  graph?: InputMaybe<QuestionnaireSurveyGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireSurveyNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSurveyPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireSurveys by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireSurveySort object. */
export type QuestionnaireSurveySort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type QuestionnaireSurveyUpdateInput = {
  graph?: InputMaybe<QuestionnaireSurveyGraphUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireSurveyNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireSurveyPrevsUpdateFieldInput>>;
};

export type QuestionnaireSurveyVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireSurveyVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireSurveyVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireSurveyVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireSurveyVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireSurveyWhere = {
  AND?: InputMaybe<Array<QuestionnaireSurveyWhere>>;
  NOT?: InputMaybe<QuestionnaireSurveyWhere>;
  OR?: InputMaybe<Array<QuestionnaireSurveyWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireSurveyGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireSurveyNextsAggregateInput>;
  /** Return QuestionnaireSurveys where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSurveys where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSurveys where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSurveys where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireSurveys where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSurveys where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSurveys where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSurveys where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireSurveyPrevsAggregateInput>;
  /** Return QuestionnaireSurveys where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSurveys where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSurveys where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSurveys where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireSurveys where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSurveys where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSurveys where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireSurveys where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type QuestionnaireSurveysConnection = {
  __typename?: 'QuestionnaireSurveysConnection';
  edges: Array<QuestionnaireSurveyEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireThirdPartiesConnection = {
  __typename?: 'QuestionnaireThirdPartiesConnection';
  edges: Array<QuestionnaireThirdPartyEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireThirdParty = QuestionnaireStep & {
  __typename?: 'QuestionnaireThirdParty';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireThirdPartyVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireThirdPartyQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireThirdPartyQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type QuestionnaireThirdPartyGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireThirdPartyGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireThirdPartyGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireThirdPartyNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireThirdPartyNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireThirdPartyNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireThirdPartyPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireThirdPartyPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireThirdPartyPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireThirdPartyAggregateSelection = {
  __typename?: 'QuestionnaireThirdPartyAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireThirdPartyConnectInput = {
  graph?: InputMaybe<QuestionnaireThirdPartyGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireThirdPartyNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireThirdPartyPrevsConnectFieldInput>>;
};

export type QuestionnaireThirdPartyCreateInput = {
  graph?: InputMaybe<QuestionnaireThirdPartyGraphFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireThirdPartyNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireThirdPartyPrevsFieldInput>;
};

export type QuestionnaireThirdPartyDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireThirdPartyNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireThirdPartyPrevsDeleteFieldInput>>;
};

export type QuestionnaireThirdPartyDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireThirdPartyNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireThirdPartyPrevsDisconnectFieldInput>>;
};

export type QuestionnaireThirdPartyEdge = {
  __typename?: 'QuestionnaireThirdPartyEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireThirdParty;
};

export type QuestionnaireThirdPartyGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireThirdPartyGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireThirdPartyGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireThirdPartyGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireThirdPartyGraphNodeAggregationWhereInput>;
};

export type QuestionnaireThirdPartyGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireThirdPartyGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireThirdPartyGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireThirdPartyGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireThirdPartyGraphCreateFieldInput>;
};

export type QuestionnaireThirdPartyGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireThirdPartyGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireThirdPartyGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireThirdPartyGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireThirdPartyGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireThirdPartyGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireThirdPartyGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireThirdPartyGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireThirdPartyGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireThirdPartyNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireThirdPartyNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireThirdPartyNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireThirdPartyNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireThirdPartyNextsNodeAggregationWhereInput>;
};

export type QuestionnaireThirdPartyNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireThirdPartyNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireThirdPartyNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireThirdPartyNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireThirdPartyNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireThirdPartyNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireThirdPartyNextsCreateFieldInput>>;
};

export type QuestionnaireThirdPartyNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireThirdPartyNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireThirdPartyNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireThirdPartyNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireThirdPartyNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireThirdPartyNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireThirdPartyNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireThirdPartyNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireThirdPartyNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireThirdPartyNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireThirdPartyNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireThirdPartyOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireThirdPartySort objects to sort QuestionnaireThirdParties by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireThirdPartySort>>;
};

export type QuestionnaireThirdPartyPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireThirdPartyPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireThirdPartyPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireThirdPartyPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireThirdPartyPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireThirdPartyPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireThirdPartyPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireThirdPartyPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireThirdPartyPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireThirdPartyPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireThirdPartyPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireThirdPartyPrevsCreateFieldInput>>;
};

export type QuestionnaireThirdPartyPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireThirdPartyPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireThirdPartyPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireThirdPartyPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireThirdPartyPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireThirdPartyPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireThirdPartyPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireThirdPartyPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireThirdPartyPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireThirdPartyPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireThirdPartyPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireThirdPartyQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireThirdPartyQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireThirdPartyQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireThirdPartyQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireThirdPartyQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireThirdPartyQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireThirdPartyQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireThirdPartyQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireThirdPartyQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireThirdPartyQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireThirdPartyQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireThirdPartyQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireThirdPartyQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireThirdPartyQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireThirdPartyQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireThirdPartyQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireThirdPartyRelationInput = {
  graph?: InputMaybe<QuestionnaireThirdPartyGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireThirdPartyNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireThirdPartyPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireThirdParties by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireThirdPartySort object. */
export type QuestionnaireThirdPartySort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type QuestionnaireThirdPartyUpdateInput = {
  graph?: InputMaybe<QuestionnaireThirdPartyGraphUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireThirdPartyNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireThirdPartyPrevsUpdateFieldInput>>;
};

export type QuestionnaireThirdPartyVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireThirdPartyVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireThirdPartyVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireThirdPartyVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireThirdPartyVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireThirdPartyWhere = {
  AND?: InputMaybe<Array<QuestionnaireThirdPartyWhere>>;
  NOT?: InputMaybe<QuestionnaireThirdPartyWhere>;
  OR?: InputMaybe<Array<QuestionnaireThirdPartyWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireThirdPartyGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireThirdPartyNextsAggregateInput>;
  /** Return QuestionnaireThirdParties where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireThirdParties where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireThirdParties where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireThirdParties where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireThirdParties where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireThirdParties where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireThirdParties where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireThirdParties where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireThirdPartyPrevsAggregateInput>;
  /** Return QuestionnaireThirdParties where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireThirdParties where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireThirdParties where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireThirdParties where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireThirdParties where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireThirdParties where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireThirdParties where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireThirdParties where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export enum QuestionnaireType {
  AiNode = 'AiNode',
  AppointmentNode = 'AppointmentNode',
  CheckboxNode = 'CheckboxNode',
  ConditionalNode = 'ConditionalNode',
  DateNode = 'DateNode',
  DocumentFillerNode = 'DocumentFillerNode',
  DocumentNode = 'DocumentNode',
  IdentityNode = 'IdentityNode',
  InfoNode = 'InfoNode',
  InterviewNode = 'InterviewNode',
  MenuNode = 'MenuNode',
  RadioNode = 'RadioNode',
  RangeNode = 'RangeNode',
  RouterNode = 'RouterNode',
  SelectMenuNode = 'SelectMenuNode',
  SelectNode = 'SelectNode',
  SetPropertyNode = 'SetPropertyNode',
  SurveyNode = 'SurveyNode',
  TextInputNode = 'TextInputNode',
  ThirdPartyNode = 'ThirdPartyNode',
  WelcomeNode = 'WelcomeNode'
}

export type QuestionnaireUniqueWhere = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireUpdateInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<QuestionnaireOwnerUpdateInput>;
  versions?: InputMaybe<Array<QuestionnaireVersionsUpdateFieldInput>>;
};

export type QuestionnaireVersionnedGraphVersionsAggregationSelection = {
  __typename?: 'QuestionnaireVersionnedGraphVersionsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireVersionnedGraphVersionsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireVersionnedGraphVersionsNodeAggregateSelection>;
};

export type QuestionnaireVersionnedGraphVersionsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireVersionnedGraphVersionsEdgeAggregateSelection';
  version: IntAggregateSelection;
};

export type QuestionnaireVersionnedGraphVersionsNodeAggregateSelection = {
  __typename?: 'QuestionnaireVersionnedGraphVersionsNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireVersionsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireVersionsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireVersionsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireVersionsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<VersionnedRelationAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireVersionsNodeAggregationWhereInput>;
};

export type QuestionnaireVersionsConnectFieldInput = {
  connect?: InputMaybe<Array<VersionnedGraphConnectInput>>;
  edge: VersionnedRelationCreateInput;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireVersionsCreateFieldInput = {
  edge: VersionnedRelationCreateInput;
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireVersionsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireVersionsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireVersionsCreateFieldInput>>;
};

export type QuestionnaireVersionsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireVersionsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireVersionsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireVersionsNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireVersionsUpdateConnectionInput = {
  edge?: InputMaybe<VersionnedRelationUpdateInput>;
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireVersionsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireVersionsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireVersionsCreateFieldInput>>;
  delete?: InputMaybe<Array<BaseQuestionnaireVersionsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<BaseQuestionnaireVersionsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireVersionsUpdateConnectionInput>;
  where?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
};

export type QuestionnaireWelcomeStep = QuestionnaireStep & {
  __typename?: 'QuestionnaireWelcomeStep';
  graph: VersionnedGraph;
  graphAggregate?: Maybe<QuestionnaireWelcomeStepVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<QuestionnaireWelcomeStepQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<QuestionnaireWelcomeStepQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
  text?: Maybe<Scalars['String']['output']>;
};


export type QuestionnaireWelcomeStepGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireWelcomeStepGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuestionnaireWelcomeStepGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type QuestionnaireWelcomeStepNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireWelcomeStepNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireWelcomeStepNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type QuestionnaireWelcomeStepPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireWelcomeStepPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type QuestionnaireWelcomeStepPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireWelcomeStepAggregateSelection = {
  __typename?: 'QuestionnaireWelcomeStepAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  text: StringAggregateSelection;
};

export type QuestionnaireWelcomeStepConnectInput = {
  graph?: InputMaybe<QuestionnaireWelcomeStepGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireWelcomeStepNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsConnectFieldInput>>;
};

export type QuestionnaireWelcomeStepCreateInput = {
  graph?: InputMaybe<QuestionnaireWelcomeStepGraphFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<QuestionnaireWelcomeStepNextsFieldInput>;
  prevs?: InputMaybe<QuestionnaireWelcomeStepPrevsFieldInput>;
  text?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireWelcomeStepDeleteInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireWelcomeStepNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsDeleteFieldInput>>;
};

export type QuestionnaireWelcomeStepDisconnectInput = {
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireWelcomeStepNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsDisconnectFieldInput>>;
};

export type QuestionnaireWelcomeStepEdge = {
  __typename?: 'QuestionnaireWelcomeStepEdge';
  cursor: Scalars['String']['output'];
  node: QuestionnaireWelcomeStep;
};

export type QuestionnaireWelcomeStepGraphAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireWelcomeStepGraphAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireWelcomeStepGraphAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireWelcomeStepGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuestionnaireWelcomeStepGraphNodeAggregationWhereInput>;
};

export type QuestionnaireWelcomeStepGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuestionnaireWelcomeStepGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuestionnaireWelcomeStepGraphFieldInput = {
  connect?: InputMaybe<QuestionnaireWelcomeStepGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireWelcomeStepGraphCreateFieldInput>;
};

export type QuestionnaireWelcomeStepGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireWelcomeStepGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireWelcomeStepGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireWelcomeStepGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuestionnaireWelcomeStepGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuestionnaireWelcomeStepGraphUpdateFieldInput = {
  connect?: InputMaybe<QuestionnaireWelcomeStepGraphConnectFieldInput>;
  create?: InputMaybe<QuestionnaireWelcomeStepGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<QuestionnaireWelcomeStepGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type QuestionnaireWelcomeStepNextsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireWelcomeStepNextsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireWelcomeStepNextsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireWelcomeStepNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireWelcomeStepNextsNodeAggregationWhereInput>;
};

export type QuestionnaireWelcomeStepNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireWelcomeStepNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireWelcomeStepNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireWelcomeStepNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireWelcomeStepNextsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireWelcomeStepNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireWelcomeStepNextsCreateFieldInput>>;
};

export type QuestionnaireWelcomeStepNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireWelcomeStepNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireWelcomeStepNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireWelcomeStepNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireWelcomeStepNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireWelcomeStepNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireWelcomeStepNextsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireWelcomeStepNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireWelcomeStepNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireWelcomeStepNextsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireWelcomeStepNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type QuestionnaireWelcomeStepOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuestionnaireWelcomeStepSort objects to sort QuestionnaireWelcomeSteps by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuestionnaireWelcomeStepSort>>;
};

export type QuestionnaireWelcomeStepPrevsAggregateInput = {
  AND?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsAggregateInput>>;
  NOT?: InputMaybe<QuestionnaireWelcomeStepPrevsAggregateInput>;
  OR?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<QuestionnaireWelcomeStepPrevsNodeAggregationWhereInput>;
};

export type QuestionnaireWelcomeStepPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type QuestionnaireWelcomeStepPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type QuestionnaireWelcomeStepPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireWelcomeStepPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireWelcomeStepPrevsFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsCreateFieldInput>>;
};

export type QuestionnaireWelcomeStepPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuestionnaireWelcomeStepPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type QuestionnaireWelcomeStepPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type QuestionnaireWelcomeStepPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsDisconnectFieldInput>>;
  update?: InputMaybe<QuestionnaireWelcomeStepPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type QuestionnaireWelcomeStepQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'QuestionnaireWelcomeStepQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireWelcomeStepQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireWelcomeStepQuestionnaireStepNextsNodeAggregateSelection>;
};

export type QuestionnaireWelcomeStepQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireWelcomeStepQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireWelcomeStepQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'QuestionnaireWelcomeStepQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireWelcomeStepQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'QuestionnaireWelcomeStepQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<QuestionnaireWelcomeStepQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<QuestionnaireWelcomeStepQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type QuestionnaireWelcomeStepQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'QuestionnaireWelcomeStepQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type QuestionnaireWelcomeStepQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'QuestionnaireWelcomeStepQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type QuestionnaireWelcomeStepRelationInput = {
  graph?: InputMaybe<QuestionnaireWelcomeStepGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<QuestionnaireWelcomeStepNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsCreateFieldInput>>;
};

/** Fields to sort QuestionnaireWelcomeSteps by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuestionnaireWelcomeStepSort object. */
export type QuestionnaireWelcomeStepSort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  text?: InputMaybe<SortDirection>;
};

export type QuestionnaireWelcomeStepUpdateInput = {
  graph?: InputMaybe<QuestionnaireWelcomeStepGraphUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<QuestionnaireWelcomeStepNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<QuestionnaireWelcomeStepPrevsUpdateFieldInput>>;
  text?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireWelcomeStepVersionnedGraphGraphAggregationSelection = {
  __typename?: 'QuestionnaireWelcomeStepVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuestionnaireWelcomeStepVersionnedGraphGraphNodeAggregateSelection>;
};

export type QuestionnaireWelcomeStepVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'QuestionnaireWelcomeStepVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuestionnaireWelcomeStepWhere = {
  AND?: InputMaybe<Array<QuestionnaireWelcomeStepWhere>>;
  NOT?: InputMaybe<QuestionnaireWelcomeStepWhere>;
  OR?: InputMaybe<Array<QuestionnaireWelcomeStepWhere>>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<QuestionnaireWelcomeStepGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<QuestionnaireWelcomeStepNextsAggregateInput>;
  /** Return QuestionnaireWelcomeSteps where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireWelcomeSteps where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireWelcomeSteps where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireWelcomeSteps where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return QuestionnaireWelcomeSteps where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireWelcomeSteps where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireWelcomeSteps where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireWelcomeSteps where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<QuestionnaireWelcomeStepPrevsAggregateInput>;
  /** Return QuestionnaireWelcomeSteps where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireWelcomeSteps where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireWelcomeSteps where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireWelcomeSteps where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return QuestionnaireWelcomeSteps where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireWelcomeSteps where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireWelcomeSteps where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return QuestionnaireWelcomeSteps where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
  text?: InputMaybe<Scalars['String']['input']>;
  text_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  text_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  text_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  text_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type QuestionnaireWelcomeStepsConnection = {
  __typename?: 'QuestionnaireWelcomeStepsConnection';
  edges: Array<QuestionnaireWelcomeStepEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionnaireWhere = {
  AND?: InputMaybe<Array<QuestionnaireWhere>>;
  NOT?: InputMaybe<QuestionnaireWhere>;
  OR?: InputMaybe<Array<QuestionnaireWhere>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  latest?: InputMaybe<VersionnedGraphWhere>;
  name?: InputMaybe<Scalars['String']['input']>;
  nameNormalized?: InputMaybe<Scalars['String']['input']>;
  nameNormalized_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  nameNormalized_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  nameNormalized_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  nameNormalized_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<OwnerWhere>;
  ownerConnection?: InputMaybe<BaseQuestionnaireOwnerConnectionWhere>;
  ownerConnection_NOT?: InputMaybe<BaseQuestionnaireOwnerConnectionWhere>;
  owner_NOT?: InputMaybe<OwnerWhere>;
  versionsAggregate?: InputMaybe<QuestionnaireVersionsAggregateInput>;
  /** Return Questionnaires where all of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_ALL?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return Questionnaires where none of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_NONE?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return Questionnaires where one of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_SINGLE?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return Questionnaires where some of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_SOME?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return Questionnaires where all of the related VersionnedGraphs match this filter */
  versions_ALL?: InputMaybe<VersionnedGraphWhere>;
  /** Return Questionnaires where none of the related VersionnedGraphs match this filter */
  versions_NONE?: InputMaybe<VersionnedGraphWhere>;
  /** Return Questionnaires where one of the related VersionnedGraphs match this filter */
  versions_SINGLE?: InputMaybe<VersionnedGraphWhere>;
  /** Return Questionnaires where some of the related VersionnedGraphs match this filter */
  versions_SOME?: InputMaybe<VersionnedGraphWhere>;
};

export type QuestionnairesConnection = {
  __typename?: 'QuestionnairesConnection';
  edges: Array<QuestionnaireEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuestionsConnection = {
  __typename?: 'QuestionsConnection';
  edges: Array<QuestionEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Quoting = {
  __typename?: 'Quoting';
  amount: Scalars['Float']['output'];
  code: Scalars['String']['output'];
  description: Scalars['String']['output'];
  versionnedGraph: VersionnedGraph;
  versionnedGraphAggregate?: Maybe<QuotingVersionnedGraphVersionnedGraphAggregationSelection>;
  versionnedGraphConnection: QuotingVersionnedGraphConnection;
};


export type QuotingVersionnedGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuotingVersionnedGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type QuotingVersionnedGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuotingVersionnedGraphConnectionSort>>;
  where?: InputMaybe<QuotingVersionnedGraphConnectionWhere>;
};

export type QuotingAggregateSelection = {
  __typename?: 'QuotingAggregateSelection';
  amount: FloatAggregateSelection;
  code: StringAggregateSelection;
  count: Scalars['Int']['output'];
  description: StringAggregateSelection;
};

export type QuotingConnectInput = {
  versionnedGraph?: InputMaybe<QuotingVersionnedGraphConnectFieldInput>;
};

export type QuotingConnectWhere = {
  node: QuotingWhere;
};

export type QuotingCreateInput = {
  amount: Scalars['Float']['input'];
  code: Scalars['String']['input'];
  description: Scalars['String']['input'];
  versionnedGraph?: InputMaybe<QuotingVersionnedGraphFieldInput>;
};

export type QuotingDeleteInput = {
  versionnedGraph?: InputMaybe<QuotingVersionnedGraphDeleteFieldInput>;
};

export type QuotingDisconnectInput = {
  versionnedGraph?: InputMaybe<QuotingVersionnedGraphDisconnectFieldInput>;
};

export type QuotingEdge = {
  __typename?: 'QuotingEdge';
  cursor: Scalars['String']['output'];
  node: Quoting;
};

export type QuotingOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more QuotingSort objects to sort Quotings by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<QuotingSort>>;
};

export type QuotingRelationInput = {
  versionnedGraph?: InputMaybe<QuotingVersionnedGraphCreateFieldInput>;
};

/** Fields to sort Quotings by. The order in which sorts are applied is not guaranteed when specifying many fields in one QuotingSort object. */
export type QuotingSort = {
  amount?: InputMaybe<SortDirection>;
  code?: InputMaybe<SortDirection>;
  description?: InputMaybe<SortDirection>;
};

export type QuotingUpdateInput = {
  amount?: InputMaybe<Scalars['Float']['input']>;
  amount_ADD?: InputMaybe<Scalars['Float']['input']>;
  amount_DIVIDE?: InputMaybe<Scalars['Float']['input']>;
  amount_MULTIPLY?: InputMaybe<Scalars['Float']['input']>;
  amount_SUBTRACT?: InputMaybe<Scalars['Float']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  versionnedGraph?: InputMaybe<QuotingVersionnedGraphUpdateFieldInput>;
};

export type QuotingVersionnedGraphAggregateInput = {
  AND?: InputMaybe<Array<QuotingVersionnedGraphAggregateInput>>;
  NOT?: InputMaybe<QuotingVersionnedGraphAggregateInput>;
  OR?: InputMaybe<Array<QuotingVersionnedGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<QuotingVersionnedGraphNodeAggregationWhereInput>;
};

export type QuotingVersionnedGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type QuotingVersionnedGraphConnection = {
  __typename?: 'QuotingVersionnedGraphConnection';
  edges: Array<QuotingVersionnedGraphRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type QuotingVersionnedGraphConnectionSort = {
  node?: InputMaybe<VersionnedGraphSort>;
};

export type QuotingVersionnedGraphConnectionWhere = {
  AND?: InputMaybe<Array<QuotingVersionnedGraphConnectionWhere>>;
  NOT?: InputMaybe<QuotingVersionnedGraphConnectionWhere>;
  OR?: InputMaybe<Array<QuotingVersionnedGraphConnectionWhere>>;
  node?: InputMaybe<VersionnedGraphWhere>;
};

export type QuotingVersionnedGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type QuotingVersionnedGraphDeleteFieldInput = {
  delete?: InputMaybe<VersionnedGraphDeleteInput>;
  where?: InputMaybe<QuotingVersionnedGraphConnectionWhere>;
};

export type QuotingVersionnedGraphDisconnectFieldInput = {
  disconnect?: InputMaybe<VersionnedGraphDisconnectInput>;
  where?: InputMaybe<QuotingVersionnedGraphConnectionWhere>;
};

export type QuotingVersionnedGraphFieldInput = {
  connect?: InputMaybe<QuotingVersionnedGraphConnectFieldInput>;
  create?: InputMaybe<QuotingVersionnedGraphCreateFieldInput>;
};

export type QuotingVersionnedGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<QuotingVersionnedGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<QuotingVersionnedGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<QuotingVersionnedGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotingVersionnedGraphRelationship = {
  __typename?: 'QuotingVersionnedGraphRelationship';
  cursor: Scalars['String']['output'];
  node: VersionnedGraph;
};

export type QuotingVersionnedGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type QuotingVersionnedGraphUpdateFieldInput = {
  connect?: InputMaybe<QuotingVersionnedGraphConnectFieldInput>;
  create?: InputMaybe<QuotingVersionnedGraphCreateFieldInput>;
  delete?: InputMaybe<QuotingVersionnedGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuotingVersionnedGraphDisconnectFieldInput>;
  update?: InputMaybe<QuotingVersionnedGraphUpdateConnectionInput>;
  where?: InputMaybe<QuotingVersionnedGraphConnectionWhere>;
};

export type QuotingVersionnedGraphVersionnedGraphAggregationSelection = {
  __typename?: 'QuotingVersionnedGraphVersionnedGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<QuotingVersionnedGraphVersionnedGraphNodeAggregateSelection>;
};

export type QuotingVersionnedGraphVersionnedGraphNodeAggregateSelection = {
  __typename?: 'QuotingVersionnedGraphVersionnedGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type QuotingWhere = {
  AND?: InputMaybe<Array<QuotingWhere>>;
  NOT?: InputMaybe<QuotingWhere>;
  OR?: InputMaybe<Array<QuotingWhere>>;
  amount?: InputMaybe<Scalars['Float']['input']>;
  amount_GT?: InputMaybe<Scalars['Float']['input']>;
  amount_GTE?: InputMaybe<Scalars['Float']['input']>;
  amount_IN?: InputMaybe<Array<Scalars['Float']['input']>>;
  amount_LT?: InputMaybe<Scalars['Float']['input']>;
  amount_LTE?: InputMaybe<Scalars['Float']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  code_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  code_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  code_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  code_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  description_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  description_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  description_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  description_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  versionnedGraph?: InputMaybe<VersionnedGraphWhere>;
  versionnedGraphAggregate?: InputMaybe<QuotingVersionnedGraphAggregateInput>;
  versionnedGraphConnection?: InputMaybe<QuotingVersionnedGraphConnectionWhere>;
  versionnedGraphConnection_NOT?: InputMaybe<QuotingVersionnedGraphConnectionWhere>;
  versionnedGraph_NOT?: InputMaybe<VersionnedGraphWhere>;
};

export type QuotingsConnection = {
  __typename?: 'QuotingsConnection';
  edges: Array<QuotingEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type RadioQuestion = Question & QuestionnaireStep & {
  __typename?: 'RadioQuestion';
  alerts?: Maybe<AlertGroup>;
  alertsAggregate?: Maybe<RadioQuestionAlertGroupAlertsAggregationSelection>;
  alertsConnection: QuestionAlertsConnection;
  answers: Array<Answer>;
  answersAggregate?: Maybe<RadioQuestionAnswerAnswersAggregationSelection>;
  answersConnection: QuestionAnswersConnection;
  choices: Array<QuestionItem>;
  choicesAggregate?: Maybe<RadioQuestionQuestionItemChoicesAggregationSelection>;
  choicesConnection: RadioQuestionChoicesConnection;
  cooldown?: Maybe<Cooldown>;
  cooldownAggregate?: Maybe<RadioQuestionCooldownCooldownAggregationSelection>;
  cooldownConnection: RadioQuestionCooldownConnection;
  field?: Maybe<Scalars['String']['output']>;
  graph: VersionnedGraph;
  graphAggregate?: Maybe<RadioQuestionVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  hint?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<RadioQuestionQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<RadioQuestionQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type RadioQuestionAlertsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AlertGroupOptions>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type RadioQuestionAlertsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type RadioQuestionAlertsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};


export type RadioQuestionAnswersArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AnswerOptions>;
  where?: InputMaybe<AnswerWhere>;
};


export type RadioQuestionAnswersAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AnswerWhere>;
};


export type RadioQuestionAnswersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionAnswersConnectionSort>>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};


export type RadioQuestionChoicesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionItemOptions>;
  where?: InputMaybe<QuestionItemWhere>;
};


export type RadioQuestionChoicesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionItemWhere>;
};


export type RadioQuestionChoicesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<RadioQuestionChoicesConnectionSort>>;
  where?: InputMaybe<RadioQuestionChoicesConnectionWhere>;
};


export type RadioQuestionCooldownArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<CooldownOptions>;
  where?: InputMaybe<CooldownWhere>;
};


export type RadioQuestionCooldownAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<CooldownWhere>;
};


export type RadioQuestionCooldownConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<RadioQuestionCooldownConnectionSort>>;
  where?: InputMaybe<RadioQuestionCooldownConnectionWhere>;
};


export type RadioQuestionGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type RadioQuestionGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type RadioQuestionGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type RadioQuestionNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type RadioQuestionNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type RadioQuestionNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type RadioQuestionPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type RadioQuestionPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type RadioQuestionPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type RadioQuestionAggregateSelection = {
  __typename?: 'RadioQuestionAggregateSelection';
  count: Scalars['Int']['output'];
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  id: IdAggregateSelection;
  image: StringAggregateSelection;
  name: StringAggregateSelection;
};

export type RadioQuestionAlertGroupAlertsAggregationSelection = {
  __typename?: 'RadioQuestionAlertGroupAlertsAggregationSelection';
  count: Scalars['Int']['output'];
};

export type RadioQuestionAlertsAggregateInput = {
  AND?: InputMaybe<Array<RadioQuestionAlertsAggregateInput>>;
  NOT?: InputMaybe<RadioQuestionAlertsAggregateInput>;
  OR?: InputMaybe<Array<RadioQuestionAlertsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RadioQuestionAlertsConnectFieldInput = {
  connect?: InputMaybe<AlertGroupConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AlertGroupConnectWhere>;
};

export type RadioQuestionAlertsCreateFieldInput = {
  node: AlertGroupCreateInput;
};

export type RadioQuestionAlertsFieldInput = {
  connect?: InputMaybe<RadioQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<RadioQuestionAlertsCreateFieldInput>;
};

export type RadioQuestionAlertsUpdateConnectionInput = {
  node?: InputMaybe<AlertGroupUpdateInput>;
};

export type RadioQuestionAlertsUpdateFieldInput = {
  connect?: InputMaybe<RadioQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<RadioQuestionAlertsCreateFieldInput>;
  delete?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  update?: InputMaybe<RadioQuestionAlertsUpdateConnectionInput>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};

export type RadioQuestionAnswerAnswersAggregationSelection = {
  __typename?: 'RadioQuestionAnswerAnswersAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<RadioQuestionAnswerAnswersNodeAggregateSelection>;
};

export type RadioQuestionAnswerAnswersNodeAggregateSelection = {
  __typename?: 'RadioQuestionAnswerAnswersNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type RadioQuestionAnswersAggregateInput = {
  AND?: InputMaybe<Array<RadioQuestionAnswersAggregateInput>>;
  NOT?: InputMaybe<RadioQuestionAnswersAggregateInput>;
  OR?: InputMaybe<Array<RadioQuestionAnswersAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<RadioQuestionAnswersNodeAggregationWhereInput>;
};

export type RadioQuestionAnswersConnectFieldInput = {
  connect?: InputMaybe<Array<AnswerConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AnswerConnectWhere>;
};

export type RadioQuestionAnswersCreateFieldInput = {
  node: AnswerCreateInput;
};

export type RadioQuestionAnswersFieldInput = {
  connect?: InputMaybe<Array<RadioQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<RadioQuestionAnswersCreateFieldInput>>;
};

export type RadioQuestionAnswersNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RadioQuestionAnswersNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RadioQuestionAnswersNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RadioQuestionAnswersNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  field_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  field_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  hint_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RadioQuestionAnswersUpdateConnectionInput = {
  node?: InputMaybe<AnswerUpdateInput>;
};

export type RadioQuestionAnswersUpdateFieldInput = {
  connect?: InputMaybe<Array<RadioQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<RadioQuestionAnswersCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  update?: InputMaybe<RadioQuestionAnswersUpdateConnectionInput>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};

export type RadioQuestionChoicesAggregateInput = {
  AND?: InputMaybe<Array<RadioQuestionChoicesAggregateInput>>;
  NOT?: InputMaybe<RadioQuestionChoicesAggregateInput>;
  OR?: InputMaybe<Array<RadioQuestionChoicesAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<RadioQuestionChoicesNodeAggregationWhereInput>;
};

export type RadioQuestionChoicesConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<QuestionItemConnectWhere>;
};

export type RadioQuestionChoicesConnectOrCreateFieldInput = {
  onCreate: RadioQuestionChoicesConnectOrCreateFieldInputOnCreate;
  where: QuestionItemConnectOrCreateWhere;
};

export type RadioQuestionChoicesConnectOrCreateFieldInputOnCreate = {
  node: QuestionItemOnCreateInput;
};

export type RadioQuestionChoicesConnection = {
  __typename?: 'RadioQuestionChoicesConnection';
  edges: Array<RadioQuestionChoicesRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type RadioQuestionChoicesConnectionSort = {
  node?: InputMaybe<QuestionItemSort>;
};

export type RadioQuestionChoicesConnectionWhere = {
  AND?: InputMaybe<Array<RadioQuestionChoicesConnectionWhere>>;
  NOT?: InputMaybe<RadioQuestionChoicesConnectionWhere>;
  OR?: InputMaybe<Array<RadioQuestionChoicesConnectionWhere>>;
  node?: InputMaybe<QuestionItemWhere>;
};

export type RadioQuestionChoicesCreateFieldInput = {
  node: QuestionItemCreateInput;
};

export type RadioQuestionChoicesDeleteFieldInput = {
  where?: InputMaybe<RadioQuestionChoicesConnectionWhere>;
};

export type RadioQuestionChoicesDisconnectFieldInput = {
  where?: InputMaybe<RadioQuestionChoicesConnectionWhere>;
};

export type RadioQuestionChoicesFieldInput = {
  connect?: InputMaybe<Array<RadioQuestionChoicesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<RadioQuestionChoicesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<RadioQuestionChoicesCreateFieldInput>>;
};

export type RadioQuestionChoicesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RadioQuestionChoicesNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RadioQuestionChoicesNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RadioQuestionChoicesNodeAggregationWhereInput>>;
  label_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  label_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
  score_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  score_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RadioQuestionChoicesRelationship = {
  __typename?: 'RadioQuestionChoicesRelationship';
  cursor: Scalars['String']['output'];
  node: QuestionItem;
};

export type RadioQuestionChoicesUpdateConnectionInput = {
  node?: InputMaybe<QuestionItemUpdateInput>;
};

export type RadioQuestionChoicesUpdateFieldInput = {
  connect?: InputMaybe<Array<RadioQuestionChoicesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<RadioQuestionChoicesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<RadioQuestionChoicesCreateFieldInput>>;
  delete?: InputMaybe<Array<RadioQuestionChoicesDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<RadioQuestionChoicesDisconnectFieldInput>>;
  update?: InputMaybe<RadioQuestionChoicesUpdateConnectionInput>;
  where?: InputMaybe<RadioQuestionChoicesConnectionWhere>;
};

export type RadioQuestionConnectInput = {
  alerts?: InputMaybe<RadioQuestionAlertsConnectFieldInput>;
  answers?: InputMaybe<Array<RadioQuestionAnswersConnectFieldInput>>;
  choices?: InputMaybe<Array<RadioQuestionChoicesConnectFieldInput>>;
  cooldown?: InputMaybe<RadioQuestionCooldownConnectFieldInput>;
  graph?: InputMaybe<RadioQuestionGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<RadioQuestionNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<RadioQuestionPrevsConnectFieldInput>>;
};

export type RadioQuestionConnectOrCreateInput = {
  choices?: InputMaybe<Array<RadioQuestionChoicesConnectOrCreateFieldInput>>;
};

export type RadioQuestionCooldownAggregateInput = {
  AND?: InputMaybe<Array<RadioQuestionCooldownAggregateInput>>;
  NOT?: InputMaybe<RadioQuestionCooldownAggregateInput>;
  OR?: InputMaybe<Array<RadioQuestionCooldownAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<RadioQuestionCooldownNodeAggregationWhereInput>;
};

export type RadioQuestionCooldownConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<CooldownConnectWhere>;
};

export type RadioQuestionCooldownConnection = {
  __typename?: 'RadioQuestionCooldownConnection';
  edges: Array<RadioQuestionCooldownRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type RadioQuestionCooldownConnectionSort = {
  node?: InputMaybe<CooldownSort>;
};

export type RadioQuestionCooldownConnectionWhere = {
  AND?: InputMaybe<Array<RadioQuestionCooldownConnectionWhere>>;
  NOT?: InputMaybe<RadioQuestionCooldownConnectionWhere>;
  OR?: InputMaybe<Array<RadioQuestionCooldownConnectionWhere>>;
  node?: InputMaybe<CooldownWhere>;
};

export type RadioQuestionCooldownCooldownAggregationSelection = {
  __typename?: 'RadioQuestionCooldownCooldownAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<RadioQuestionCooldownCooldownNodeAggregateSelection>;
};

export type RadioQuestionCooldownCooldownNodeAggregateSelection = {
  __typename?: 'RadioQuestionCooldownCooldownNodeAggregateSelection';
  value: IntAggregateSelection;
};

export type RadioQuestionCooldownCreateFieldInput = {
  node: CooldownCreateInput;
};

export type RadioQuestionCooldownDeleteFieldInput = {
  where?: InputMaybe<RadioQuestionCooldownConnectionWhere>;
};

export type RadioQuestionCooldownDisconnectFieldInput = {
  where?: InputMaybe<RadioQuestionCooldownConnectionWhere>;
};

export type RadioQuestionCooldownFieldInput = {
  connect?: InputMaybe<RadioQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<RadioQuestionCooldownCreateFieldInput>;
};

export type RadioQuestionCooldownNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RadioQuestionCooldownNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RadioQuestionCooldownNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RadioQuestionCooldownNodeAggregationWhereInput>>;
  value_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  value_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RadioQuestionCooldownRelationship = {
  __typename?: 'RadioQuestionCooldownRelationship';
  cursor: Scalars['String']['output'];
  node: Cooldown;
};

export type RadioQuestionCooldownUpdateConnectionInput = {
  node?: InputMaybe<CooldownUpdateInput>;
};

export type RadioQuestionCooldownUpdateFieldInput = {
  connect?: InputMaybe<RadioQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<RadioQuestionCooldownCreateFieldInput>;
  delete?: InputMaybe<RadioQuestionCooldownDeleteFieldInput>;
  disconnect?: InputMaybe<RadioQuestionCooldownDisconnectFieldInput>;
  update?: InputMaybe<RadioQuestionCooldownUpdateConnectionInput>;
  where?: InputMaybe<RadioQuestionCooldownConnectionWhere>;
};

export type RadioQuestionCreateInput = {
  alerts?: InputMaybe<RadioQuestionAlertsFieldInput>;
  answers?: InputMaybe<RadioQuestionAnswersFieldInput>;
  choices?: InputMaybe<RadioQuestionChoicesFieldInput>;
  cooldown?: InputMaybe<RadioQuestionCooldownFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<RadioQuestionGraphFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  nexts?: InputMaybe<RadioQuestionNextsFieldInput>;
  prevs?: InputMaybe<RadioQuestionPrevsFieldInput>;
};

export type RadioQuestionDeleteInput = {
  alerts?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  choices?: InputMaybe<Array<RadioQuestionChoicesDeleteFieldInput>>;
  cooldown?: InputMaybe<RadioQuestionCooldownDeleteFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<RadioQuestionNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<RadioQuestionPrevsDeleteFieldInput>>;
};

export type RadioQuestionDisconnectInput = {
  alerts?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  choices?: InputMaybe<Array<RadioQuestionChoicesDisconnectFieldInput>>;
  cooldown?: InputMaybe<RadioQuestionCooldownDisconnectFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<RadioQuestionNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<RadioQuestionPrevsDisconnectFieldInput>>;
};

export type RadioQuestionEdge = {
  __typename?: 'RadioQuestionEdge';
  cursor: Scalars['String']['output'];
  node: RadioQuestion;
};

export type RadioQuestionGraphAggregateInput = {
  AND?: InputMaybe<Array<RadioQuestionGraphAggregateInput>>;
  NOT?: InputMaybe<RadioQuestionGraphAggregateInput>;
  OR?: InputMaybe<Array<RadioQuestionGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<RadioQuestionGraphNodeAggregationWhereInput>;
};

export type RadioQuestionGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type RadioQuestionGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type RadioQuestionGraphFieldInput = {
  connect?: InputMaybe<RadioQuestionGraphConnectFieldInput>;
  create?: InputMaybe<RadioQuestionGraphCreateFieldInput>;
};

export type RadioQuestionGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RadioQuestionGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RadioQuestionGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RadioQuestionGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type RadioQuestionGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type RadioQuestionGraphUpdateFieldInput = {
  connect?: InputMaybe<RadioQuestionGraphConnectFieldInput>;
  create?: InputMaybe<RadioQuestionGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<RadioQuestionGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type RadioQuestionNextsAggregateInput = {
  AND?: InputMaybe<Array<RadioQuestionNextsAggregateInput>>;
  NOT?: InputMaybe<RadioQuestionNextsAggregateInput>;
  OR?: InputMaybe<Array<RadioQuestionNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<RadioQuestionNextsNodeAggregationWhereInput>;
};

export type RadioQuestionNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type RadioQuestionNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type RadioQuestionNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type RadioQuestionNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type RadioQuestionNextsFieldInput = {
  connect?: InputMaybe<Array<RadioQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<RadioQuestionNextsCreateFieldInput>>;
};

export type RadioQuestionNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RadioQuestionNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RadioQuestionNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RadioQuestionNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RadioQuestionNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type RadioQuestionNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<RadioQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<RadioQuestionNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<RadioQuestionNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<RadioQuestionNextsDisconnectFieldInput>>;
  update?: InputMaybe<RadioQuestionNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type RadioQuestionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more RadioQuestionSort objects to sort RadioQuestions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<RadioQuestionSort>>;
};

export type RadioQuestionPrevsAggregateInput = {
  AND?: InputMaybe<Array<RadioQuestionPrevsAggregateInput>>;
  NOT?: InputMaybe<RadioQuestionPrevsAggregateInput>;
  OR?: InputMaybe<Array<RadioQuestionPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<RadioQuestionPrevsNodeAggregationWhereInput>;
};

export type RadioQuestionPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type RadioQuestionPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type RadioQuestionPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type RadioQuestionPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type RadioQuestionPrevsFieldInput = {
  connect?: InputMaybe<Array<RadioQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<RadioQuestionPrevsCreateFieldInput>>;
};

export type RadioQuestionPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RadioQuestionPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RadioQuestionPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RadioQuestionPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RadioQuestionPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type RadioQuestionPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<RadioQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<RadioQuestionPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<RadioQuestionPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<RadioQuestionPrevsDisconnectFieldInput>>;
  update?: InputMaybe<RadioQuestionPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type RadioQuestionQuestionItemChoicesAggregationSelection = {
  __typename?: 'RadioQuestionQuestionItemChoicesAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<RadioQuestionQuestionItemChoicesNodeAggregateSelection>;
};

export type RadioQuestionQuestionItemChoicesNodeAggregateSelection = {
  __typename?: 'RadioQuestionQuestionItemChoicesNodeAggregateSelection';
  id: IdAggregateSelection;
  label: StringAggregateSelection;
  medicalLabel: StringAggregateSelection;
  order: IntAggregateSelection;
  score: IntAggregateSelection;
};

export type RadioQuestionQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'RadioQuestionQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<RadioQuestionQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<RadioQuestionQuestionnaireStepNextsNodeAggregateSelection>;
};

export type RadioQuestionQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'RadioQuestionQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type RadioQuestionQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'RadioQuestionQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type RadioQuestionQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'RadioQuestionQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<RadioQuestionQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<RadioQuestionQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type RadioQuestionQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'RadioQuestionQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type RadioQuestionQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'RadioQuestionQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type RadioQuestionRelationInput = {
  alerts?: InputMaybe<RadioQuestionAlertsCreateFieldInput>;
  answers?: InputMaybe<Array<RadioQuestionAnswersCreateFieldInput>>;
  choices?: InputMaybe<Array<RadioQuestionChoicesCreateFieldInput>>;
  cooldown?: InputMaybe<RadioQuestionCooldownCreateFieldInput>;
  graph?: InputMaybe<RadioQuestionGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<RadioQuestionNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<RadioQuestionPrevsCreateFieldInput>>;
};

/** Fields to sort RadioQuestions by. The order in which sorts are applied is not guaranteed when specifying many fields in one RadioQuestionSort object. */
export type RadioQuestionSort = {
  field?: InputMaybe<SortDirection>;
  hint?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  image?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type RadioQuestionUpdateInput = {
  alerts?: InputMaybe<RadioQuestionAlertsUpdateFieldInput>;
  answers?: InputMaybe<Array<RadioQuestionAnswersUpdateFieldInput>>;
  choices?: InputMaybe<Array<RadioQuestionChoicesUpdateFieldInput>>;
  cooldown?: InputMaybe<RadioQuestionCooldownUpdateFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<RadioQuestionGraphUpdateFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<RadioQuestionNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<RadioQuestionPrevsUpdateFieldInput>>;
};

export type RadioQuestionVersionnedGraphGraphAggregationSelection = {
  __typename?: 'RadioQuestionVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<RadioQuestionVersionnedGraphGraphNodeAggregateSelection>;
};

export type RadioQuestionVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'RadioQuestionVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type RadioQuestionWhere = {
  AND?: InputMaybe<Array<RadioQuestionWhere>>;
  NOT?: InputMaybe<RadioQuestionWhere>;
  OR?: InputMaybe<Array<RadioQuestionWhere>>;
  alerts?: InputMaybe<AlertGroupWhere>;
  alertsAggregate?: InputMaybe<RadioQuestionAlertsAggregateInput>;
  alertsConnection?: InputMaybe<QuestionAlertsConnectionWhere>;
  alertsConnection_NOT?: InputMaybe<QuestionAlertsConnectionWhere>;
  alerts_NOT?: InputMaybe<AlertGroupWhere>;
  answersAggregate?: InputMaybe<RadioQuestionAnswersAggregateInput>;
  /** Return RadioQuestions where all of the related QuestionAnswersConnections match this filter */
  answersConnection_ALL?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return RadioQuestions where none of the related QuestionAnswersConnections match this filter */
  answersConnection_NONE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return RadioQuestions where one of the related QuestionAnswersConnections match this filter */
  answersConnection_SINGLE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return RadioQuestions where some of the related QuestionAnswersConnections match this filter */
  answersConnection_SOME?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return RadioQuestions where all of the related Answers match this filter */
  answers_ALL?: InputMaybe<AnswerWhere>;
  /** Return RadioQuestions where none of the related Answers match this filter */
  answers_NONE?: InputMaybe<AnswerWhere>;
  /** Return RadioQuestions where one of the related Answers match this filter */
  answers_SINGLE?: InputMaybe<AnswerWhere>;
  /** Return RadioQuestions where some of the related Answers match this filter */
  answers_SOME?: InputMaybe<AnswerWhere>;
  choicesAggregate?: InputMaybe<RadioQuestionChoicesAggregateInput>;
  /** Return RadioQuestions where all of the related RadioQuestionChoicesConnections match this filter */
  choicesConnection_ALL?: InputMaybe<RadioQuestionChoicesConnectionWhere>;
  /** Return RadioQuestions where none of the related RadioQuestionChoicesConnections match this filter */
  choicesConnection_NONE?: InputMaybe<RadioQuestionChoicesConnectionWhere>;
  /** Return RadioQuestions where one of the related RadioQuestionChoicesConnections match this filter */
  choicesConnection_SINGLE?: InputMaybe<RadioQuestionChoicesConnectionWhere>;
  /** Return RadioQuestions where some of the related RadioQuestionChoicesConnections match this filter */
  choicesConnection_SOME?: InputMaybe<RadioQuestionChoicesConnectionWhere>;
  /** Return RadioQuestions where all of the related QuestionItems match this filter */
  choices_ALL?: InputMaybe<QuestionItemWhere>;
  /** Return RadioQuestions where none of the related QuestionItems match this filter */
  choices_NONE?: InputMaybe<QuestionItemWhere>;
  /** Return RadioQuestions where one of the related QuestionItems match this filter */
  choices_SINGLE?: InputMaybe<QuestionItemWhere>;
  /** Return RadioQuestions where some of the related QuestionItems match this filter */
  choices_SOME?: InputMaybe<QuestionItemWhere>;
  cooldown?: InputMaybe<CooldownWhere>;
  cooldownAggregate?: InputMaybe<RadioQuestionCooldownAggregateInput>;
  cooldownConnection?: InputMaybe<RadioQuestionCooldownConnectionWhere>;
  cooldownConnection_NOT?: InputMaybe<RadioQuestionCooldownConnectionWhere>;
  cooldown_NOT?: InputMaybe<CooldownWhere>;
  field?: InputMaybe<Scalars['String']['input']>;
  field_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  field_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  field_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  field_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<RadioQuestionGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  hint?: InputMaybe<Scalars['String']['input']>;
  hint_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  hint_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hint_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  image_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  image_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  image_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  image_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<RadioQuestionNextsAggregateInput>;
  /** Return RadioQuestions where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return RadioQuestions where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return RadioQuestions where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return RadioQuestions where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return RadioQuestions where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RadioQuestions where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RadioQuestions where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RadioQuestions where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<RadioQuestionPrevsAggregateInput>;
  /** Return RadioQuestions where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return RadioQuestions where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return RadioQuestions where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return RadioQuestions where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return RadioQuestions where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RadioQuestions where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RadioQuestions where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RadioQuestions where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type RadioQuestionsConnection = {
  __typename?: 'RadioQuestionsConnection';
  edges: Array<RadioQuestionEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type RangeQuestion = Question & QuestionnaireStep & {
  __typename?: 'RangeQuestion';
  alerts?: Maybe<AlertGroup>;
  alertsAggregate?: Maybe<RangeQuestionAlertGroupAlertsAggregationSelection>;
  alertsConnection: QuestionAlertsConnection;
  answers: Array<Answer>;
  answersAggregate?: Maybe<RangeQuestionAnswerAnswersAggregationSelection>;
  answersConnection: QuestionAnswersConnection;
  cooldown?: Maybe<Cooldown>;
  cooldownAggregate?: Maybe<RangeQuestionCooldownCooldownAggregationSelection>;
  cooldownConnection: RangeQuestionCooldownConnection;
  field?: Maybe<Scalars['String']['output']>;
  graph: VersionnedGraph;
  graphAggregate?: Maybe<RangeQuestionVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  hint?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  max?: Maybe<Scalars['Int']['output']>;
  min?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<RangeQuestionQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<RangeQuestionQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type RangeQuestionAlertsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AlertGroupOptions>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type RangeQuestionAlertsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type RangeQuestionAlertsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};


export type RangeQuestionAnswersArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AnswerOptions>;
  where?: InputMaybe<AnswerWhere>;
};


export type RangeQuestionAnswersAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AnswerWhere>;
};


export type RangeQuestionAnswersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionAnswersConnectionSort>>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};


export type RangeQuestionCooldownArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<CooldownOptions>;
  where?: InputMaybe<CooldownWhere>;
};


export type RangeQuestionCooldownAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<CooldownWhere>;
};


export type RangeQuestionCooldownConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<RangeQuestionCooldownConnectionSort>>;
  where?: InputMaybe<RangeQuestionCooldownConnectionWhere>;
};


export type RangeQuestionGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type RangeQuestionGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type RangeQuestionGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type RangeQuestionNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type RangeQuestionNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type RangeQuestionNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type RangeQuestionPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type RangeQuestionPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type RangeQuestionPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type RangeQuestionAggregateSelection = {
  __typename?: 'RangeQuestionAggregateSelection';
  count: Scalars['Int']['output'];
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  id: IdAggregateSelection;
  image: StringAggregateSelection;
  max: IntAggregateSelection;
  min: IntAggregateSelection;
  name: StringAggregateSelection;
};

export type RangeQuestionAlertGroupAlertsAggregationSelection = {
  __typename?: 'RangeQuestionAlertGroupAlertsAggregationSelection';
  count: Scalars['Int']['output'];
};

export type RangeQuestionAlertsAggregateInput = {
  AND?: InputMaybe<Array<RangeQuestionAlertsAggregateInput>>;
  NOT?: InputMaybe<RangeQuestionAlertsAggregateInput>;
  OR?: InputMaybe<Array<RangeQuestionAlertsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RangeQuestionAlertsConnectFieldInput = {
  connect?: InputMaybe<AlertGroupConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AlertGroupConnectWhere>;
};

export type RangeQuestionAlertsCreateFieldInput = {
  node: AlertGroupCreateInput;
};

export type RangeQuestionAlertsFieldInput = {
  connect?: InputMaybe<RangeQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<RangeQuestionAlertsCreateFieldInput>;
};

export type RangeQuestionAlertsUpdateConnectionInput = {
  node?: InputMaybe<AlertGroupUpdateInput>;
};

export type RangeQuestionAlertsUpdateFieldInput = {
  connect?: InputMaybe<RangeQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<RangeQuestionAlertsCreateFieldInput>;
  delete?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  update?: InputMaybe<RangeQuestionAlertsUpdateConnectionInput>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};

export type RangeQuestionAnswerAnswersAggregationSelection = {
  __typename?: 'RangeQuestionAnswerAnswersAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<RangeQuestionAnswerAnswersNodeAggregateSelection>;
};

export type RangeQuestionAnswerAnswersNodeAggregateSelection = {
  __typename?: 'RangeQuestionAnswerAnswersNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type RangeQuestionAnswersAggregateInput = {
  AND?: InputMaybe<Array<RangeQuestionAnswersAggregateInput>>;
  NOT?: InputMaybe<RangeQuestionAnswersAggregateInput>;
  OR?: InputMaybe<Array<RangeQuestionAnswersAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<RangeQuestionAnswersNodeAggregationWhereInput>;
};

export type RangeQuestionAnswersConnectFieldInput = {
  connect?: InputMaybe<Array<AnswerConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AnswerConnectWhere>;
};

export type RangeQuestionAnswersCreateFieldInput = {
  node: AnswerCreateInput;
};

export type RangeQuestionAnswersFieldInput = {
  connect?: InputMaybe<Array<RangeQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<RangeQuestionAnswersCreateFieldInput>>;
};

export type RangeQuestionAnswersNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RangeQuestionAnswersNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RangeQuestionAnswersNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RangeQuestionAnswersNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  field_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  field_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  hint_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RangeQuestionAnswersUpdateConnectionInput = {
  node?: InputMaybe<AnswerUpdateInput>;
};

export type RangeQuestionAnswersUpdateFieldInput = {
  connect?: InputMaybe<Array<RangeQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<RangeQuestionAnswersCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  update?: InputMaybe<RangeQuestionAnswersUpdateConnectionInput>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};

export type RangeQuestionConnectInput = {
  alerts?: InputMaybe<RangeQuestionAlertsConnectFieldInput>;
  answers?: InputMaybe<Array<RangeQuestionAnswersConnectFieldInput>>;
  cooldown?: InputMaybe<RangeQuestionCooldownConnectFieldInput>;
  graph?: InputMaybe<RangeQuestionGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<RangeQuestionNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<RangeQuestionPrevsConnectFieldInput>>;
};

export type RangeQuestionCooldownAggregateInput = {
  AND?: InputMaybe<Array<RangeQuestionCooldownAggregateInput>>;
  NOT?: InputMaybe<RangeQuestionCooldownAggregateInput>;
  OR?: InputMaybe<Array<RangeQuestionCooldownAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<RangeQuestionCooldownNodeAggregationWhereInput>;
};

export type RangeQuestionCooldownConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<CooldownConnectWhere>;
};

export type RangeQuestionCooldownConnection = {
  __typename?: 'RangeQuestionCooldownConnection';
  edges: Array<RangeQuestionCooldownRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type RangeQuestionCooldownConnectionSort = {
  node?: InputMaybe<CooldownSort>;
};

export type RangeQuestionCooldownConnectionWhere = {
  AND?: InputMaybe<Array<RangeQuestionCooldownConnectionWhere>>;
  NOT?: InputMaybe<RangeQuestionCooldownConnectionWhere>;
  OR?: InputMaybe<Array<RangeQuestionCooldownConnectionWhere>>;
  node?: InputMaybe<CooldownWhere>;
};

export type RangeQuestionCooldownCooldownAggregationSelection = {
  __typename?: 'RangeQuestionCooldownCooldownAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<RangeQuestionCooldownCooldownNodeAggregateSelection>;
};

export type RangeQuestionCooldownCooldownNodeAggregateSelection = {
  __typename?: 'RangeQuestionCooldownCooldownNodeAggregateSelection';
  value: IntAggregateSelection;
};

export type RangeQuestionCooldownCreateFieldInput = {
  node: CooldownCreateInput;
};

export type RangeQuestionCooldownDeleteFieldInput = {
  where?: InputMaybe<RangeQuestionCooldownConnectionWhere>;
};

export type RangeQuestionCooldownDisconnectFieldInput = {
  where?: InputMaybe<RangeQuestionCooldownConnectionWhere>;
};

export type RangeQuestionCooldownFieldInput = {
  connect?: InputMaybe<RangeQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<RangeQuestionCooldownCreateFieldInput>;
};

export type RangeQuestionCooldownNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RangeQuestionCooldownNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RangeQuestionCooldownNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RangeQuestionCooldownNodeAggregationWhereInput>>;
  value_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  value_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RangeQuestionCooldownRelationship = {
  __typename?: 'RangeQuestionCooldownRelationship';
  cursor: Scalars['String']['output'];
  node: Cooldown;
};

export type RangeQuestionCooldownUpdateConnectionInput = {
  node?: InputMaybe<CooldownUpdateInput>;
};

export type RangeQuestionCooldownUpdateFieldInput = {
  connect?: InputMaybe<RangeQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<RangeQuestionCooldownCreateFieldInput>;
  delete?: InputMaybe<RangeQuestionCooldownDeleteFieldInput>;
  disconnect?: InputMaybe<RangeQuestionCooldownDisconnectFieldInput>;
  update?: InputMaybe<RangeQuestionCooldownUpdateConnectionInput>;
  where?: InputMaybe<RangeQuestionCooldownConnectionWhere>;
};

export type RangeQuestionCreateInput = {
  alerts?: InputMaybe<RangeQuestionAlertsFieldInput>;
  answers?: InputMaybe<RangeQuestionAnswersFieldInput>;
  cooldown?: InputMaybe<RangeQuestionCooldownFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<RangeQuestionGraphFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  max?: InputMaybe<Scalars['Int']['input']>;
  min?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  nexts?: InputMaybe<RangeQuestionNextsFieldInput>;
  prevs?: InputMaybe<RangeQuestionPrevsFieldInput>;
};

export type RangeQuestionDeleteInput = {
  alerts?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  cooldown?: InputMaybe<RangeQuestionCooldownDeleteFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<RangeQuestionNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<RangeQuestionPrevsDeleteFieldInput>>;
};

export type RangeQuestionDisconnectInput = {
  alerts?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  cooldown?: InputMaybe<RangeQuestionCooldownDisconnectFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<RangeQuestionNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<RangeQuestionPrevsDisconnectFieldInput>>;
};

export type RangeQuestionEdge = {
  __typename?: 'RangeQuestionEdge';
  cursor: Scalars['String']['output'];
  node: RangeQuestion;
};

export type RangeQuestionGraphAggregateInput = {
  AND?: InputMaybe<Array<RangeQuestionGraphAggregateInput>>;
  NOT?: InputMaybe<RangeQuestionGraphAggregateInput>;
  OR?: InputMaybe<Array<RangeQuestionGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<RangeQuestionGraphNodeAggregationWhereInput>;
};

export type RangeQuestionGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type RangeQuestionGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type RangeQuestionGraphFieldInput = {
  connect?: InputMaybe<RangeQuestionGraphConnectFieldInput>;
  create?: InputMaybe<RangeQuestionGraphCreateFieldInput>;
};

export type RangeQuestionGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RangeQuestionGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RangeQuestionGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RangeQuestionGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type RangeQuestionGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type RangeQuestionGraphUpdateFieldInput = {
  connect?: InputMaybe<RangeQuestionGraphConnectFieldInput>;
  create?: InputMaybe<RangeQuestionGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<RangeQuestionGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type RangeQuestionNextsAggregateInput = {
  AND?: InputMaybe<Array<RangeQuestionNextsAggregateInput>>;
  NOT?: InputMaybe<RangeQuestionNextsAggregateInput>;
  OR?: InputMaybe<Array<RangeQuestionNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<RangeQuestionNextsNodeAggregationWhereInput>;
};

export type RangeQuestionNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type RangeQuestionNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type RangeQuestionNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type RangeQuestionNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type RangeQuestionNextsFieldInput = {
  connect?: InputMaybe<Array<RangeQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<RangeQuestionNextsCreateFieldInput>>;
};

export type RangeQuestionNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RangeQuestionNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RangeQuestionNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RangeQuestionNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RangeQuestionNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type RangeQuestionNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<RangeQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<RangeQuestionNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<RangeQuestionNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<RangeQuestionNextsDisconnectFieldInput>>;
  update?: InputMaybe<RangeQuestionNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type RangeQuestionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more RangeQuestionSort objects to sort RangeQuestions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<RangeQuestionSort>>;
};

export type RangeQuestionPrevsAggregateInput = {
  AND?: InputMaybe<Array<RangeQuestionPrevsAggregateInput>>;
  NOT?: InputMaybe<RangeQuestionPrevsAggregateInput>;
  OR?: InputMaybe<Array<RangeQuestionPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<RangeQuestionPrevsNodeAggregationWhereInput>;
};

export type RangeQuestionPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type RangeQuestionPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type RangeQuestionPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type RangeQuestionPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type RangeQuestionPrevsFieldInput = {
  connect?: InputMaybe<Array<RangeQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<RangeQuestionPrevsCreateFieldInput>>;
};

export type RangeQuestionPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RangeQuestionPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<RangeQuestionPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<RangeQuestionPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type RangeQuestionPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type RangeQuestionPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<RangeQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<RangeQuestionPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<RangeQuestionPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<RangeQuestionPrevsDisconnectFieldInput>>;
  update?: InputMaybe<RangeQuestionPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type RangeQuestionQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'RangeQuestionQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<RangeQuestionQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<RangeQuestionQuestionnaireStepNextsNodeAggregateSelection>;
};

export type RangeQuestionQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'RangeQuestionQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type RangeQuestionQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'RangeQuestionQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type RangeQuestionQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'RangeQuestionQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<RangeQuestionQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<RangeQuestionQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type RangeQuestionQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'RangeQuestionQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type RangeQuestionQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'RangeQuestionQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type RangeQuestionRelationInput = {
  alerts?: InputMaybe<RangeQuestionAlertsCreateFieldInput>;
  answers?: InputMaybe<Array<RangeQuestionAnswersCreateFieldInput>>;
  cooldown?: InputMaybe<RangeQuestionCooldownCreateFieldInput>;
  graph?: InputMaybe<RangeQuestionGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<RangeQuestionNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<RangeQuestionPrevsCreateFieldInput>>;
};

/** Fields to sort RangeQuestions by. The order in which sorts are applied is not guaranteed when specifying many fields in one RangeQuestionSort object. */
export type RangeQuestionSort = {
  field?: InputMaybe<SortDirection>;
  hint?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  image?: InputMaybe<SortDirection>;
  max?: InputMaybe<SortDirection>;
  min?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type RangeQuestionUpdateInput = {
  alerts?: InputMaybe<RangeQuestionAlertsUpdateFieldInput>;
  answers?: InputMaybe<Array<RangeQuestionAnswersUpdateFieldInput>>;
  cooldown?: InputMaybe<RangeQuestionCooldownUpdateFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<RangeQuestionGraphUpdateFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  max?: InputMaybe<Scalars['Int']['input']>;
  max_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  max_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  min?: InputMaybe<Scalars['Int']['input']>;
  min_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  min_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<RangeQuestionNextsUpdateFieldInput>>;
  prevs?: InputMaybe<Array<RangeQuestionPrevsUpdateFieldInput>>;
};

export type RangeQuestionVersionnedGraphGraphAggregationSelection = {
  __typename?: 'RangeQuestionVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<RangeQuestionVersionnedGraphGraphNodeAggregateSelection>;
};

export type RangeQuestionVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'RangeQuestionVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type RangeQuestionWhere = {
  AND?: InputMaybe<Array<RangeQuestionWhere>>;
  NOT?: InputMaybe<RangeQuestionWhere>;
  OR?: InputMaybe<Array<RangeQuestionWhere>>;
  alerts?: InputMaybe<AlertGroupWhere>;
  alertsAggregate?: InputMaybe<RangeQuestionAlertsAggregateInput>;
  alertsConnection?: InputMaybe<QuestionAlertsConnectionWhere>;
  alertsConnection_NOT?: InputMaybe<QuestionAlertsConnectionWhere>;
  alerts_NOT?: InputMaybe<AlertGroupWhere>;
  answersAggregate?: InputMaybe<RangeQuestionAnswersAggregateInput>;
  /** Return RangeQuestions where all of the related QuestionAnswersConnections match this filter */
  answersConnection_ALL?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return RangeQuestions where none of the related QuestionAnswersConnections match this filter */
  answersConnection_NONE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return RangeQuestions where one of the related QuestionAnswersConnections match this filter */
  answersConnection_SINGLE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return RangeQuestions where some of the related QuestionAnswersConnections match this filter */
  answersConnection_SOME?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return RangeQuestions where all of the related Answers match this filter */
  answers_ALL?: InputMaybe<AnswerWhere>;
  /** Return RangeQuestions where none of the related Answers match this filter */
  answers_NONE?: InputMaybe<AnswerWhere>;
  /** Return RangeQuestions where one of the related Answers match this filter */
  answers_SINGLE?: InputMaybe<AnswerWhere>;
  /** Return RangeQuestions where some of the related Answers match this filter */
  answers_SOME?: InputMaybe<AnswerWhere>;
  cooldown?: InputMaybe<CooldownWhere>;
  cooldownAggregate?: InputMaybe<RangeQuestionCooldownAggregateInput>;
  cooldownConnection?: InputMaybe<RangeQuestionCooldownConnectionWhere>;
  cooldownConnection_NOT?: InputMaybe<RangeQuestionCooldownConnectionWhere>;
  cooldown_NOT?: InputMaybe<CooldownWhere>;
  field?: InputMaybe<Scalars['String']['input']>;
  field_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  field_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  field_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  field_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<RangeQuestionGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  hint?: InputMaybe<Scalars['String']['input']>;
  hint_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  hint_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hint_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  image_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  image_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  image_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  image_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  max?: InputMaybe<Scalars['Int']['input']>;
  max_GT?: InputMaybe<Scalars['Int']['input']>;
  max_GTE?: InputMaybe<Scalars['Int']['input']>;
  max_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  max_LT?: InputMaybe<Scalars['Int']['input']>;
  max_LTE?: InputMaybe<Scalars['Int']['input']>;
  min?: InputMaybe<Scalars['Int']['input']>;
  min_GT?: InputMaybe<Scalars['Int']['input']>;
  min_GTE?: InputMaybe<Scalars['Int']['input']>;
  min_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  min_LT?: InputMaybe<Scalars['Int']['input']>;
  min_LTE?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<RangeQuestionNextsAggregateInput>;
  /** Return RangeQuestions where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return RangeQuestions where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return RangeQuestions where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return RangeQuestions where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return RangeQuestions where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RangeQuestions where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RangeQuestions where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RangeQuestions where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  prevsAggregate?: InputMaybe<RangeQuestionPrevsAggregateInput>;
  /** Return RangeQuestions where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return RangeQuestions where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return RangeQuestions where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return RangeQuestions where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return RangeQuestions where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RangeQuestions where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RangeQuestions where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return RangeQuestions where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type RangeQuestionsConnection = {
  __typename?: 'RangeQuestionsConnection';
  edges: Array<RangeQuestionEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/**
 * The edge properties for the following fields:
 * * Interview.scored
 */
export type Scored = {
  __typename?: 'Scored';
  alert?: Maybe<AlertLevel>;
  value?: Maybe<Scalars['Int']['output']>;
};

export type ScoredAggregationWhereInput = {
  AND?: InputMaybe<Array<ScoredAggregationWhereInput>>;
  NOT?: InputMaybe<ScoredAggregationWhereInput>;
  OR?: InputMaybe<Array<ScoredAggregationWhereInput>>;
  value_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  value_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type ScoredCreateInput = {
  alert?: InputMaybe<AlertLevel>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

export type ScoredSort = {
  alert?: InputMaybe<SortDirection>;
  value?: InputMaybe<SortDirection>;
};

export type ScoredUpdateInput = {
  alert?: InputMaybe<AlertLevel>;
  value?: InputMaybe<Scalars['Int']['input']>;
  value_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  value_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
};

export type ScoredWhere = {
  AND?: InputMaybe<Array<ScoredWhere>>;
  NOT?: InputMaybe<ScoredWhere>;
  OR?: InputMaybe<Array<ScoredWhere>>;
  alert?: InputMaybe<AlertLevel>;
  alert_IN?: InputMaybe<Array<InputMaybe<AlertLevel>>>;
  value?: InputMaybe<Scalars['Int']['input']>;
  value_GT?: InputMaybe<Scalars['Int']['input']>;
  value_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  value_LT?: InputMaybe<Scalars['Int']['input']>;
  value_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type SearchQuestionResult = {
  __typename?: 'SearchQuestionResult';
  questionId: Scalars['ID']['output'];
  questionName: Scalars['String']['output'];
  questionType: Scalars['String']['output'];
  questionnaireId: Scalars['ID']['output'];
  questionnaireName: Scalars['String']['output'];
  questionnaireType: Scalars['String']['output'];
};

export type SearchQuestionResultAggregateSelection = {
  __typename?: 'SearchQuestionResultAggregateSelection';
  count: Scalars['Int']['output'];
  questionId: IdAggregateSelection;
  questionName: StringAggregateSelection;
  questionType: StringAggregateSelection;
  questionnaireId: IdAggregateSelection;
  questionnaireName: StringAggregateSelection;
  questionnaireType: StringAggregateSelection;
};

export type SearchQuestionResultCreateInput = {
  questionId: Scalars['ID']['input'];
  questionName: Scalars['String']['input'];
  questionType: Scalars['String']['input'];
  questionnaireId: Scalars['ID']['input'];
  questionnaireName: Scalars['String']['input'];
  questionnaireType: Scalars['String']['input'];
};

export type SearchQuestionResultEdge = {
  __typename?: 'SearchQuestionResultEdge';
  cursor: Scalars['String']['output'];
  node: SearchQuestionResult;
};

export type SearchQuestionResultOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more SearchQuestionResultSort objects to sort SearchQuestionResults by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<SearchQuestionResultSort>>;
};

/** Fields to sort SearchQuestionResults by. The order in which sorts are applied is not guaranteed when specifying many fields in one SearchQuestionResultSort object. */
export type SearchQuestionResultSort = {
  questionId?: InputMaybe<SortDirection>;
  questionName?: InputMaybe<SortDirection>;
  questionType?: InputMaybe<SortDirection>;
  questionnaireId?: InputMaybe<SortDirection>;
  questionnaireName?: InputMaybe<SortDirection>;
  questionnaireType?: InputMaybe<SortDirection>;
};

export type SearchQuestionResultUpdateInput = {
  questionId?: InputMaybe<Scalars['ID']['input']>;
  questionName?: InputMaybe<Scalars['String']['input']>;
  questionType?: InputMaybe<Scalars['String']['input']>;
  questionnaireId?: InputMaybe<Scalars['ID']['input']>;
  questionnaireName?: InputMaybe<Scalars['String']['input']>;
  questionnaireType?: InputMaybe<Scalars['String']['input']>;
};

export type SearchQuestionResultWhere = {
  AND?: InputMaybe<Array<SearchQuestionResultWhere>>;
  NOT?: InputMaybe<SearchQuestionResultWhere>;
  OR?: InputMaybe<Array<SearchQuestionResultWhere>>;
  questionId?: InputMaybe<Scalars['ID']['input']>;
  questionId_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  questionId_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  questionId_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  questionId_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  questionName?: InputMaybe<Scalars['String']['input']>;
  questionName_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  questionName_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  questionName_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  questionName_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  questionType?: InputMaybe<Scalars['String']['input']>;
  questionType_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  questionType_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  questionType_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  questionType_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  questionnaireId?: InputMaybe<Scalars['ID']['input']>;
  questionnaireId_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  questionnaireId_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  questionnaireId_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  questionnaireId_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  questionnaireName?: InputMaybe<Scalars['String']['input']>;
  questionnaireName_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  questionnaireName_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  questionnaireName_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  questionnaireName_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  questionnaireType?: InputMaybe<Scalars['String']['input']>;
  questionnaireType_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  questionnaireType_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  questionnaireType_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  questionnaireType_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type SearchQuestionResultsConnection = {
  __typename?: 'SearchQuestionResultsConnection';
  edges: Array<SearchQuestionResultEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type SelectMenuItemInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  icon: Scalars['Int']['input'];
  iconFontFamily: Scalars['String']['input'];
  iconFontPackage: Scalars['String']['input'];
  iconName: Scalars['String']['input'];
  iconPrefix: Scalars['String']['input'];
  label: Scalars['String']['input'];
  medicalLabel?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

export type SelectQuestion = Question & QuestionnaireStep & {
  __typename?: 'SelectQuestion';
  alerts?: Maybe<AlertGroup>;
  alertsAggregate?: Maybe<SelectQuestionAlertGroupAlertsAggregationSelection>;
  alertsConnection: QuestionAlertsConnection;
  answers: Array<Answer>;
  answersAggregate?: Maybe<SelectQuestionAnswerAnswersAggregationSelection>;
  answersConnection: QuestionAnswersConnection;
  choices: Array<QuestionItem>;
  choicesAggregate?: Maybe<SelectQuestionQuestionItemChoicesAggregationSelection>;
  choicesConnection: SelectQuestionChoicesConnection;
  cooldown?: Maybe<Cooldown>;
  cooldownAggregate?: Maybe<SelectQuestionCooldownCooldownAggregationSelection>;
  cooldownConnection: SelectQuestionCooldownConnection;
  field?: Maybe<Scalars['String']['output']>;
  graph: VersionnedGraph;
  graphAggregate?: Maybe<SelectQuestionVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  hint?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  multiple?: Maybe<Scalars['Boolean']['output']>;
  name: Scalars['String']['output'];
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<SelectQuestionQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  placeholder?: Maybe<Scalars['String']['output']>;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<SelectQuestionQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type SelectQuestionAlertsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AlertGroupOptions>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type SelectQuestionAlertsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type SelectQuestionAlertsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};


export type SelectQuestionAnswersArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AnswerOptions>;
  where?: InputMaybe<AnswerWhere>;
};


export type SelectQuestionAnswersAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AnswerWhere>;
};


export type SelectQuestionAnswersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionAnswersConnectionSort>>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};


export type SelectQuestionChoicesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionItemOptions>;
  where?: InputMaybe<QuestionItemWhere>;
};


export type SelectQuestionChoicesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionItemWhere>;
};


export type SelectQuestionChoicesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<SelectQuestionChoicesConnectionSort>>;
  where?: InputMaybe<SelectQuestionChoicesConnectionWhere>;
};


export type SelectQuestionCooldownArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<CooldownOptions>;
  where?: InputMaybe<CooldownWhere>;
};


export type SelectQuestionCooldownAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<CooldownWhere>;
};


export type SelectQuestionCooldownConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<SelectQuestionCooldownConnectionSort>>;
  where?: InputMaybe<SelectQuestionCooldownConnectionWhere>;
};


export type SelectQuestionGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type SelectQuestionGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type SelectQuestionGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type SelectQuestionNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type SelectQuestionNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type SelectQuestionNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type SelectQuestionPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type SelectQuestionPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type SelectQuestionPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type SelectQuestionAggregateSelection = {
  __typename?: 'SelectQuestionAggregateSelection';
  count: Scalars['Int']['output'];
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  id: IdAggregateSelection;
  image: StringAggregateSelection;
  name: StringAggregateSelection;
  placeholder: StringAggregateSelection;
};

export type SelectQuestionAlertGroupAlertsAggregationSelection = {
  __typename?: 'SelectQuestionAlertGroupAlertsAggregationSelection';
  count: Scalars['Int']['output'];
};

export type SelectQuestionAlertsAggregateInput = {
  AND?: InputMaybe<Array<SelectQuestionAlertsAggregateInput>>;
  NOT?: InputMaybe<SelectQuestionAlertsAggregateInput>;
  OR?: InputMaybe<Array<SelectQuestionAlertsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type SelectQuestionAlertsConnectFieldInput = {
  connect?: InputMaybe<AlertGroupConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AlertGroupConnectWhere>;
};

export type SelectQuestionAlertsCreateFieldInput = {
  node: AlertGroupCreateInput;
};

export type SelectQuestionAlertsFieldInput = {
  connect?: InputMaybe<SelectQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<SelectQuestionAlertsCreateFieldInput>;
};

export type SelectQuestionAlertsUpdateConnectionInput = {
  node?: InputMaybe<AlertGroupUpdateInput>;
};

export type SelectQuestionAlertsUpdateFieldInput = {
  connect?: InputMaybe<SelectQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<SelectQuestionAlertsCreateFieldInput>;
  delete?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  update?: InputMaybe<SelectQuestionAlertsUpdateConnectionInput>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};

export type SelectQuestionAnswerAnswersAggregationSelection = {
  __typename?: 'SelectQuestionAnswerAnswersAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<SelectQuestionAnswerAnswersNodeAggregateSelection>;
};

export type SelectQuestionAnswerAnswersNodeAggregateSelection = {
  __typename?: 'SelectQuestionAnswerAnswersNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type SelectQuestionAnswersAggregateInput = {
  AND?: InputMaybe<Array<SelectQuestionAnswersAggregateInput>>;
  NOT?: InputMaybe<SelectQuestionAnswersAggregateInput>;
  OR?: InputMaybe<Array<SelectQuestionAnswersAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<SelectQuestionAnswersNodeAggregationWhereInput>;
};

export type SelectQuestionAnswersConnectFieldInput = {
  connect?: InputMaybe<Array<AnswerConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AnswerConnectWhere>;
};

export type SelectQuestionAnswersCreateFieldInput = {
  node: AnswerCreateInput;
};

export type SelectQuestionAnswersFieldInput = {
  connect?: InputMaybe<Array<SelectQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<SelectQuestionAnswersCreateFieldInput>>;
};

export type SelectQuestionAnswersNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<SelectQuestionAnswersNodeAggregationWhereInput>>;
  NOT?: InputMaybe<SelectQuestionAnswersNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<SelectQuestionAnswersNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  field_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  field_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  hint_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type SelectQuestionAnswersUpdateConnectionInput = {
  node?: InputMaybe<AnswerUpdateInput>;
};

export type SelectQuestionAnswersUpdateFieldInput = {
  connect?: InputMaybe<Array<SelectQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<SelectQuestionAnswersCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  update?: InputMaybe<SelectQuestionAnswersUpdateConnectionInput>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};

export type SelectQuestionChoicesAggregateInput = {
  AND?: InputMaybe<Array<SelectQuestionChoicesAggregateInput>>;
  NOT?: InputMaybe<SelectQuestionChoicesAggregateInput>;
  OR?: InputMaybe<Array<SelectQuestionChoicesAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<SelectQuestionChoicesNodeAggregationWhereInput>;
};

export type SelectQuestionChoicesConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<QuestionItemConnectWhere>;
};

export type SelectQuestionChoicesConnectOrCreateFieldInput = {
  onCreate: SelectQuestionChoicesConnectOrCreateFieldInputOnCreate;
  where: QuestionItemConnectOrCreateWhere;
};

export type SelectQuestionChoicesConnectOrCreateFieldInputOnCreate = {
  node: QuestionItemOnCreateInput;
};

export type SelectQuestionChoicesConnection = {
  __typename?: 'SelectQuestionChoicesConnection';
  edges: Array<SelectQuestionChoicesRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type SelectQuestionChoicesConnectionSort = {
  node?: InputMaybe<QuestionItemSort>;
};

export type SelectQuestionChoicesConnectionWhere = {
  AND?: InputMaybe<Array<SelectQuestionChoicesConnectionWhere>>;
  NOT?: InputMaybe<SelectQuestionChoicesConnectionWhere>;
  OR?: InputMaybe<Array<SelectQuestionChoicesConnectionWhere>>;
  node?: InputMaybe<QuestionItemWhere>;
};

export type SelectQuestionChoicesCreateFieldInput = {
  node: QuestionItemCreateInput;
};

export type SelectQuestionChoicesDeleteFieldInput = {
  where?: InputMaybe<SelectQuestionChoicesConnectionWhere>;
};

export type SelectQuestionChoicesDisconnectFieldInput = {
  where?: InputMaybe<SelectQuestionChoicesConnectionWhere>;
};

export type SelectQuestionChoicesFieldInput = {
  connect?: InputMaybe<Array<SelectQuestionChoicesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<SelectQuestionChoicesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<SelectQuestionChoicesCreateFieldInput>>;
};

export type SelectQuestionChoicesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<SelectQuestionChoicesNodeAggregationWhereInput>>;
  NOT?: InputMaybe<SelectQuestionChoicesNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<SelectQuestionChoicesNodeAggregationWhereInput>>;
  label_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  label_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  medicalLabel_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  medicalLabel_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
  score_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  score_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  score_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  score_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  score_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  score_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type SelectQuestionChoicesRelationship = {
  __typename?: 'SelectQuestionChoicesRelationship';
  cursor: Scalars['String']['output'];
  node: QuestionItem;
};

export type SelectQuestionChoicesUpdateConnectionInput = {
  node?: InputMaybe<QuestionItemUpdateInput>;
};

export type SelectQuestionChoicesUpdateFieldInput = {
  connect?: InputMaybe<Array<SelectQuestionChoicesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<SelectQuestionChoicesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<SelectQuestionChoicesCreateFieldInput>>;
  delete?: InputMaybe<Array<SelectQuestionChoicesDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<SelectQuestionChoicesDisconnectFieldInput>>;
  update?: InputMaybe<SelectQuestionChoicesUpdateConnectionInput>;
  where?: InputMaybe<SelectQuestionChoicesConnectionWhere>;
};

export type SelectQuestionConnectInput = {
  alerts?: InputMaybe<SelectQuestionAlertsConnectFieldInput>;
  answers?: InputMaybe<Array<SelectQuestionAnswersConnectFieldInput>>;
  choices?: InputMaybe<Array<SelectQuestionChoicesConnectFieldInput>>;
  cooldown?: InputMaybe<SelectQuestionCooldownConnectFieldInput>;
  graph?: InputMaybe<SelectQuestionGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<SelectQuestionNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<SelectQuestionPrevsConnectFieldInput>>;
};

export type SelectQuestionConnectOrCreateInput = {
  choices?: InputMaybe<Array<SelectQuestionChoicesConnectOrCreateFieldInput>>;
};

export type SelectQuestionCooldownAggregateInput = {
  AND?: InputMaybe<Array<SelectQuestionCooldownAggregateInput>>;
  NOT?: InputMaybe<SelectQuestionCooldownAggregateInput>;
  OR?: InputMaybe<Array<SelectQuestionCooldownAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<SelectQuestionCooldownNodeAggregationWhereInput>;
};

export type SelectQuestionCooldownConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<CooldownConnectWhere>;
};

export type SelectQuestionCooldownConnection = {
  __typename?: 'SelectQuestionCooldownConnection';
  edges: Array<SelectQuestionCooldownRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type SelectQuestionCooldownConnectionSort = {
  node?: InputMaybe<CooldownSort>;
};

export type SelectQuestionCooldownConnectionWhere = {
  AND?: InputMaybe<Array<SelectQuestionCooldownConnectionWhere>>;
  NOT?: InputMaybe<SelectQuestionCooldownConnectionWhere>;
  OR?: InputMaybe<Array<SelectQuestionCooldownConnectionWhere>>;
  node?: InputMaybe<CooldownWhere>;
};

export type SelectQuestionCooldownCooldownAggregationSelection = {
  __typename?: 'SelectQuestionCooldownCooldownAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<SelectQuestionCooldownCooldownNodeAggregateSelection>;
};

export type SelectQuestionCooldownCooldownNodeAggregateSelection = {
  __typename?: 'SelectQuestionCooldownCooldownNodeAggregateSelection';
  value: IntAggregateSelection;
};

export type SelectQuestionCooldownCreateFieldInput = {
  node: CooldownCreateInput;
};

export type SelectQuestionCooldownDeleteFieldInput = {
  where?: InputMaybe<SelectQuestionCooldownConnectionWhere>;
};

export type SelectQuestionCooldownDisconnectFieldInput = {
  where?: InputMaybe<SelectQuestionCooldownConnectionWhere>;
};

export type SelectQuestionCooldownFieldInput = {
  connect?: InputMaybe<SelectQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<SelectQuestionCooldownCreateFieldInput>;
};

export type SelectQuestionCooldownNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<SelectQuestionCooldownNodeAggregationWhereInput>>;
  NOT?: InputMaybe<SelectQuestionCooldownNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<SelectQuestionCooldownNodeAggregationWhereInput>>;
  value_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  value_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type SelectQuestionCooldownRelationship = {
  __typename?: 'SelectQuestionCooldownRelationship';
  cursor: Scalars['String']['output'];
  node: Cooldown;
};

export type SelectQuestionCooldownUpdateConnectionInput = {
  node?: InputMaybe<CooldownUpdateInput>;
};

export type SelectQuestionCooldownUpdateFieldInput = {
  connect?: InputMaybe<SelectQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<SelectQuestionCooldownCreateFieldInput>;
  delete?: InputMaybe<SelectQuestionCooldownDeleteFieldInput>;
  disconnect?: InputMaybe<SelectQuestionCooldownDisconnectFieldInput>;
  update?: InputMaybe<SelectQuestionCooldownUpdateConnectionInput>;
  where?: InputMaybe<SelectQuestionCooldownConnectionWhere>;
};

export type SelectQuestionCreateInput = {
  alerts?: InputMaybe<SelectQuestionAlertsFieldInput>;
  answers?: InputMaybe<SelectQuestionAnswersFieldInput>;
  choices?: InputMaybe<SelectQuestionChoicesFieldInput>;
  cooldown?: InputMaybe<SelectQuestionCooldownFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<SelectQuestionGraphFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  multiple?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  nexts?: InputMaybe<SelectQuestionNextsFieldInput>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  prevs?: InputMaybe<SelectQuestionPrevsFieldInput>;
};

export type SelectQuestionDeleteInput = {
  alerts?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  choices?: InputMaybe<Array<SelectQuestionChoicesDeleteFieldInput>>;
  cooldown?: InputMaybe<SelectQuestionCooldownDeleteFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<SelectQuestionNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<SelectQuestionPrevsDeleteFieldInput>>;
};

export type SelectQuestionDisconnectInput = {
  alerts?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  choices?: InputMaybe<Array<SelectQuestionChoicesDisconnectFieldInput>>;
  cooldown?: InputMaybe<SelectQuestionCooldownDisconnectFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<SelectQuestionNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<SelectQuestionPrevsDisconnectFieldInput>>;
};

export type SelectQuestionEdge = {
  __typename?: 'SelectQuestionEdge';
  cursor: Scalars['String']['output'];
  node: SelectQuestion;
};

export type SelectQuestionGraphAggregateInput = {
  AND?: InputMaybe<Array<SelectQuestionGraphAggregateInput>>;
  NOT?: InputMaybe<SelectQuestionGraphAggregateInput>;
  OR?: InputMaybe<Array<SelectQuestionGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<SelectQuestionGraphNodeAggregationWhereInput>;
};

export type SelectQuestionGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type SelectQuestionGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type SelectQuestionGraphFieldInput = {
  connect?: InputMaybe<SelectQuestionGraphConnectFieldInput>;
  create?: InputMaybe<SelectQuestionGraphCreateFieldInput>;
};

export type SelectQuestionGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<SelectQuestionGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<SelectQuestionGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<SelectQuestionGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SelectQuestionGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type SelectQuestionGraphUpdateFieldInput = {
  connect?: InputMaybe<SelectQuestionGraphConnectFieldInput>;
  create?: InputMaybe<SelectQuestionGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<SelectQuestionGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type SelectQuestionNextsAggregateInput = {
  AND?: InputMaybe<Array<SelectQuestionNextsAggregateInput>>;
  NOT?: InputMaybe<SelectQuestionNextsAggregateInput>;
  OR?: InputMaybe<Array<SelectQuestionNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<SelectQuestionNextsNodeAggregationWhereInput>;
};

export type SelectQuestionNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type SelectQuestionNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type SelectQuestionNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type SelectQuestionNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type SelectQuestionNextsFieldInput = {
  connect?: InputMaybe<Array<SelectQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<SelectQuestionNextsCreateFieldInput>>;
};

export type SelectQuestionNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<SelectQuestionNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<SelectQuestionNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<SelectQuestionNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type SelectQuestionNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type SelectQuestionNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<SelectQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<SelectQuestionNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<SelectQuestionNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<SelectQuestionNextsDisconnectFieldInput>>;
  update?: InputMaybe<SelectQuestionNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type SelectQuestionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more SelectQuestionSort objects to sort SelectQuestions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<SelectQuestionSort>>;
};

export type SelectQuestionPrevsAggregateInput = {
  AND?: InputMaybe<Array<SelectQuestionPrevsAggregateInput>>;
  NOT?: InputMaybe<SelectQuestionPrevsAggregateInput>;
  OR?: InputMaybe<Array<SelectQuestionPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<SelectQuestionPrevsNodeAggregationWhereInput>;
};

export type SelectQuestionPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type SelectQuestionPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type SelectQuestionPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type SelectQuestionPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type SelectQuestionPrevsFieldInput = {
  connect?: InputMaybe<Array<SelectQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<SelectQuestionPrevsCreateFieldInput>>;
};

export type SelectQuestionPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<SelectQuestionPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<SelectQuestionPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<SelectQuestionPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type SelectQuestionPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type SelectQuestionPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<SelectQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<SelectQuestionPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<SelectQuestionPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<SelectQuestionPrevsDisconnectFieldInput>>;
  update?: InputMaybe<SelectQuestionPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type SelectQuestionQuestionItemChoicesAggregationSelection = {
  __typename?: 'SelectQuestionQuestionItemChoicesAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<SelectQuestionQuestionItemChoicesNodeAggregateSelection>;
};

export type SelectQuestionQuestionItemChoicesNodeAggregateSelection = {
  __typename?: 'SelectQuestionQuestionItemChoicesNodeAggregateSelection';
  id: IdAggregateSelection;
  label: StringAggregateSelection;
  medicalLabel: StringAggregateSelection;
  order: IntAggregateSelection;
  score: IntAggregateSelection;
};

export type SelectQuestionQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'SelectQuestionQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<SelectQuestionQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<SelectQuestionQuestionnaireStepNextsNodeAggregateSelection>;
};

export type SelectQuestionQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'SelectQuestionQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type SelectQuestionQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'SelectQuestionQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type SelectQuestionQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'SelectQuestionQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<SelectQuestionQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<SelectQuestionQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type SelectQuestionQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'SelectQuestionQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type SelectQuestionQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'SelectQuestionQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type SelectQuestionRelationInput = {
  alerts?: InputMaybe<SelectQuestionAlertsCreateFieldInput>;
  answers?: InputMaybe<Array<SelectQuestionAnswersCreateFieldInput>>;
  choices?: InputMaybe<Array<SelectQuestionChoicesCreateFieldInput>>;
  cooldown?: InputMaybe<SelectQuestionCooldownCreateFieldInput>;
  graph?: InputMaybe<SelectQuestionGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<SelectQuestionNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<SelectQuestionPrevsCreateFieldInput>>;
};

/** Fields to sort SelectQuestions by. The order in which sorts are applied is not guaranteed when specifying many fields in one SelectQuestionSort object. */
export type SelectQuestionSort = {
  field?: InputMaybe<SortDirection>;
  hint?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  image?: InputMaybe<SortDirection>;
  multiple?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  placeholder?: InputMaybe<SortDirection>;
};

export type SelectQuestionUpdateInput = {
  alerts?: InputMaybe<SelectQuestionAlertsUpdateFieldInput>;
  answers?: InputMaybe<Array<SelectQuestionAnswersUpdateFieldInput>>;
  choices?: InputMaybe<Array<SelectQuestionChoicesUpdateFieldInput>>;
  cooldown?: InputMaybe<SelectQuestionCooldownUpdateFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<SelectQuestionGraphUpdateFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  multiple?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<SelectQuestionNextsUpdateFieldInput>>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  prevs?: InputMaybe<Array<SelectQuestionPrevsUpdateFieldInput>>;
};

export type SelectQuestionVersionnedGraphGraphAggregationSelection = {
  __typename?: 'SelectQuestionVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<SelectQuestionVersionnedGraphGraphNodeAggregateSelection>;
};

export type SelectQuestionVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'SelectQuestionVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type SelectQuestionWhere = {
  AND?: InputMaybe<Array<SelectQuestionWhere>>;
  NOT?: InputMaybe<SelectQuestionWhere>;
  OR?: InputMaybe<Array<SelectQuestionWhere>>;
  alerts?: InputMaybe<AlertGroupWhere>;
  alertsAggregate?: InputMaybe<SelectQuestionAlertsAggregateInput>;
  alertsConnection?: InputMaybe<QuestionAlertsConnectionWhere>;
  alertsConnection_NOT?: InputMaybe<QuestionAlertsConnectionWhere>;
  alerts_NOT?: InputMaybe<AlertGroupWhere>;
  answersAggregate?: InputMaybe<SelectQuestionAnswersAggregateInput>;
  /** Return SelectQuestions where all of the related QuestionAnswersConnections match this filter */
  answersConnection_ALL?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return SelectQuestions where none of the related QuestionAnswersConnections match this filter */
  answersConnection_NONE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return SelectQuestions where one of the related QuestionAnswersConnections match this filter */
  answersConnection_SINGLE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return SelectQuestions where some of the related QuestionAnswersConnections match this filter */
  answersConnection_SOME?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return SelectQuestions where all of the related Answers match this filter */
  answers_ALL?: InputMaybe<AnswerWhere>;
  /** Return SelectQuestions where none of the related Answers match this filter */
  answers_NONE?: InputMaybe<AnswerWhere>;
  /** Return SelectQuestions where one of the related Answers match this filter */
  answers_SINGLE?: InputMaybe<AnswerWhere>;
  /** Return SelectQuestions where some of the related Answers match this filter */
  answers_SOME?: InputMaybe<AnswerWhere>;
  choicesAggregate?: InputMaybe<SelectQuestionChoicesAggregateInput>;
  /** Return SelectQuestions where all of the related SelectQuestionChoicesConnections match this filter */
  choicesConnection_ALL?: InputMaybe<SelectQuestionChoicesConnectionWhere>;
  /** Return SelectQuestions where none of the related SelectQuestionChoicesConnections match this filter */
  choicesConnection_NONE?: InputMaybe<SelectQuestionChoicesConnectionWhere>;
  /** Return SelectQuestions where one of the related SelectQuestionChoicesConnections match this filter */
  choicesConnection_SINGLE?: InputMaybe<SelectQuestionChoicesConnectionWhere>;
  /** Return SelectQuestions where some of the related SelectQuestionChoicesConnections match this filter */
  choicesConnection_SOME?: InputMaybe<SelectQuestionChoicesConnectionWhere>;
  /** Return SelectQuestions where all of the related QuestionItems match this filter */
  choices_ALL?: InputMaybe<QuestionItemWhere>;
  /** Return SelectQuestions where none of the related QuestionItems match this filter */
  choices_NONE?: InputMaybe<QuestionItemWhere>;
  /** Return SelectQuestions where one of the related QuestionItems match this filter */
  choices_SINGLE?: InputMaybe<QuestionItemWhere>;
  /** Return SelectQuestions where some of the related QuestionItems match this filter */
  choices_SOME?: InputMaybe<QuestionItemWhere>;
  cooldown?: InputMaybe<CooldownWhere>;
  cooldownAggregate?: InputMaybe<SelectQuestionCooldownAggregateInput>;
  cooldownConnection?: InputMaybe<SelectQuestionCooldownConnectionWhere>;
  cooldownConnection_NOT?: InputMaybe<SelectQuestionCooldownConnectionWhere>;
  cooldown_NOT?: InputMaybe<CooldownWhere>;
  field?: InputMaybe<Scalars['String']['input']>;
  field_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  field_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  field_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  field_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<SelectQuestionGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  hint?: InputMaybe<Scalars['String']['input']>;
  hint_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  hint_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hint_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  image_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  image_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  image_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  image_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  multiple?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<SelectQuestionNextsAggregateInput>;
  /** Return SelectQuestions where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return SelectQuestions where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return SelectQuestions where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return SelectQuestions where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return SelectQuestions where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return SelectQuestions where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return SelectQuestions where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return SelectQuestions where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  placeholder_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  placeholder_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  placeholder_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  placeholder_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  prevsAggregate?: InputMaybe<SelectQuestionPrevsAggregateInput>;
  /** Return SelectQuestions where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return SelectQuestions where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return SelectQuestions where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return SelectQuestions where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return SelectQuestions where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return SelectQuestions where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return SelectQuestions where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return SelectQuestions where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type SelectQuestionsConnection = {
  __typename?: 'SelectQuestionsConnection';
  edges: Array<SelectQuestionEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type SerializationNode = {
  __typename?: 'SerializationNode';
  id: Scalars['Int']['output'];
  sockets: Array<SerializationSocket>;
  step: QuestionnaireStep;
  type: QuestionnaireType;
};

export type SerializationNodeAggregateSelection = {
  __typename?: 'SerializationNodeAggregateSelection';
  count: Scalars['Int']['output'];
  id: IntAggregateSelection;
};

export type SerializationNodeCreateInput = {
  id: Scalars['Int']['input'];
  type: QuestionnaireType;
};

export type SerializationNodeEdge = {
  __typename?: 'SerializationNodeEdge';
  cursor: Scalars['String']['output'];
  node: SerializationNode;
};

export type SerializationNodeInput = {
  alerts?: InputMaybe<AlertGroupInput>;
  choices?: InputMaybe<Array<QuestionItemInput>>;
  conditions?: InputMaybe<Array<ConditionGroupInput>>;
  cooldown?: InputMaybe<CooldownInput>;
  fields?: InputMaybe<Array<FieldInput>>;
  id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  questionnaireId?: InputMaybe<Scalars['ID']['input']>;
  questionnaires?: InputMaybe<Array<QuestionnaireMenuItemInput>>;
  selectMenu?: InputMaybe<Array<SelectMenuItemInput>>;
  sockets: Array<SerializationSocketInput>;
  type: QuestionnaireType;
};

export type SerializationNodeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more SerializationNodeSort objects to sort SerializationNodes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<SerializationNodeSort>>;
};

/** Fields to sort SerializationNodes by. The order in which sorts are applied is not guaranteed when specifying many fields in one SerializationNodeSort object. */
export type SerializationNodeSort = {
  id?: InputMaybe<SortDirection>;
  type?: InputMaybe<SortDirection>;
};

export type SerializationNodeUpdateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  id_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  id_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<QuestionnaireType>;
};

export type SerializationNodeWhere = {
  AND?: InputMaybe<Array<SerializationNodeWhere>>;
  NOT?: InputMaybe<SerializationNodeWhere>;
  OR?: InputMaybe<Array<SerializationNodeWhere>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  id_GT?: InputMaybe<Scalars['Int']['input']>;
  id_GTE?: InputMaybe<Scalars['Int']['input']>;
  id_IN?: InputMaybe<Array<Scalars['Int']['input']>>;
  id_LT?: InputMaybe<Scalars['Int']['input']>;
  id_LTE?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<QuestionnaireType>;
  type_IN?: InputMaybe<Array<QuestionnaireType>>;
};

export type SerializationNodesConnection = {
  __typename?: 'SerializationNodesConnection';
  edges: Array<SerializationNodeEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type SerializationSocket = {
  __typename?: 'SerializationSocket';
  attachedNodeId?: Maybe<Scalars['Int']['output']>;
  label?: Maybe<Scalars['String']['output']>;
};

export type SerializationSocketAggregateSelection = {
  __typename?: 'SerializationSocketAggregateSelection';
  attachedNodeId: IntAggregateSelection;
  count: Scalars['Int']['output'];
  label: StringAggregateSelection;
};

export type SerializationSocketCreateInput = {
  attachedNodeId?: InputMaybe<Scalars['Int']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export type SerializationSocketEdge = {
  __typename?: 'SerializationSocketEdge';
  cursor: Scalars['String']['output'];
  node: SerializationSocket;
};

export type SerializationSocketInput = {
  attachedNodeId?: InputMaybe<Scalars['Int']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export type SerializationSocketOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more SerializationSocketSort objects to sort SerializationSockets by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<SerializationSocketSort>>;
};

/** Fields to sort SerializationSockets by. The order in which sorts are applied is not guaranteed when specifying many fields in one SerializationSocketSort object. */
export type SerializationSocketSort = {
  attachedNodeId?: InputMaybe<SortDirection>;
  label?: InputMaybe<SortDirection>;
};

export type SerializationSocketUpdateInput = {
  attachedNodeId?: InputMaybe<Scalars['Int']['input']>;
  attachedNodeId_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  attachedNodeId_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
};

export type SerializationSocketWhere = {
  AND?: InputMaybe<Array<SerializationSocketWhere>>;
  NOT?: InputMaybe<SerializationSocketWhere>;
  OR?: InputMaybe<Array<SerializationSocketWhere>>;
  attachedNodeId?: InputMaybe<Scalars['Int']['input']>;
  attachedNodeId_GT?: InputMaybe<Scalars['Int']['input']>;
  attachedNodeId_GTE?: InputMaybe<Scalars['Int']['input']>;
  attachedNodeId_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  attachedNodeId_LT?: InputMaybe<Scalars['Int']['input']>;
  attachedNodeId_LTE?: InputMaybe<Scalars['Int']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  label_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  label_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  label_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  label_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type SerializationSocketsConnection = {
  __typename?: 'SerializationSocketsConnection';
  edges: Array<SerializationSocketEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/**
 * The edge properties for the following fields:
 * * TextQuestion.nexts
 * * TextQuestion.prevs
 * * SelectQuestion.nexts
 * * SelectQuestion.prevs
 * * RangeQuestion.nexts
 * * RangeQuestion.prevs
 * * CheckboxQuestion.nexts
 * * CheckboxQuestion.prevs
 * * RadioQuestion.nexts
 * * RadioQuestion.prevs
 * * DateQuestion.nexts
 * * DateQuestion.prevs
 * * QuestionnaireWelcomeStep.nexts
 * * QuestionnaireWelcomeStep.prevs
 * * QuestionnaireInfoStep.nexts
 * * QuestionnaireInfoStep.prevs
 * * QuestionnaireCondition.nexts
 * * QuestionnaireCondition.prevs
 * * QuestionnaireAppointmentDate.nexts
 * * QuestionnaireAppointmentDate.prevs
 * * QuestionnaireDocument.nexts
 * * QuestionnaireDocument.prevs
 * * QuestionnaireIdentity.nexts
 * * QuestionnaireIdentity.prevs
 * * QuestionnaireRouter.nexts
 * * QuestionnaireRouter.prevs
 * * QuestionnaireMenu.nexts
 * * QuestionnaireMenu.prevs
 * * QuestionnaireInterview.nexts
 * * QuestionnaireInterview.prevs
 * * QuestionnaireSelectMenu.nexts
 * * QuestionnaireSelectMenu.prevs
 * * QuestionnaireSurvey.nexts
 * * QuestionnaireSurvey.prevs
 * * QuestionnaireThirdParty.nexts
 * * QuestionnaireThirdParty.prevs
 * * QuestionnaireSetProperty.nexts
 * * QuestionnaireSetProperty.prevs
 * * QuestionnaireDocumentFiller.nexts
 * * QuestionnaireDocumentFiller.prevs
 * * QuestionnaireAi.nexts
 * * QuestionnaireAi.prevs
 */
export type Socket = {
  __typename?: 'Socket';
  label?: Maybe<Scalars['String']['output']>;
};

export type SocketAggregationWhereInput = {
  AND?: InputMaybe<Array<SocketAggregationWhereInput>>;
  NOT?: InputMaybe<SocketAggregationWhereInput>;
  OR?: InputMaybe<Array<SocketAggregationWhereInput>>;
  label_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  label_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  label_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  label_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type SocketCreateInput = {
  label?: InputMaybe<Scalars['String']['input']>;
};

export type SocketSort = {
  label?: InputMaybe<SortDirection>;
};

export type SocketUpdateInput = {
  label?: InputMaybe<Scalars['String']['input']>;
};

export type SocketWhere = {
  AND?: InputMaybe<Array<SocketWhere>>;
  NOT?: InputMaybe<SocketWhere>;
  OR?: InputMaybe<Array<SocketWhere>>;
  label?: InputMaybe<Scalars['String']['input']>;
  label_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  label_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  label_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  label_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

/** An enum for sorting in either ascending or descending order. */
export enum SortDirection {
  /** Sort by field values in ascending order. */
  Asc = 'ASC',
  /** Sort by field values in descending order. */
  Desc = 'DESC'
}

export type SpecialitiesConnection = {
  __typename?: 'SpecialitiesConnection';
  edges: Array<SpecialityEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type Speciality = {
  __typename?: 'Speciality';
  defaultWorkflow?: Maybe<Workflow>;
  defaultWorkflowAggregate?: Maybe<SpecialityWorkflowDefaultWorkflowAggregationSelection>;
  defaultWorkflowConnection: SpecialityDefaultWorkflowConnection;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  nameNormalized: Scalars['String']['output'];
};


export type SpecialityDefaultWorkflowArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<WorkflowOptions>;
  where?: InputMaybe<WorkflowWhere>;
};


export type SpecialityDefaultWorkflowAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<WorkflowWhere>;
};


export type SpecialityDefaultWorkflowConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<SpecialityDefaultWorkflowConnectionSort>>;
  where?: InputMaybe<SpecialityDefaultWorkflowConnectionWhere>;
};

export type SpecialityAggregateSelection = {
  __typename?: 'SpecialityAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type SpecialityConnectInput = {
  defaultWorkflow?: InputMaybe<SpecialityDefaultWorkflowConnectFieldInput>;
};

export type SpecialityConnectOrCreateInput = {
  defaultWorkflow?: InputMaybe<SpecialityDefaultWorkflowConnectOrCreateFieldInput>;
};

export type SpecialityConnectOrCreateWhere = {
  node: SpecialityUniqueWhere;
};

export type SpecialityConnectWhere = {
  node: SpecialityWhere;
};

export type SpecialityCreateInput = {
  defaultWorkflow?: InputMaybe<SpecialityDefaultWorkflowFieldInput>;
  name: Scalars['String']['input'];
};

export type SpecialityDefaultWorkflowAggregateInput = {
  AND?: InputMaybe<Array<SpecialityDefaultWorkflowAggregateInput>>;
  NOT?: InputMaybe<SpecialityDefaultWorkflowAggregateInput>;
  OR?: InputMaybe<Array<SpecialityDefaultWorkflowAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<SpecialityDefaultWorkflowNodeAggregationWhereInput>;
};

export type SpecialityDefaultWorkflowConnectFieldInput = {
  connect?: InputMaybe<WorkflowConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<WorkflowConnectWhere>;
};

export type SpecialityDefaultWorkflowConnectOrCreateFieldInput = {
  onCreate: SpecialityDefaultWorkflowConnectOrCreateFieldInputOnCreate;
  where: WorkflowConnectOrCreateWhere;
};

export type SpecialityDefaultWorkflowConnectOrCreateFieldInputOnCreate = {
  node: WorkflowOnCreateInput;
};

export type SpecialityDefaultWorkflowConnection = {
  __typename?: 'SpecialityDefaultWorkflowConnection';
  edges: Array<SpecialityDefaultWorkflowRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type SpecialityDefaultWorkflowConnectionSort = {
  node?: InputMaybe<WorkflowSort>;
};

export type SpecialityDefaultWorkflowConnectionWhere = {
  AND?: InputMaybe<Array<SpecialityDefaultWorkflowConnectionWhere>>;
  NOT?: InputMaybe<SpecialityDefaultWorkflowConnectionWhere>;
  OR?: InputMaybe<Array<SpecialityDefaultWorkflowConnectionWhere>>;
  node?: InputMaybe<WorkflowWhere>;
};

export type SpecialityDefaultWorkflowCreateFieldInput = {
  node: WorkflowCreateInput;
};

export type SpecialityDefaultWorkflowDeleteFieldInput = {
  delete?: InputMaybe<WorkflowDeleteInput>;
  where?: InputMaybe<SpecialityDefaultWorkflowConnectionWhere>;
};

export type SpecialityDefaultWorkflowDisconnectFieldInput = {
  disconnect?: InputMaybe<WorkflowDisconnectInput>;
  where?: InputMaybe<SpecialityDefaultWorkflowConnectionWhere>;
};

export type SpecialityDefaultWorkflowFieldInput = {
  connect?: InputMaybe<SpecialityDefaultWorkflowConnectFieldInput>;
  connectOrCreate?: InputMaybe<SpecialityDefaultWorkflowConnectOrCreateFieldInput>;
  create?: InputMaybe<SpecialityDefaultWorkflowCreateFieldInput>;
};

export type SpecialityDefaultWorkflowNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<SpecialityDefaultWorkflowNodeAggregationWhereInput>>;
  NOT?: InputMaybe<SpecialityDefaultWorkflowNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<SpecialityDefaultWorkflowNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type SpecialityDefaultWorkflowRelationship = {
  __typename?: 'SpecialityDefaultWorkflowRelationship';
  cursor: Scalars['String']['output'];
  node: Workflow;
};

export type SpecialityDefaultWorkflowUpdateConnectionInput = {
  node?: InputMaybe<WorkflowUpdateInput>;
};

export type SpecialityDefaultWorkflowUpdateFieldInput = {
  connect?: InputMaybe<SpecialityDefaultWorkflowConnectFieldInput>;
  connectOrCreate?: InputMaybe<SpecialityDefaultWorkflowConnectOrCreateFieldInput>;
  create?: InputMaybe<SpecialityDefaultWorkflowCreateFieldInput>;
  delete?: InputMaybe<SpecialityDefaultWorkflowDeleteFieldInput>;
  disconnect?: InputMaybe<SpecialityDefaultWorkflowDisconnectFieldInput>;
  update?: InputMaybe<SpecialityDefaultWorkflowUpdateConnectionInput>;
  where?: InputMaybe<SpecialityDefaultWorkflowConnectionWhere>;
};

export type SpecialityDeleteInput = {
  defaultWorkflow?: InputMaybe<SpecialityDefaultWorkflowDeleteFieldInput>;
};

export type SpecialityDisconnectInput = {
  defaultWorkflow?: InputMaybe<SpecialityDefaultWorkflowDisconnectFieldInput>;
};

export type SpecialityEdge = {
  __typename?: 'SpecialityEdge';
  cursor: Scalars['String']['output'];
  node: Speciality;
};

export type SpecialityOnCreateInput = {
  name: Scalars['String']['input'];
};

export type SpecialityOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more SpecialitySort objects to sort Specialities by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<SpecialitySort>>;
};

export type SpecialityRelationInput = {
  defaultWorkflow?: InputMaybe<SpecialityDefaultWorkflowCreateFieldInput>;
};

/** Fields to sort Specialities by. The order in which sorts are applied is not guaranteed when specifying many fields in one SpecialitySort object. */
export type SpecialitySort = {
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  nameNormalized?: InputMaybe<SortDirection>;
};

export type SpecialityUniqueWhere = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type SpecialityUpdateInput = {
  defaultWorkflow?: InputMaybe<SpecialityDefaultWorkflowUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type SpecialityWhere = {
  AND?: InputMaybe<Array<SpecialityWhere>>;
  NOT?: InputMaybe<SpecialityWhere>;
  OR?: InputMaybe<Array<SpecialityWhere>>;
  defaultWorkflow?: InputMaybe<WorkflowWhere>;
  defaultWorkflowAggregate?: InputMaybe<SpecialityDefaultWorkflowAggregateInput>;
  defaultWorkflowConnection?: InputMaybe<SpecialityDefaultWorkflowConnectionWhere>;
  defaultWorkflowConnection_NOT?: InputMaybe<SpecialityDefaultWorkflowConnectionWhere>;
  defaultWorkflow_NOT?: InputMaybe<WorkflowWhere>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nameNormalized?: InputMaybe<Scalars['String']['input']>;
  nameNormalized_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  nameNormalized_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  nameNormalized_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  nameNormalized_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
};

export type SpecialityWorkflowDefaultWorkflowAggregationSelection = {
  __typename?: 'SpecialityWorkflowDefaultWorkflowAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<SpecialityWorkflowDefaultWorkflowNodeAggregateSelection>;
};

export type SpecialityWorkflowDefaultWorkflowNodeAggregateSelection = {
  __typename?: 'SpecialityWorkflowDefaultWorkflowNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type StringAggregateSelection = {
  __typename?: 'StringAggregateSelection';
  longest?: Maybe<Scalars['String']['output']>;
  shortest?: Maybe<Scalars['String']['output']>;
};

export enum SubscriptionPlan {
  Basic = 'Basic',
  Comfort = 'Comfort',
  Demo = 'Demo',
  Premium = 'Premium',
  Standard = 'Standard'
}

export type TextQuestion = Question & QuestionnaireStep & {
  __typename?: 'TextQuestion';
  alerts?: Maybe<AlertGroup>;
  alertsAggregate?: Maybe<TextQuestionAlertGroupAlertsAggregationSelection>;
  alertsConnection: QuestionAlertsConnection;
  answers: Array<Answer>;
  answersAggregate?: Maybe<TextQuestionAnswerAnswersAggregationSelection>;
  answersConnection: QuestionAnswersConnection;
  cooldown?: Maybe<Cooldown>;
  cooldownAggregate?: Maybe<TextQuestionCooldownCooldownAggregationSelection>;
  cooldownConnection: TextQuestionCooldownConnection;
  field?: Maybe<Scalars['String']['output']>;
  graph: VersionnedGraph;
  graphAggregate?: Maybe<TextQuestionVersionnedGraphGraphAggregationSelection>;
  graphConnection: QuestionnaireStepGraphConnection;
  hint?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  nextIds: Array<Scalars['String']['output']>;
  nexts: Array<QuestionnaireStep>;
  nextsAggregate?: Maybe<TextQuestionQuestionnaireStepNextsAggregationSelection>;
  nextsConnection: QuestionnaireStepNextsConnection;
  placeholder?: Maybe<Scalars['String']['output']>;
  prevs: Array<QuestionnaireStep>;
  prevsAggregate?: Maybe<TextQuestionQuestionnaireStepPrevsAggregationSelection>;
  prevsConnection: QuestionnaireStepPrevsConnection;
};


export type TextQuestionAlertsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AlertGroupOptions>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type TextQuestionAlertsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type TextQuestionAlertsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};


export type TextQuestionAnswersArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AnswerOptions>;
  where?: InputMaybe<AnswerWhere>;
};


export type TextQuestionAnswersAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AnswerWhere>;
};


export type TextQuestionAnswersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionAnswersConnectionSort>>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};


export type TextQuestionCooldownArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<CooldownOptions>;
  where?: InputMaybe<CooldownWhere>;
};


export type TextQuestionCooldownAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<CooldownWhere>;
};


export type TextQuestionCooldownConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<TextQuestionCooldownConnectionSort>>;
  where?: InputMaybe<TextQuestionCooldownConnectionWhere>;
};


export type TextQuestionGraphArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type TextQuestionGraphAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type TextQuestionGraphConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepGraphConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};


export type TextQuestionNextsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type TextQuestionNextsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type TextQuestionNextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepNextsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};


export type TextQuestionPrevsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type TextQuestionPrevsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type TextQuestionPrevsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<QuestionnaireStepPrevsConnectionSort>>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type TextQuestionAggregateSelection = {
  __typename?: 'TextQuestionAggregateSelection';
  count: Scalars['Int']['output'];
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  id: IdAggregateSelection;
  image: StringAggregateSelection;
  name: StringAggregateSelection;
  placeholder: StringAggregateSelection;
};

export type TextQuestionAlertGroupAlertsAggregationSelection = {
  __typename?: 'TextQuestionAlertGroupAlertsAggregationSelection';
  count: Scalars['Int']['output'];
};

export type TextQuestionAlertsAggregateInput = {
  AND?: InputMaybe<Array<TextQuestionAlertsAggregateInput>>;
  NOT?: InputMaybe<TextQuestionAlertsAggregateInput>;
  OR?: InputMaybe<Array<TextQuestionAlertsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type TextQuestionAlertsConnectFieldInput = {
  connect?: InputMaybe<AlertGroupConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AlertGroupConnectWhere>;
};

export type TextQuestionAlertsCreateFieldInput = {
  node: AlertGroupCreateInput;
};

export type TextQuestionAlertsFieldInput = {
  connect?: InputMaybe<TextQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<TextQuestionAlertsCreateFieldInput>;
};

export type TextQuestionAlertsUpdateConnectionInput = {
  node?: InputMaybe<AlertGroupUpdateInput>;
};

export type TextQuestionAlertsUpdateFieldInput = {
  connect?: InputMaybe<TextQuestionAlertsConnectFieldInput>;
  create?: InputMaybe<TextQuestionAlertsCreateFieldInput>;
  delete?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  update?: InputMaybe<TextQuestionAlertsUpdateConnectionInput>;
  where?: InputMaybe<QuestionAlertsConnectionWhere>;
};

export type TextQuestionAnswerAnswersAggregationSelection = {
  __typename?: 'TextQuestionAnswerAnswersAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<TextQuestionAnswerAnswersNodeAggregateSelection>;
};

export type TextQuestionAnswerAnswersNodeAggregateSelection = {
  __typename?: 'TextQuestionAnswerAnswersNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
  field: StringAggregateSelection;
  hint: StringAggregateSelection;
  order: IntAggregateSelection;
};

export type TextQuestionAnswersAggregateInput = {
  AND?: InputMaybe<Array<TextQuestionAnswersAggregateInput>>;
  NOT?: InputMaybe<TextQuestionAnswersAggregateInput>;
  OR?: InputMaybe<Array<TextQuestionAnswersAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<TextQuestionAnswersNodeAggregationWhereInput>;
};

export type TextQuestionAnswersConnectFieldInput = {
  connect?: InputMaybe<Array<AnswerConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AnswerConnectWhere>;
};

export type TextQuestionAnswersCreateFieldInput = {
  node: AnswerCreateInput;
};

export type TextQuestionAnswersFieldInput = {
  connect?: InputMaybe<Array<TextQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<TextQuestionAnswersCreateFieldInput>>;
};

export type TextQuestionAnswersNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<TextQuestionAnswersNodeAggregationWhereInput>>;
  NOT?: InputMaybe<TextQuestionAnswersNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<TextQuestionAnswersNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  field_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  field_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  field_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  field_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  hint_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  hint_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  hint_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  order_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  order_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  order_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  order_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type TextQuestionAnswersUpdateConnectionInput = {
  node?: InputMaybe<AnswerUpdateInput>;
};

export type TextQuestionAnswersUpdateFieldInput = {
  connect?: InputMaybe<Array<TextQuestionAnswersConnectFieldInput>>;
  create?: InputMaybe<Array<TextQuestionAnswersCreateFieldInput>>;
  delete?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  update?: InputMaybe<TextQuestionAnswersUpdateConnectionInput>;
  where?: InputMaybe<QuestionAnswersConnectionWhere>;
};

export type TextQuestionConnectInput = {
  alerts?: InputMaybe<TextQuestionAlertsConnectFieldInput>;
  answers?: InputMaybe<Array<TextQuestionAnswersConnectFieldInput>>;
  cooldown?: InputMaybe<TextQuestionCooldownConnectFieldInput>;
  graph?: InputMaybe<TextQuestionGraphConnectFieldInput>;
  nexts?: InputMaybe<Array<TextQuestionNextsConnectFieldInput>>;
  prevs?: InputMaybe<Array<TextQuestionPrevsConnectFieldInput>>;
};

export type TextQuestionCooldownAggregateInput = {
  AND?: InputMaybe<Array<TextQuestionCooldownAggregateInput>>;
  NOT?: InputMaybe<TextQuestionCooldownAggregateInput>;
  OR?: InputMaybe<Array<TextQuestionCooldownAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<TextQuestionCooldownNodeAggregationWhereInput>;
};

export type TextQuestionCooldownConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<CooldownConnectWhere>;
};

export type TextQuestionCooldownConnection = {
  __typename?: 'TextQuestionCooldownConnection';
  edges: Array<TextQuestionCooldownRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type TextQuestionCooldownConnectionSort = {
  node?: InputMaybe<CooldownSort>;
};

export type TextQuestionCooldownConnectionWhere = {
  AND?: InputMaybe<Array<TextQuestionCooldownConnectionWhere>>;
  NOT?: InputMaybe<TextQuestionCooldownConnectionWhere>;
  OR?: InputMaybe<Array<TextQuestionCooldownConnectionWhere>>;
  node?: InputMaybe<CooldownWhere>;
};

export type TextQuestionCooldownCooldownAggregationSelection = {
  __typename?: 'TextQuestionCooldownCooldownAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<TextQuestionCooldownCooldownNodeAggregateSelection>;
};

export type TextQuestionCooldownCooldownNodeAggregateSelection = {
  __typename?: 'TextQuestionCooldownCooldownNodeAggregateSelection';
  value: IntAggregateSelection;
};

export type TextQuestionCooldownCreateFieldInput = {
  node: CooldownCreateInput;
};

export type TextQuestionCooldownDeleteFieldInput = {
  where?: InputMaybe<TextQuestionCooldownConnectionWhere>;
};

export type TextQuestionCooldownDisconnectFieldInput = {
  where?: InputMaybe<TextQuestionCooldownConnectionWhere>;
};

export type TextQuestionCooldownFieldInput = {
  connect?: InputMaybe<TextQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<TextQuestionCooldownCreateFieldInput>;
};

export type TextQuestionCooldownNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<TextQuestionCooldownNodeAggregationWhereInput>>;
  NOT?: InputMaybe<TextQuestionCooldownNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<TextQuestionCooldownNodeAggregationWhereInput>>;
  value_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  value_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type TextQuestionCooldownRelationship = {
  __typename?: 'TextQuestionCooldownRelationship';
  cursor: Scalars['String']['output'];
  node: Cooldown;
};

export type TextQuestionCooldownUpdateConnectionInput = {
  node?: InputMaybe<CooldownUpdateInput>;
};

export type TextQuestionCooldownUpdateFieldInput = {
  connect?: InputMaybe<TextQuestionCooldownConnectFieldInput>;
  create?: InputMaybe<TextQuestionCooldownCreateFieldInput>;
  delete?: InputMaybe<TextQuestionCooldownDeleteFieldInput>;
  disconnect?: InputMaybe<TextQuestionCooldownDisconnectFieldInput>;
  update?: InputMaybe<TextQuestionCooldownUpdateConnectionInput>;
  where?: InputMaybe<TextQuestionCooldownConnectionWhere>;
};

export type TextQuestionCreateInput = {
  alerts?: InputMaybe<TextQuestionAlertsFieldInput>;
  answers?: InputMaybe<TextQuestionAnswersFieldInput>;
  cooldown?: InputMaybe<TextQuestionCooldownFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<TextQuestionGraphFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  nexts?: InputMaybe<TextQuestionNextsFieldInput>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  prevs?: InputMaybe<TextQuestionPrevsFieldInput>;
};

export type TextQuestionDeleteInput = {
  alerts?: InputMaybe<QuestionAlertsDeleteFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDeleteFieldInput>>;
  cooldown?: InputMaybe<TextQuestionCooldownDeleteFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  nexts?: InputMaybe<Array<TextQuestionNextsDeleteFieldInput>>;
  prevs?: InputMaybe<Array<TextQuestionPrevsDeleteFieldInput>>;
};

export type TextQuestionDisconnectInput = {
  alerts?: InputMaybe<QuestionAlertsDisconnectFieldInput>;
  answers?: InputMaybe<Array<QuestionAnswersDisconnectFieldInput>>;
  cooldown?: InputMaybe<TextQuestionCooldownDisconnectFieldInput>;
  graph?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  nexts?: InputMaybe<Array<TextQuestionNextsDisconnectFieldInput>>;
  prevs?: InputMaybe<Array<TextQuestionPrevsDisconnectFieldInput>>;
};

export type TextQuestionEdge = {
  __typename?: 'TextQuestionEdge';
  cursor: Scalars['String']['output'];
  node: TextQuestion;
};

export type TextQuestionGraphAggregateInput = {
  AND?: InputMaybe<Array<TextQuestionGraphAggregateInput>>;
  NOT?: InputMaybe<TextQuestionGraphAggregateInput>;
  OR?: InputMaybe<Array<TextQuestionGraphAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<TextQuestionGraphNodeAggregationWhereInput>;
};

export type TextQuestionGraphConnectFieldInput = {
  connect?: InputMaybe<VersionnedGraphConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type TextQuestionGraphCreateFieldInput = {
  node: VersionnedGraphCreateInput;
};

export type TextQuestionGraphFieldInput = {
  connect?: InputMaybe<TextQuestionGraphConnectFieldInput>;
  create?: InputMaybe<TextQuestionGraphCreateFieldInput>;
};

export type TextQuestionGraphNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<TextQuestionGraphNodeAggregationWhereInput>>;
  NOT?: InputMaybe<TextQuestionGraphNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<TextQuestionGraphNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type TextQuestionGraphUpdateConnectionInput = {
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type TextQuestionGraphUpdateFieldInput = {
  connect?: InputMaybe<TextQuestionGraphConnectFieldInput>;
  create?: InputMaybe<TextQuestionGraphCreateFieldInput>;
  delete?: InputMaybe<QuestionnaireStepGraphDeleteFieldInput>;
  disconnect?: InputMaybe<QuestionnaireStepGraphDisconnectFieldInput>;
  update?: InputMaybe<TextQuestionGraphUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
};

export type TextQuestionNextsAggregateInput = {
  AND?: InputMaybe<Array<TextQuestionNextsAggregateInput>>;
  NOT?: InputMaybe<TextQuestionNextsAggregateInput>;
  OR?: InputMaybe<Array<TextQuestionNextsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<TextQuestionNextsNodeAggregationWhereInput>;
};

export type TextQuestionNextsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type TextQuestionNextsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type TextQuestionNextsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type TextQuestionNextsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type TextQuestionNextsFieldInput = {
  connect?: InputMaybe<Array<TextQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<TextQuestionNextsCreateFieldInput>>;
};

export type TextQuestionNextsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<TextQuestionNextsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<TextQuestionNextsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<TextQuestionNextsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type TextQuestionNextsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type TextQuestionNextsUpdateFieldInput = {
  connect?: InputMaybe<Array<TextQuestionNextsConnectFieldInput>>;
  create?: InputMaybe<Array<TextQuestionNextsCreateFieldInput>>;
  delete?: InputMaybe<Array<TextQuestionNextsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<TextQuestionNextsDisconnectFieldInput>>;
  update?: InputMaybe<TextQuestionNextsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
};

export type TextQuestionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more TextQuestionSort objects to sort TextQuestions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<TextQuestionSort>>;
};

export type TextQuestionPrevsAggregateInput = {
  AND?: InputMaybe<Array<TextQuestionPrevsAggregateInput>>;
  NOT?: InputMaybe<TextQuestionPrevsAggregateInput>;
  OR?: InputMaybe<Array<TextQuestionPrevsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<SocketAggregationWhereInput>;
  node?: InputMaybe<TextQuestionPrevsNodeAggregationWhereInput>;
};

export type TextQuestionPrevsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  edge?: InputMaybe<SocketCreateInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type TextQuestionPrevsCreateFieldInput = {
  edge?: InputMaybe<SocketCreateInput>;
  node: QuestionnaireStepCreateInput;
};

export type TextQuestionPrevsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type TextQuestionPrevsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type TextQuestionPrevsFieldInput = {
  connect?: InputMaybe<Array<TextQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<TextQuestionPrevsCreateFieldInput>>;
};

export type TextQuestionPrevsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<TextQuestionPrevsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<TextQuestionPrevsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<TextQuestionPrevsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type TextQuestionPrevsUpdateConnectionInput = {
  edge?: InputMaybe<SocketUpdateInput>;
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type TextQuestionPrevsUpdateFieldInput = {
  connect?: InputMaybe<Array<TextQuestionPrevsConnectFieldInput>>;
  create?: InputMaybe<Array<TextQuestionPrevsCreateFieldInput>>;
  delete?: InputMaybe<Array<TextQuestionPrevsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<TextQuestionPrevsDisconnectFieldInput>>;
  update?: InputMaybe<TextQuestionPrevsUpdateConnectionInput>;
  where?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
};

export type TextQuestionQuestionnaireStepNextsAggregationSelection = {
  __typename?: 'TextQuestionQuestionnaireStepNextsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<TextQuestionQuestionnaireStepNextsEdgeAggregateSelection>;
  node?: Maybe<TextQuestionQuestionnaireStepNextsNodeAggregateSelection>;
};

export type TextQuestionQuestionnaireStepNextsEdgeAggregateSelection = {
  __typename?: 'TextQuestionQuestionnaireStepNextsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type TextQuestionQuestionnaireStepNextsNodeAggregateSelection = {
  __typename?: 'TextQuestionQuestionnaireStepNextsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type TextQuestionQuestionnaireStepPrevsAggregationSelection = {
  __typename?: 'TextQuestionQuestionnaireStepPrevsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<TextQuestionQuestionnaireStepPrevsEdgeAggregateSelection>;
  node?: Maybe<TextQuestionQuestionnaireStepPrevsNodeAggregateSelection>;
};

export type TextQuestionQuestionnaireStepPrevsEdgeAggregateSelection = {
  __typename?: 'TextQuestionQuestionnaireStepPrevsEdgeAggregateSelection';
  label: StringAggregateSelection;
};

export type TextQuestionQuestionnaireStepPrevsNodeAggregateSelection = {
  __typename?: 'TextQuestionQuestionnaireStepPrevsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type TextQuestionRelationInput = {
  alerts?: InputMaybe<TextQuestionAlertsCreateFieldInput>;
  answers?: InputMaybe<Array<TextQuestionAnswersCreateFieldInput>>;
  cooldown?: InputMaybe<TextQuestionCooldownCreateFieldInput>;
  graph?: InputMaybe<TextQuestionGraphCreateFieldInput>;
  nexts?: InputMaybe<Array<TextQuestionNextsCreateFieldInput>>;
  prevs?: InputMaybe<Array<TextQuestionPrevsCreateFieldInput>>;
};

/** Fields to sort TextQuestions by. The order in which sorts are applied is not guaranteed when specifying many fields in one TextQuestionSort object. */
export type TextQuestionSort = {
  field?: InputMaybe<SortDirection>;
  hint?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  image?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
  placeholder?: InputMaybe<SortDirection>;
};

export type TextQuestionUpdateInput = {
  alerts?: InputMaybe<TextQuestionAlertsUpdateFieldInput>;
  answers?: InputMaybe<Array<TextQuestionAnswersUpdateFieldInput>>;
  cooldown?: InputMaybe<TextQuestionCooldownUpdateFieldInput>;
  field?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<TextQuestionGraphUpdateFieldInput>;
  hint?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nexts?: InputMaybe<Array<TextQuestionNextsUpdateFieldInput>>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  prevs?: InputMaybe<Array<TextQuestionPrevsUpdateFieldInput>>;
};

export type TextQuestionVersionnedGraphGraphAggregationSelection = {
  __typename?: 'TextQuestionVersionnedGraphGraphAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<TextQuestionVersionnedGraphGraphNodeAggregateSelection>;
};

export type TextQuestionVersionnedGraphGraphNodeAggregateSelection = {
  __typename?: 'TextQuestionVersionnedGraphGraphNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type TextQuestionWhere = {
  AND?: InputMaybe<Array<TextQuestionWhere>>;
  NOT?: InputMaybe<TextQuestionWhere>;
  OR?: InputMaybe<Array<TextQuestionWhere>>;
  alerts?: InputMaybe<AlertGroupWhere>;
  alertsAggregate?: InputMaybe<TextQuestionAlertsAggregateInput>;
  alertsConnection?: InputMaybe<QuestionAlertsConnectionWhere>;
  alertsConnection_NOT?: InputMaybe<QuestionAlertsConnectionWhere>;
  alerts_NOT?: InputMaybe<AlertGroupWhere>;
  answersAggregate?: InputMaybe<TextQuestionAnswersAggregateInput>;
  /** Return TextQuestions where all of the related QuestionAnswersConnections match this filter */
  answersConnection_ALL?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return TextQuestions where none of the related QuestionAnswersConnections match this filter */
  answersConnection_NONE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return TextQuestions where one of the related QuestionAnswersConnections match this filter */
  answersConnection_SINGLE?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return TextQuestions where some of the related QuestionAnswersConnections match this filter */
  answersConnection_SOME?: InputMaybe<QuestionAnswersConnectionWhere>;
  /** Return TextQuestions where all of the related Answers match this filter */
  answers_ALL?: InputMaybe<AnswerWhere>;
  /** Return TextQuestions where none of the related Answers match this filter */
  answers_NONE?: InputMaybe<AnswerWhere>;
  /** Return TextQuestions where one of the related Answers match this filter */
  answers_SINGLE?: InputMaybe<AnswerWhere>;
  /** Return TextQuestions where some of the related Answers match this filter */
  answers_SOME?: InputMaybe<AnswerWhere>;
  cooldown?: InputMaybe<CooldownWhere>;
  cooldownAggregate?: InputMaybe<TextQuestionCooldownAggregateInput>;
  cooldownConnection?: InputMaybe<TextQuestionCooldownConnectionWhere>;
  cooldownConnection_NOT?: InputMaybe<TextQuestionCooldownConnectionWhere>;
  cooldown_NOT?: InputMaybe<CooldownWhere>;
  field?: InputMaybe<Scalars['String']['input']>;
  field_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  field_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  field_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  field_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  graph?: InputMaybe<VersionnedGraphWhere>;
  graphAggregate?: InputMaybe<TextQuestionGraphAggregateInput>;
  graphConnection?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graphConnection_NOT?: InputMaybe<QuestionnaireStepGraphConnectionWhere>;
  graph_NOT?: InputMaybe<VersionnedGraphWhere>;
  hint?: InputMaybe<Scalars['String']['input']>;
  hint_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  hint_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  hint_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hint_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  image_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  image_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  image_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  image_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  nextIds?: InputMaybe<Array<Scalars['String']['input']>>;
  nextIds_INCLUDES?: InputMaybe<Scalars['String']['input']>;
  nextsAggregate?: InputMaybe<TextQuestionNextsAggregateInput>;
  /** Return TextQuestions where all of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_ALL?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return TextQuestions where none of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_NONE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return TextQuestions where one of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SINGLE?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return TextQuestions where some of the related QuestionnaireStepNextsConnections match this filter */
  nextsConnection_SOME?: InputMaybe<QuestionnaireStepNextsConnectionWhere>;
  /** Return TextQuestions where all of the related QuestionnaireSteps match this filter */
  nexts_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return TextQuestions where none of the related QuestionnaireSteps match this filter */
  nexts_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return TextQuestions where one of the related QuestionnaireSteps match this filter */
  nexts_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return TextQuestions where some of the related QuestionnaireSteps match this filter */
  nexts_SOME?: InputMaybe<QuestionnaireStepWhere>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  placeholder_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  placeholder_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  placeholder_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  placeholder_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  prevsAggregate?: InputMaybe<TextQuestionPrevsAggregateInput>;
  /** Return TextQuestions where all of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_ALL?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return TextQuestions where none of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_NONE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return TextQuestions where one of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SINGLE?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return TextQuestions where some of the related QuestionnaireStepPrevsConnections match this filter */
  prevsConnection_SOME?: InputMaybe<QuestionnaireStepPrevsConnectionWhere>;
  /** Return TextQuestions where all of the related QuestionnaireSteps match this filter */
  prevs_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return TextQuestions where none of the related QuestionnaireSteps match this filter */
  prevs_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return TextQuestions where one of the related QuestionnaireSteps match this filter */
  prevs_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return TextQuestions where some of the related QuestionnaireSteps match this filter */
  prevs_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type TextQuestionsConnection = {
  __typename?: 'TextQuestionsConnection';
  edges: Array<TextQuestionEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type UnserializationResponse = {
  __typename?: 'UnserializationResponse';
  isTemplate: Scalars['Boolean']['output'];
  nodes: Array<SerializationNode>;
};

export type UnserializationResponseAggregateSelection = {
  __typename?: 'UnserializationResponseAggregateSelection';
  count: Scalars['Int']['output'];
};

export type UnserializationResponseCreateInput = {
  isTemplate: Scalars['Boolean']['input'];
};

export type UnserializationResponseEdge = {
  __typename?: 'UnserializationResponseEdge';
  cursor: Scalars['String']['output'];
  node: UnserializationResponse;
};

export type UnserializationResponseOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more UnserializationResponseSort objects to sort UnserializationResponses by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<UnserializationResponseSort>>;
};

/** Fields to sort UnserializationResponses by. The order in which sorts are applied is not guaranteed when specifying many fields in one UnserializationResponseSort object. */
export type UnserializationResponseSort = {
  isTemplate?: InputMaybe<SortDirection>;
};

export type UnserializationResponseUpdateInput = {
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UnserializationResponseWhere = {
  AND?: InputMaybe<Array<UnserializationResponseWhere>>;
  NOT?: InputMaybe<UnserializationResponseWhere>;
  OR?: InputMaybe<Array<UnserializationResponseWhere>>;
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UnserializationResponsesConnection = {
  __typename?: 'UnserializationResponsesConnection';
  edges: Array<UnserializationResponseEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type UpdateAiResponsesMutationResponse = {
  __typename?: 'UpdateAiResponsesMutationResponse';
  aiResponses: Array<AiResponse>;
  info: UpdateInfo;
};

export type UpdateAlertGroupsMutationResponse = {
  __typename?: 'UpdateAlertGroupsMutationResponse';
  alertGroups: Array<AlertGroup>;
  info: UpdateInfo;
};

export type UpdateAlertsMutationResponse = {
  __typename?: 'UpdateAlertsMutationResponse';
  alerts: Array<Alert>;
  info: UpdateInfo;
};

export type UpdateAnswersMutationResponse = {
  __typename?: 'UpdateAnswersMutationResponse';
  answers: Array<Answer>;
  info: UpdateInfo;
};

export type UpdateCheckboxQuestionsMutationResponse = {
  __typename?: 'UpdateCheckboxQuestionsMutationResponse';
  checkboxQuestions: Array<CheckboxQuestion>;
  info: UpdateInfo;
};

export type UpdateConditionGroupsMutationResponse = {
  __typename?: 'UpdateConditionGroupsMutationResponse';
  conditionGroups: Array<ConditionGroup>;
  info: UpdateInfo;
};

export type UpdateConditionsMutationResponse = {
  __typename?: 'UpdateConditionsMutationResponse';
  conditions: Array<Condition>;
  info: UpdateInfo;
};

export type UpdateConfigurationsMutationResponse = {
  __typename?: 'UpdateConfigurationsMutationResponse';
  configurations: Array<Configuration>;
  info: UpdateInfo;
};

export type UpdateCooldownsMutationResponse = {
  __typename?: 'UpdateCooldownsMutationResponse';
  cooldowns: Array<Cooldown>;
  info: UpdateInfo;
};

export type UpdateDateQuestionsMutationResponse = {
  __typename?: 'UpdateDateQuestionsMutationResponse';
  dateQuestions: Array<DateQuestion>;
  info: UpdateInfo;
};

export type UpdateDeleteInfosMutationResponse = {
  __typename?: 'UpdateDeleteInfosMutationResponse';
  deleteInfos: Array<DeleteInfo>;
  info: UpdateInfo;
};

export type UpdateDevicesMutationResponse = {
  __typename?: 'UpdateDevicesMutationResponse';
  devices: Array<Device>;
  info: UpdateInfo;
};

export type UpdateDoctorsMutationResponse = {
  __typename?: 'UpdateDoctorsMutationResponse';
  doctors: Array<Doctor>;
  info: UpdateInfo;
};

export type UpdateDocumentsMutationResponse = {
  __typename?: 'UpdateDocumentsMutationResponse';
  documents: Array<Document>;
  info: UpdateInfo;
};

/** Information about the number of nodes and relationships created and deleted during an update mutation */
export type UpdateInfo = {
  __typename?: 'UpdateInfo';
  nodesCreated: Scalars['Int']['output'];
  nodesDeleted: Scalars['Int']['output'];
  relationshipsCreated: Scalars['Int']['output'];
  relationshipsDeleted: Scalars['Int']['output'];
};

export type UpdateInstitutionsMutationResponse = {
  __typename?: 'UpdateInstitutionsMutationResponse';
  info: UpdateInfo;
  institutions: Array<Institution>;
};

export type UpdateInterviewsMutationResponse = {
  __typename?: 'UpdateInterviewsMutationResponse';
  info: UpdateInfo;
  interviews: Array<Interview>;
};

export type UpdateInvoicesMutationResponse = {
  __typename?: 'UpdateInvoicesMutationResponse';
  info: UpdateInfo;
  invoices: Array<Invoice>;
};

export type UpdateManagersMutationResponse = {
  __typename?: 'UpdateManagersMutationResponse';
  info: UpdateInfo;
  managers: Array<Manager>;
};

export type UpdatePatientsMutationResponse = {
  __typename?: 'UpdatePatientsMutationResponse';
  info: UpdateInfo;
  patients: Array<Patient>;
};

export type UpdatePdfDocumentsMutationResponse = {
  __typename?: 'UpdatePdfDocumentsMutationResponse';
  info: UpdateInfo;
  pdfDocuments: Array<PdfDocument>;
};

export type UpdatePostalAddressesMutationResponse = {
  __typename?: 'UpdatePostalAddressesMutationResponse';
  info: UpdateInfo;
  postalAddresses: Array<PostalAddress>;
};

export type UpdateQuestionItemsMutationResponse = {
  __typename?: 'UpdateQuestionItemsMutationResponse';
  info: UpdateInfo;
  questionItems: Array<QuestionItem>;
};

export type UpdateQuestionnaireAisMutationResponse = {
  __typename?: 'UpdateQuestionnaireAisMutationResponse';
  info: UpdateInfo;
  questionnaireAis: Array<QuestionnaireAi>;
};

export type UpdateQuestionnaireAlertsMutationResponse = {
  __typename?: 'UpdateQuestionnaireAlertsMutationResponse';
  info: UpdateInfo;
  questionnaireAlerts: Array<QuestionnaireAlerts>;
};

export type UpdateQuestionnaireAppointmentDatesMutationResponse = {
  __typename?: 'UpdateQuestionnaireAppointmentDatesMutationResponse';
  info: UpdateInfo;
  questionnaireAppointmentDates: Array<QuestionnaireAppointmentDate>;
};

export type UpdateQuestionnaireConditionsMutationResponse = {
  __typename?: 'UpdateQuestionnaireConditionsMutationResponse';
  info: UpdateInfo;
  questionnaireConditions: Array<QuestionnaireCondition>;
};

export type UpdateQuestionnaireDocumentFillersMutationResponse = {
  __typename?: 'UpdateQuestionnaireDocumentFillersMutationResponse';
  info: UpdateInfo;
  questionnaireDocumentFillers: Array<QuestionnaireDocumentFiller>;
};

export type UpdateQuestionnaireDocumentsMutationResponse = {
  __typename?: 'UpdateQuestionnaireDocumentsMutationResponse';
  info: UpdateInfo;
  questionnaireDocuments: Array<QuestionnaireDocument>;
};

export type UpdateQuestionnaireIdentitiesMutationResponse = {
  __typename?: 'UpdateQuestionnaireIdentitiesMutationResponse';
  info: UpdateInfo;
  questionnaireIdentities: Array<QuestionnaireIdentity>;
};

export type UpdateQuestionnaireInfoStepsMutationResponse = {
  __typename?: 'UpdateQuestionnaireInfoStepsMutationResponse';
  info: UpdateInfo;
  questionnaireInfoSteps: Array<QuestionnaireInfoStep>;
};

export type UpdateQuestionnaireInterviewsMutationResponse = {
  __typename?: 'UpdateQuestionnaireInterviewsMutationResponse';
  info: UpdateInfo;
  questionnaireInterviews: Array<QuestionnaireInterview>;
};

export type UpdateQuestionnaireMenuEntriesMutationResponse = {
  __typename?: 'UpdateQuestionnaireMenuEntriesMutationResponse';
  info: UpdateInfo;
  questionnaireMenuEntries: Array<QuestionnaireMenuEntry>;
};

export type UpdateQuestionnaireMenuItemsMutationResponse = {
  __typename?: 'UpdateQuestionnaireMenuItemsMutationResponse';
  info: UpdateInfo;
  questionnaireMenuItems: Array<QuestionnaireMenuItem>;
};

export type UpdateQuestionnaireMenusMutationResponse = {
  __typename?: 'UpdateQuestionnaireMenusMutationResponse';
  info: UpdateInfo;
  questionnaireMenus: Array<QuestionnaireMenu>;
};

export type UpdateQuestionnaireRoutersMutationResponse = {
  __typename?: 'UpdateQuestionnaireRoutersMutationResponse';
  info: UpdateInfo;
  questionnaireRouters: Array<QuestionnaireRouter>;
};

export type UpdateQuestionnaireSelectMenusMutationResponse = {
  __typename?: 'UpdateQuestionnaireSelectMenusMutationResponse';
  info: UpdateInfo;
  questionnaireSelectMenus: Array<QuestionnaireSelectMenu>;
};

export type UpdateQuestionnaireSetPropertiesMutationResponse = {
  __typename?: 'UpdateQuestionnaireSetPropertiesMutationResponse';
  info: UpdateInfo;
  questionnaireSetProperties: Array<QuestionnaireSetProperty>;
};

export type UpdateQuestionnaireSurveysMutationResponse = {
  __typename?: 'UpdateQuestionnaireSurveysMutationResponse';
  info: UpdateInfo;
  questionnaireSurveys: Array<QuestionnaireSurvey>;
};

export type UpdateQuestionnaireThirdPartiesMutationResponse = {
  __typename?: 'UpdateQuestionnaireThirdPartiesMutationResponse';
  info: UpdateInfo;
  questionnaireThirdParties: Array<QuestionnaireThirdParty>;
};

export type UpdateQuestionnaireWelcomeStepsMutationResponse = {
  __typename?: 'UpdateQuestionnaireWelcomeStepsMutationResponse';
  info: UpdateInfo;
  questionnaireWelcomeSteps: Array<QuestionnaireWelcomeStep>;
};

export type UpdateQuestionnairesMutationResponse = {
  __typename?: 'UpdateQuestionnairesMutationResponse';
  info: UpdateInfo;
  questionnaires: Array<Questionnaire>;
};

export type UpdateQuotingsMutationResponse = {
  __typename?: 'UpdateQuotingsMutationResponse';
  info: UpdateInfo;
  quotings: Array<Quoting>;
};

export type UpdateRadioQuestionsMutationResponse = {
  __typename?: 'UpdateRadioQuestionsMutationResponse';
  info: UpdateInfo;
  radioQuestions: Array<RadioQuestion>;
};

export type UpdateRangeQuestionsMutationResponse = {
  __typename?: 'UpdateRangeQuestionsMutationResponse';
  info: UpdateInfo;
  rangeQuestions: Array<RangeQuestion>;
};

export type UpdateSearchQuestionResultsMutationResponse = {
  __typename?: 'UpdateSearchQuestionResultsMutationResponse';
  info: UpdateInfo;
  searchQuestionResults: Array<SearchQuestionResult>;
};

export type UpdateSelectQuestionsMutationResponse = {
  __typename?: 'UpdateSelectQuestionsMutationResponse';
  info: UpdateInfo;
  selectQuestions: Array<SelectQuestion>;
};

export type UpdateSerializationNodesMutationResponse = {
  __typename?: 'UpdateSerializationNodesMutationResponse';
  info: UpdateInfo;
  serializationNodes: Array<SerializationNode>;
};

export type UpdateSerializationSocketsMutationResponse = {
  __typename?: 'UpdateSerializationSocketsMutationResponse';
  info: UpdateInfo;
  serializationSockets: Array<SerializationSocket>;
};

export type UpdateSpecialitiesMutationResponse = {
  __typename?: 'UpdateSpecialitiesMutationResponse';
  info: UpdateInfo;
  specialities: Array<Speciality>;
};

export type UpdateTextQuestionsMutationResponse = {
  __typename?: 'UpdateTextQuestionsMutationResponse';
  info: UpdateInfo;
  textQuestions: Array<TextQuestion>;
};

export type UpdateUnserializationResponsesMutationResponse = {
  __typename?: 'UpdateUnserializationResponsesMutationResponse';
  info: UpdateInfo;
  unserializationResponses: Array<UnserializationResponse>;
};

export type UpdateVersionnedGraphsMutationResponse = {
  __typename?: 'UpdateVersionnedGraphsMutationResponse';
  info: UpdateInfo;
  versionnedGraphs: Array<VersionnedGraph>;
};

export type UpdateWorkflowLinksMutationResponse = {
  __typename?: 'UpdateWorkflowLinksMutationResponse';
  info: UpdateInfo;
  workflowLinks: Array<WorkflowLink>;
};

export type UpdateWorkflowsMutationResponse = {
  __typename?: 'UpdateWorkflowsMutationResponse';
  info: UpdateInfo;
  workflows: Array<Workflow>;
};

export type User = {
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
};

export type UserAggregateSelection = {
  __typename?: 'UserAggregateSelection';
  count: Scalars['Int']['output'];
  email: StringAggregateSelection;
  id: IdAggregateSelection;
};

export type UserEdge = {
  __typename?: 'UserEdge';
  cursor: Scalars['String']['output'];
  node: User;
};

export enum UserImplementation {
  Doctor = 'Doctor',
  Manager = 'Manager'
}

export type UserOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more UserSort objects to sort Users by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<InputMaybe<UserSort>>>;
};

/** Fields to sort Users by. The order in which sorts are applied is not guaranteed when specifying many fields in one UserSort object. */
export type UserSort = {
  email?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
};

export type UserWhere = {
  AND?: InputMaybe<Array<UserWhere>>;
  NOT?: InputMaybe<UserWhere>;
  OR?: InputMaybe<Array<UserWhere>>;
  email?: InputMaybe<Scalars['String']['input']>;
  email_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  email_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  email_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  email_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  typename_IN?: InputMaybe<Array<UserImplementation>>;
};

export type UsersConnection = {
  __typename?: 'UsersConnection';
  edges: Array<UserEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type VersionnedGraph = {
  __typename?: 'VersionnedGraph';
  alerts?: Maybe<AlertGroup>;
  alertsAggregate?: Maybe<VersionnedGraphAlertGroupAlertsAggregationSelection>;
  alertsConnection: VersionnedGraphAlertsConnection;
  cooldown?: Maybe<Cooldown>;
  cooldownAggregate?: Maybe<VersionnedGraphCooldownCooldownAggregationSelection>;
  cooldownConnection: VersionnedGraphCooldownConnection;
  createdAt: Scalars['DateTime']['output'];
  firstStep: QuestionnaireStep;
  firstStepAggregate?: Maybe<VersionnedGraphQuestionnaireStepFirstStepAggregationSelection>;
  firstStepConnection: VersionnedGraphFirstStepConnection;
  firstStepId: Scalars['ID']['output'];
  hasDocument: Scalars['Boolean']['output'];
  isFirstStepOnCooldown: Scalars['Boolean']['output'];
  isTemplate?: Maybe<Scalars['Boolean']['output']>;
  maxScore?: Maybe<Scalars['Int']['output']>;
  modifiedBy?: Maybe<Editor>;
  modifiedByConnection: VersionnedGraphModifiedByConnection;
  questionnaire: BaseQuestionnaire;
  questionnaireAggregate?: Maybe<VersionnedGraphBaseQuestionnaireQuestionnaireAggregationSelection>;
  questionnaireConnection: VersionnedGraphQuestionnaireConnection;
  quoting?: Maybe<Quoting>;
  quotingAggregate?: Maybe<VersionnedGraphQuotingQuotingAggregationSelection>;
  quotingConnection: VersionnedGraphQuotingConnection;
  steps: Array<QuestionnaireStep>;
  stepsAggregate?: Maybe<VersionnedGraphQuestionnaireStepStepsAggregationSelection>;
  stepsConnection: VersionnedGraphStepsConnection;
};


export type VersionnedGraphAlertsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<AlertGroupOptions>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type VersionnedGraphAlertsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<AlertGroupWhere>;
};


export type VersionnedGraphAlertsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<VersionnedGraphAlertsConnectionWhere>;
};


export type VersionnedGraphCooldownArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<CooldownOptions>;
  where?: InputMaybe<CooldownWhere>;
};


export type VersionnedGraphCooldownAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<CooldownWhere>;
};


export type VersionnedGraphCooldownConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<VersionnedGraphCooldownConnectionSort>>;
  where?: InputMaybe<VersionnedGraphCooldownConnectionWhere>;
};


export type VersionnedGraphFirstStepArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type VersionnedGraphFirstStepAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type VersionnedGraphFirstStepConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<VersionnedGraphFirstStepConnectionSort>>;
  where?: InputMaybe<VersionnedGraphFirstStepConnectionWhere>;
};


export type VersionnedGraphModifiedByArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QueryOptions>;
  where?: InputMaybe<EditorWhere>;
};


export type VersionnedGraphModifiedByConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<VersionnedGraphModifiedByConnectionWhere>;
};


export type VersionnedGraphQuestionnaireArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<BaseQuestionnaireOptions>;
  where?: InputMaybe<BaseQuestionnaireWhere>;
};


export type VersionnedGraphQuestionnaireAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<BaseQuestionnaireWhere>;
};


export type VersionnedGraphQuestionnaireConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<VersionnedGraphQuestionnaireConnectionSort>>;
  where?: InputMaybe<VersionnedGraphQuestionnaireConnectionWhere>;
};


export type VersionnedGraphQuotingArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuotingOptions>;
  where?: InputMaybe<QuotingWhere>;
};


export type VersionnedGraphQuotingAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuotingWhere>;
};


export type VersionnedGraphQuotingConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<VersionnedGraphQuotingConnectionSort>>;
  where?: InputMaybe<VersionnedGraphQuotingConnectionWhere>;
};


export type VersionnedGraphStepsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QuestionnaireStepOptions>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type VersionnedGraphStepsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<QuestionnaireStepWhere>;
};


export type VersionnedGraphStepsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<VersionnedGraphStepsConnectionSort>>;
  where?: InputMaybe<VersionnedGraphStepsConnectionWhere>;
};

export type VersionnedGraphAggregateSelection = {
  __typename?: 'VersionnedGraphAggregateSelection';
  count: Scalars['Int']['output'];
  createdAt: DateTimeAggregateSelection;
};

export type VersionnedGraphAlertGroupAlertsAggregationSelection = {
  __typename?: 'VersionnedGraphAlertGroupAlertsAggregationSelection';
  count: Scalars['Int']['output'];
};

export type VersionnedGraphAlertsAggregateInput = {
  AND?: InputMaybe<Array<VersionnedGraphAlertsAggregateInput>>;
  NOT?: InputMaybe<VersionnedGraphAlertsAggregateInput>;
  OR?: InputMaybe<Array<VersionnedGraphAlertsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type VersionnedGraphAlertsConnectFieldInput = {
  connect?: InputMaybe<AlertGroupConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<AlertGroupConnectWhere>;
};

export type VersionnedGraphAlertsConnection = {
  __typename?: 'VersionnedGraphAlertsConnection';
  edges: Array<VersionnedGraphAlertsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type VersionnedGraphAlertsConnectionWhere = {
  AND?: InputMaybe<Array<VersionnedGraphAlertsConnectionWhere>>;
  NOT?: InputMaybe<VersionnedGraphAlertsConnectionWhere>;
  OR?: InputMaybe<Array<VersionnedGraphAlertsConnectionWhere>>;
  node?: InputMaybe<AlertGroupWhere>;
};

export type VersionnedGraphAlertsCreateFieldInput = {
  node: AlertGroupCreateInput;
};

export type VersionnedGraphAlertsDeleteFieldInput = {
  delete?: InputMaybe<AlertGroupDeleteInput>;
  where?: InputMaybe<VersionnedGraphAlertsConnectionWhere>;
};

export type VersionnedGraphAlertsDisconnectFieldInput = {
  disconnect?: InputMaybe<AlertGroupDisconnectInput>;
  where?: InputMaybe<VersionnedGraphAlertsConnectionWhere>;
};

export type VersionnedGraphAlertsFieldInput = {
  connect?: InputMaybe<VersionnedGraphAlertsConnectFieldInput>;
  create?: InputMaybe<VersionnedGraphAlertsCreateFieldInput>;
};

export type VersionnedGraphAlertsRelationship = {
  __typename?: 'VersionnedGraphAlertsRelationship';
  cursor: Scalars['String']['output'];
  node: AlertGroup;
};

export type VersionnedGraphAlertsUpdateConnectionInput = {
  node?: InputMaybe<AlertGroupUpdateInput>;
};

export type VersionnedGraphAlertsUpdateFieldInput = {
  connect?: InputMaybe<VersionnedGraphAlertsConnectFieldInput>;
  create?: InputMaybe<VersionnedGraphAlertsCreateFieldInput>;
  delete?: InputMaybe<VersionnedGraphAlertsDeleteFieldInput>;
  disconnect?: InputMaybe<VersionnedGraphAlertsDisconnectFieldInput>;
  update?: InputMaybe<VersionnedGraphAlertsUpdateConnectionInput>;
  where?: InputMaybe<VersionnedGraphAlertsConnectionWhere>;
};

export type VersionnedGraphBaseQuestionnaireQuestionnaireAggregationSelection = {
  __typename?: 'VersionnedGraphBaseQuestionnaireQuestionnaireAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<VersionnedGraphBaseQuestionnaireQuestionnaireEdgeAggregateSelection>;
  node?: Maybe<VersionnedGraphBaseQuestionnaireQuestionnaireNodeAggregateSelection>;
};

export type VersionnedGraphBaseQuestionnaireQuestionnaireEdgeAggregateSelection = {
  __typename?: 'VersionnedGraphBaseQuestionnaireQuestionnaireEdgeAggregateSelection';
  version: IntAggregateSelection;
};

export type VersionnedGraphBaseQuestionnaireQuestionnaireNodeAggregateSelection = {
  __typename?: 'VersionnedGraphBaseQuestionnaireQuestionnaireNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type VersionnedGraphConnectInput = {
  alerts?: InputMaybe<VersionnedGraphAlertsConnectFieldInput>;
  cooldown?: InputMaybe<VersionnedGraphCooldownConnectFieldInput>;
  firstStep?: InputMaybe<VersionnedGraphFirstStepConnectFieldInput>;
  modifiedBy?: InputMaybe<VersionnedGraphModifiedByConnectInput>;
  questionnaire?: InputMaybe<VersionnedGraphQuestionnaireConnectFieldInput>;
  quoting?: InputMaybe<VersionnedGraphQuotingConnectFieldInput>;
  steps?: InputMaybe<Array<VersionnedGraphStepsConnectFieldInput>>;
};

export type VersionnedGraphConnectOrCreateInput = {
  modifiedBy?: InputMaybe<VersionnedGraphModifiedByConnectOrCreateInput>;
};

export type VersionnedGraphConnectWhere = {
  node: VersionnedGraphWhere;
};

export type VersionnedGraphCooldownAggregateInput = {
  AND?: InputMaybe<Array<VersionnedGraphCooldownAggregateInput>>;
  NOT?: InputMaybe<VersionnedGraphCooldownAggregateInput>;
  OR?: InputMaybe<Array<VersionnedGraphCooldownAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<VersionnedGraphCooldownNodeAggregationWhereInput>;
};

export type VersionnedGraphCooldownConnectFieldInput = {
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<CooldownConnectWhere>;
};

export type VersionnedGraphCooldownConnection = {
  __typename?: 'VersionnedGraphCooldownConnection';
  edges: Array<VersionnedGraphCooldownRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type VersionnedGraphCooldownConnectionSort = {
  node?: InputMaybe<CooldownSort>;
};

export type VersionnedGraphCooldownConnectionWhere = {
  AND?: InputMaybe<Array<VersionnedGraphCooldownConnectionWhere>>;
  NOT?: InputMaybe<VersionnedGraphCooldownConnectionWhere>;
  OR?: InputMaybe<Array<VersionnedGraphCooldownConnectionWhere>>;
  node?: InputMaybe<CooldownWhere>;
};

export type VersionnedGraphCooldownCooldownAggregationSelection = {
  __typename?: 'VersionnedGraphCooldownCooldownAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<VersionnedGraphCooldownCooldownNodeAggregateSelection>;
};

export type VersionnedGraphCooldownCooldownNodeAggregateSelection = {
  __typename?: 'VersionnedGraphCooldownCooldownNodeAggregateSelection';
  value: IntAggregateSelection;
};

export type VersionnedGraphCooldownCreateFieldInput = {
  node: CooldownCreateInput;
};

export type VersionnedGraphCooldownDeleteFieldInput = {
  where?: InputMaybe<VersionnedGraphCooldownConnectionWhere>;
};

export type VersionnedGraphCooldownDisconnectFieldInput = {
  where?: InputMaybe<VersionnedGraphCooldownConnectionWhere>;
};

export type VersionnedGraphCooldownFieldInput = {
  connect?: InputMaybe<VersionnedGraphCooldownConnectFieldInput>;
  create?: InputMaybe<VersionnedGraphCooldownCreateFieldInput>;
};

export type VersionnedGraphCooldownNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<VersionnedGraphCooldownNodeAggregationWhereInput>>;
  NOT?: InputMaybe<VersionnedGraphCooldownNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<VersionnedGraphCooldownNodeAggregationWhereInput>>;
  value_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  value_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  value_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  value_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  value_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type VersionnedGraphCooldownRelationship = {
  __typename?: 'VersionnedGraphCooldownRelationship';
  cursor: Scalars['String']['output'];
  node: Cooldown;
};

export type VersionnedGraphCooldownUpdateConnectionInput = {
  node?: InputMaybe<CooldownUpdateInput>;
};

export type VersionnedGraphCooldownUpdateFieldInput = {
  connect?: InputMaybe<VersionnedGraphCooldownConnectFieldInput>;
  create?: InputMaybe<VersionnedGraphCooldownCreateFieldInput>;
  delete?: InputMaybe<VersionnedGraphCooldownDeleteFieldInput>;
  disconnect?: InputMaybe<VersionnedGraphCooldownDisconnectFieldInput>;
  update?: InputMaybe<VersionnedGraphCooldownUpdateConnectionInput>;
  where?: InputMaybe<VersionnedGraphCooldownConnectionWhere>;
};

export type VersionnedGraphCreateInput = {
  alerts?: InputMaybe<VersionnedGraphAlertsFieldInput>;
  cooldown?: InputMaybe<VersionnedGraphCooldownFieldInput>;
  firstStep?: InputMaybe<VersionnedGraphFirstStepFieldInput>;
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  modifiedBy?: InputMaybe<VersionnedGraphModifiedByCreateInput>;
  questionnaire?: InputMaybe<VersionnedGraphQuestionnaireFieldInput>;
  quoting?: InputMaybe<VersionnedGraphQuotingFieldInput>;
  steps?: InputMaybe<VersionnedGraphStepsFieldInput>;
};

export type VersionnedGraphDeleteInput = {
  alerts?: InputMaybe<VersionnedGraphAlertsDeleteFieldInput>;
  cooldown?: InputMaybe<VersionnedGraphCooldownDeleteFieldInput>;
  firstStep?: InputMaybe<VersionnedGraphFirstStepDeleteFieldInput>;
  modifiedBy?: InputMaybe<VersionnedGraphModifiedByDeleteInput>;
  questionnaire?: InputMaybe<VersionnedGraphQuestionnaireDeleteFieldInput>;
  quoting?: InputMaybe<VersionnedGraphQuotingDeleteFieldInput>;
  steps?: InputMaybe<Array<VersionnedGraphStepsDeleteFieldInput>>;
};

export type VersionnedGraphDisconnectInput = {
  alerts?: InputMaybe<VersionnedGraphAlertsDisconnectFieldInput>;
  cooldown?: InputMaybe<VersionnedGraphCooldownDisconnectFieldInput>;
  firstStep?: InputMaybe<VersionnedGraphFirstStepDisconnectFieldInput>;
  modifiedBy?: InputMaybe<VersionnedGraphModifiedByDisconnectInput>;
  questionnaire?: InputMaybe<VersionnedGraphQuestionnaireDisconnectFieldInput>;
  quoting?: InputMaybe<VersionnedGraphQuotingDisconnectFieldInput>;
  steps?: InputMaybe<Array<VersionnedGraphStepsDisconnectFieldInput>>;
};

export type VersionnedGraphEdge = {
  __typename?: 'VersionnedGraphEdge';
  cursor: Scalars['String']['output'];
  node: VersionnedGraph;
};

export type VersionnedGraphFirstStepAggregateInput = {
  AND?: InputMaybe<Array<VersionnedGraphFirstStepAggregateInput>>;
  NOT?: InputMaybe<VersionnedGraphFirstStepAggregateInput>;
  OR?: InputMaybe<Array<VersionnedGraphFirstStepAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<VersionnedGraphFirstStepNodeAggregationWhereInput>;
};

export type VersionnedGraphFirstStepConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type VersionnedGraphFirstStepConnection = {
  __typename?: 'VersionnedGraphFirstStepConnection';
  edges: Array<VersionnedGraphFirstStepRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type VersionnedGraphFirstStepConnectionSort = {
  node?: InputMaybe<QuestionnaireStepSort>;
};

export type VersionnedGraphFirstStepConnectionWhere = {
  AND?: InputMaybe<Array<VersionnedGraphFirstStepConnectionWhere>>;
  NOT?: InputMaybe<VersionnedGraphFirstStepConnectionWhere>;
  OR?: InputMaybe<Array<VersionnedGraphFirstStepConnectionWhere>>;
  node?: InputMaybe<QuestionnaireStepWhere>;
};

export type VersionnedGraphFirstStepCreateFieldInput = {
  node: QuestionnaireStepCreateInput;
};

export type VersionnedGraphFirstStepDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<VersionnedGraphFirstStepConnectionWhere>;
};

export type VersionnedGraphFirstStepDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<VersionnedGraphFirstStepConnectionWhere>;
};

export type VersionnedGraphFirstStepFieldInput = {
  connect?: InputMaybe<VersionnedGraphFirstStepConnectFieldInput>;
  create?: InputMaybe<VersionnedGraphFirstStepCreateFieldInput>;
};

export type VersionnedGraphFirstStepNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<VersionnedGraphFirstStepNodeAggregationWhereInput>>;
  NOT?: InputMaybe<VersionnedGraphFirstStepNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<VersionnedGraphFirstStepNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type VersionnedGraphFirstStepRelationship = {
  __typename?: 'VersionnedGraphFirstStepRelationship';
  cursor: Scalars['String']['output'];
  node: QuestionnaireStep;
};

export type VersionnedGraphFirstStepUpdateConnectionInput = {
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type VersionnedGraphFirstStepUpdateFieldInput = {
  connect?: InputMaybe<VersionnedGraphFirstStepConnectFieldInput>;
  create?: InputMaybe<VersionnedGraphFirstStepCreateFieldInput>;
  delete?: InputMaybe<VersionnedGraphFirstStepDeleteFieldInput>;
  disconnect?: InputMaybe<VersionnedGraphFirstStepDisconnectFieldInput>;
  update?: InputMaybe<VersionnedGraphFirstStepUpdateConnectionInput>;
  where?: InputMaybe<VersionnedGraphFirstStepConnectionWhere>;
};

export type VersionnedGraphModifiedByConnectInput = {
  Doctor?: InputMaybe<VersionnedGraphModifiedByDoctorConnectFieldInput>;
  Institution?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectFieldInput>;
  Manager?: InputMaybe<VersionnedGraphModifiedByManagerConnectFieldInput>;
};

export type VersionnedGraphModifiedByConnectOrCreateInput = {
  Doctor?: InputMaybe<VersionnedGraphModifiedByDoctorConnectOrCreateFieldInput>;
  Institution?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectOrCreateFieldInput>;
  Manager?: InputMaybe<VersionnedGraphModifiedByManagerConnectOrCreateFieldInput>;
};

export type VersionnedGraphModifiedByConnection = {
  __typename?: 'VersionnedGraphModifiedByConnection';
  edges: Array<VersionnedGraphModifiedByRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type VersionnedGraphModifiedByConnectionWhere = {
  Doctor?: InputMaybe<VersionnedGraphModifiedByDoctorConnectionWhere>;
  Institution?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectionWhere>;
  Manager?: InputMaybe<VersionnedGraphModifiedByManagerConnectionWhere>;
};

export type VersionnedGraphModifiedByCreateFieldInput = {
  Doctor?: InputMaybe<VersionnedGraphModifiedByDoctorCreateFieldInput>;
  Institution?: InputMaybe<VersionnedGraphModifiedByInstitutionCreateFieldInput>;
  Manager?: InputMaybe<VersionnedGraphModifiedByManagerCreateFieldInput>;
};

export type VersionnedGraphModifiedByCreateInput = {
  Doctor?: InputMaybe<VersionnedGraphModifiedByDoctorFieldInput>;
  Institution?: InputMaybe<VersionnedGraphModifiedByInstitutionFieldInput>;
  Manager?: InputMaybe<VersionnedGraphModifiedByManagerFieldInput>;
};

export type VersionnedGraphModifiedByDeleteInput = {
  Doctor?: InputMaybe<VersionnedGraphModifiedByDoctorDeleteFieldInput>;
  Institution?: InputMaybe<VersionnedGraphModifiedByInstitutionDeleteFieldInput>;
  Manager?: InputMaybe<VersionnedGraphModifiedByManagerDeleteFieldInput>;
};

export type VersionnedGraphModifiedByDisconnectInput = {
  Doctor?: InputMaybe<VersionnedGraphModifiedByDoctorDisconnectFieldInput>;
  Institution?: InputMaybe<VersionnedGraphModifiedByInstitutionDisconnectFieldInput>;
  Manager?: InputMaybe<VersionnedGraphModifiedByManagerDisconnectFieldInput>;
};

export type VersionnedGraphModifiedByDoctorConnectFieldInput = {
  connect?: InputMaybe<DoctorConnectInput>;
  where?: InputMaybe<DoctorConnectWhere>;
};

export type VersionnedGraphModifiedByDoctorConnectOrCreateFieldInput = {
  onCreate: VersionnedGraphModifiedByDoctorConnectOrCreateFieldInputOnCreate;
  where: DoctorConnectOrCreateWhere;
};

export type VersionnedGraphModifiedByDoctorConnectOrCreateFieldInputOnCreate = {
  node: DoctorOnCreateInput;
};

export type VersionnedGraphModifiedByDoctorConnectionWhere = {
  AND?: InputMaybe<Array<VersionnedGraphModifiedByDoctorConnectionWhere>>;
  NOT?: InputMaybe<VersionnedGraphModifiedByDoctorConnectionWhere>;
  OR?: InputMaybe<Array<VersionnedGraphModifiedByDoctorConnectionWhere>>;
  node?: InputMaybe<DoctorWhere>;
};

export type VersionnedGraphModifiedByDoctorCreateFieldInput = {
  node: DoctorCreateInput;
};

export type VersionnedGraphModifiedByDoctorDeleteFieldInput = {
  delete?: InputMaybe<DoctorDeleteInput>;
  where?: InputMaybe<VersionnedGraphModifiedByDoctorConnectionWhere>;
};

export type VersionnedGraphModifiedByDoctorDisconnectFieldInput = {
  disconnect?: InputMaybe<DoctorDisconnectInput>;
  where?: InputMaybe<VersionnedGraphModifiedByDoctorConnectionWhere>;
};

export type VersionnedGraphModifiedByDoctorFieldInput = {
  connect?: InputMaybe<VersionnedGraphModifiedByDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<VersionnedGraphModifiedByDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<VersionnedGraphModifiedByDoctorCreateFieldInput>;
};

export type VersionnedGraphModifiedByDoctorUpdateConnectionInput = {
  node?: InputMaybe<DoctorUpdateInput>;
};

export type VersionnedGraphModifiedByDoctorUpdateFieldInput = {
  connect?: InputMaybe<VersionnedGraphModifiedByDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<VersionnedGraphModifiedByDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<VersionnedGraphModifiedByDoctorCreateFieldInput>;
  delete?: InputMaybe<VersionnedGraphModifiedByDoctorDeleteFieldInput>;
  disconnect?: InputMaybe<VersionnedGraphModifiedByDoctorDisconnectFieldInput>;
  update?: InputMaybe<VersionnedGraphModifiedByDoctorUpdateConnectionInput>;
  where?: InputMaybe<VersionnedGraphModifiedByDoctorConnectionWhere>;
};

export type VersionnedGraphModifiedByInstitutionConnectFieldInput = {
  connect?: InputMaybe<InstitutionConnectInput>;
  where?: InputMaybe<InstitutionConnectWhere>;
};

export type VersionnedGraphModifiedByInstitutionConnectOrCreateFieldInput = {
  onCreate: VersionnedGraphModifiedByInstitutionConnectOrCreateFieldInputOnCreate;
  where: InstitutionConnectOrCreateWhere;
};

export type VersionnedGraphModifiedByInstitutionConnectOrCreateFieldInputOnCreate = {
  node: InstitutionOnCreateInput;
};

export type VersionnedGraphModifiedByInstitutionConnectionWhere = {
  AND?: InputMaybe<Array<VersionnedGraphModifiedByInstitutionConnectionWhere>>;
  NOT?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectionWhere>;
  OR?: InputMaybe<Array<VersionnedGraphModifiedByInstitutionConnectionWhere>>;
  node?: InputMaybe<InstitutionWhere>;
};

export type VersionnedGraphModifiedByInstitutionCreateFieldInput = {
  node: InstitutionCreateInput;
};

export type VersionnedGraphModifiedByInstitutionDeleteFieldInput = {
  delete?: InputMaybe<InstitutionDeleteInput>;
  where?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectionWhere>;
};

export type VersionnedGraphModifiedByInstitutionDisconnectFieldInput = {
  disconnect?: InputMaybe<InstitutionDisconnectInput>;
  where?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectionWhere>;
};

export type VersionnedGraphModifiedByInstitutionFieldInput = {
  connect?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<VersionnedGraphModifiedByInstitutionCreateFieldInput>;
};

export type VersionnedGraphModifiedByInstitutionUpdateConnectionInput = {
  node?: InputMaybe<InstitutionUpdateInput>;
};

export type VersionnedGraphModifiedByInstitutionUpdateFieldInput = {
  connect?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<VersionnedGraphModifiedByInstitutionCreateFieldInput>;
  delete?: InputMaybe<VersionnedGraphModifiedByInstitutionDeleteFieldInput>;
  disconnect?: InputMaybe<VersionnedGraphModifiedByInstitutionDisconnectFieldInput>;
  update?: InputMaybe<VersionnedGraphModifiedByInstitutionUpdateConnectionInput>;
  where?: InputMaybe<VersionnedGraphModifiedByInstitutionConnectionWhere>;
};

export type VersionnedGraphModifiedByManagerConnectFieldInput = {
  where?: InputMaybe<ManagerConnectWhere>;
};

export type VersionnedGraphModifiedByManagerConnectOrCreateFieldInput = {
  onCreate: VersionnedGraphModifiedByManagerConnectOrCreateFieldInputOnCreate;
  where: ManagerConnectOrCreateWhere;
};

export type VersionnedGraphModifiedByManagerConnectOrCreateFieldInputOnCreate = {
  node: ManagerOnCreateInput;
};

export type VersionnedGraphModifiedByManagerConnectionWhere = {
  AND?: InputMaybe<Array<VersionnedGraphModifiedByManagerConnectionWhere>>;
  NOT?: InputMaybe<VersionnedGraphModifiedByManagerConnectionWhere>;
  OR?: InputMaybe<Array<VersionnedGraphModifiedByManagerConnectionWhere>>;
  node?: InputMaybe<ManagerWhere>;
};

export type VersionnedGraphModifiedByManagerCreateFieldInput = {
  node: ManagerCreateInput;
};

export type VersionnedGraphModifiedByManagerDeleteFieldInput = {
  where?: InputMaybe<VersionnedGraphModifiedByManagerConnectionWhere>;
};

export type VersionnedGraphModifiedByManagerDisconnectFieldInput = {
  where?: InputMaybe<VersionnedGraphModifiedByManagerConnectionWhere>;
};

export type VersionnedGraphModifiedByManagerFieldInput = {
  connect?: InputMaybe<VersionnedGraphModifiedByManagerConnectFieldInput>;
  connectOrCreate?: InputMaybe<VersionnedGraphModifiedByManagerConnectOrCreateFieldInput>;
  create?: InputMaybe<VersionnedGraphModifiedByManagerCreateFieldInput>;
};

export type VersionnedGraphModifiedByManagerUpdateConnectionInput = {
  node?: InputMaybe<ManagerUpdateInput>;
};

export type VersionnedGraphModifiedByManagerUpdateFieldInput = {
  connect?: InputMaybe<VersionnedGraphModifiedByManagerConnectFieldInput>;
  connectOrCreate?: InputMaybe<VersionnedGraphModifiedByManagerConnectOrCreateFieldInput>;
  create?: InputMaybe<VersionnedGraphModifiedByManagerCreateFieldInput>;
  delete?: InputMaybe<VersionnedGraphModifiedByManagerDeleteFieldInput>;
  disconnect?: InputMaybe<VersionnedGraphModifiedByManagerDisconnectFieldInput>;
  update?: InputMaybe<VersionnedGraphModifiedByManagerUpdateConnectionInput>;
  where?: InputMaybe<VersionnedGraphModifiedByManagerConnectionWhere>;
};

export type VersionnedGraphModifiedByRelationship = {
  __typename?: 'VersionnedGraphModifiedByRelationship';
  cursor: Scalars['String']['output'];
  node: Editor;
};

export type VersionnedGraphModifiedByUpdateInput = {
  Doctor?: InputMaybe<VersionnedGraphModifiedByDoctorUpdateFieldInput>;
  Institution?: InputMaybe<VersionnedGraphModifiedByInstitutionUpdateFieldInput>;
  Manager?: InputMaybe<VersionnedGraphModifiedByManagerUpdateFieldInput>;
};

export type VersionnedGraphOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more VersionnedGraphSort objects to sort VersionnedGraphs by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<VersionnedGraphSort>>;
};

export type VersionnedGraphQuestionnaireAggregateInput = {
  AND?: InputMaybe<Array<VersionnedGraphQuestionnaireAggregateInput>>;
  NOT?: InputMaybe<VersionnedGraphQuestionnaireAggregateInput>;
  OR?: InputMaybe<Array<VersionnedGraphQuestionnaireAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<VersionnedRelationAggregationWhereInput>;
  node?: InputMaybe<VersionnedGraphQuestionnaireNodeAggregationWhereInput>;
};

export type VersionnedGraphQuestionnaireConnectFieldInput = {
  connect?: InputMaybe<BaseQuestionnaireConnectInput>;
  edge: VersionnedRelationCreateInput;
  where?: InputMaybe<BaseQuestionnaireConnectWhere>;
};

export type VersionnedGraphQuestionnaireConnection = {
  __typename?: 'VersionnedGraphQuestionnaireConnection';
  edges: Array<VersionnedGraphQuestionnaireRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type VersionnedGraphQuestionnaireConnectionSort = {
  edge?: InputMaybe<VersionnedRelationSort>;
  node?: InputMaybe<BaseQuestionnaireSort>;
};

export type VersionnedGraphQuestionnaireConnectionWhere = {
  AND?: InputMaybe<Array<VersionnedGraphQuestionnaireConnectionWhere>>;
  NOT?: InputMaybe<VersionnedGraphQuestionnaireConnectionWhere>;
  OR?: InputMaybe<Array<VersionnedGraphQuestionnaireConnectionWhere>>;
  edge?: InputMaybe<VersionnedRelationWhere>;
  node?: InputMaybe<BaseQuestionnaireWhere>;
};

export type VersionnedGraphQuestionnaireCreateFieldInput = {
  edge: VersionnedRelationCreateInput;
  node: BaseQuestionnaireCreateInput;
};

export type VersionnedGraphQuestionnaireDeleteFieldInput = {
  delete?: InputMaybe<BaseQuestionnaireDeleteInput>;
  where?: InputMaybe<VersionnedGraphQuestionnaireConnectionWhere>;
};

export type VersionnedGraphQuestionnaireDisconnectFieldInput = {
  disconnect?: InputMaybe<BaseQuestionnaireDisconnectInput>;
  where?: InputMaybe<VersionnedGraphQuestionnaireConnectionWhere>;
};

export type VersionnedGraphQuestionnaireFieldInput = {
  connect?: InputMaybe<VersionnedGraphQuestionnaireConnectFieldInput>;
  create?: InputMaybe<VersionnedGraphQuestionnaireCreateFieldInput>;
};

export type VersionnedGraphQuestionnaireNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<VersionnedGraphQuestionnaireNodeAggregationWhereInput>>;
  NOT?: InputMaybe<VersionnedGraphQuestionnaireNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<VersionnedGraphQuestionnaireNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type VersionnedGraphQuestionnaireRelationship = {
  __typename?: 'VersionnedGraphQuestionnaireRelationship';
  cursor: Scalars['String']['output'];
  node: BaseQuestionnaire;
  properties: VersionnedRelation;
};

export type VersionnedGraphQuestionnaireStepFirstStepAggregationSelection = {
  __typename?: 'VersionnedGraphQuestionnaireStepFirstStepAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<VersionnedGraphQuestionnaireStepFirstStepNodeAggregateSelection>;
};

export type VersionnedGraphQuestionnaireStepFirstStepNodeAggregateSelection = {
  __typename?: 'VersionnedGraphQuestionnaireStepFirstStepNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type VersionnedGraphQuestionnaireStepStepsAggregationSelection = {
  __typename?: 'VersionnedGraphQuestionnaireStepStepsAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<VersionnedGraphQuestionnaireStepStepsNodeAggregateSelection>;
};

export type VersionnedGraphQuestionnaireStepStepsNodeAggregateSelection = {
  __typename?: 'VersionnedGraphQuestionnaireStepStepsNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type VersionnedGraphQuestionnaireUpdateConnectionInput = {
  edge?: InputMaybe<VersionnedRelationUpdateInput>;
  node?: InputMaybe<BaseQuestionnaireUpdateInput>;
};

export type VersionnedGraphQuestionnaireUpdateFieldInput = {
  connect?: InputMaybe<VersionnedGraphQuestionnaireConnectFieldInput>;
  create?: InputMaybe<VersionnedGraphQuestionnaireCreateFieldInput>;
  delete?: InputMaybe<VersionnedGraphQuestionnaireDeleteFieldInput>;
  disconnect?: InputMaybe<VersionnedGraphQuestionnaireDisconnectFieldInput>;
  update?: InputMaybe<VersionnedGraphQuestionnaireUpdateConnectionInput>;
  where?: InputMaybe<VersionnedGraphQuestionnaireConnectionWhere>;
};

export type VersionnedGraphQuotingAggregateInput = {
  AND?: InputMaybe<Array<VersionnedGraphQuotingAggregateInput>>;
  NOT?: InputMaybe<VersionnedGraphQuotingAggregateInput>;
  OR?: InputMaybe<Array<VersionnedGraphQuotingAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<VersionnedGraphQuotingNodeAggregationWhereInput>;
};

export type VersionnedGraphQuotingConnectFieldInput = {
  connect?: InputMaybe<QuotingConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<QuotingConnectWhere>;
};

export type VersionnedGraphQuotingConnection = {
  __typename?: 'VersionnedGraphQuotingConnection';
  edges: Array<VersionnedGraphQuotingRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type VersionnedGraphQuotingConnectionSort = {
  node?: InputMaybe<QuotingSort>;
};

export type VersionnedGraphQuotingConnectionWhere = {
  AND?: InputMaybe<Array<VersionnedGraphQuotingConnectionWhere>>;
  NOT?: InputMaybe<VersionnedGraphQuotingConnectionWhere>;
  OR?: InputMaybe<Array<VersionnedGraphQuotingConnectionWhere>>;
  node?: InputMaybe<QuotingWhere>;
};

export type VersionnedGraphQuotingCreateFieldInput = {
  node: QuotingCreateInput;
};

export type VersionnedGraphQuotingDeleteFieldInput = {
  delete?: InputMaybe<QuotingDeleteInput>;
  where?: InputMaybe<VersionnedGraphQuotingConnectionWhere>;
};

export type VersionnedGraphQuotingDisconnectFieldInput = {
  disconnect?: InputMaybe<QuotingDisconnectInput>;
  where?: InputMaybe<VersionnedGraphQuotingConnectionWhere>;
};

export type VersionnedGraphQuotingFieldInput = {
  connect?: InputMaybe<VersionnedGraphQuotingConnectFieldInput>;
  create?: InputMaybe<VersionnedGraphQuotingCreateFieldInput>;
};

export type VersionnedGraphQuotingNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<VersionnedGraphQuotingNodeAggregationWhereInput>>;
  NOT?: InputMaybe<VersionnedGraphQuotingNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<VersionnedGraphQuotingNodeAggregationWhereInput>>;
  amount_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  amount_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  amount_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  amount_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  amount_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  amount_MAX_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  amount_MAX_GT?: InputMaybe<Scalars['Float']['input']>;
  amount_MAX_GTE?: InputMaybe<Scalars['Float']['input']>;
  amount_MAX_LT?: InputMaybe<Scalars['Float']['input']>;
  amount_MAX_LTE?: InputMaybe<Scalars['Float']['input']>;
  amount_MIN_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  amount_MIN_GT?: InputMaybe<Scalars['Float']['input']>;
  amount_MIN_GTE?: InputMaybe<Scalars['Float']['input']>;
  amount_MIN_LT?: InputMaybe<Scalars['Float']['input']>;
  amount_MIN_LTE?: InputMaybe<Scalars['Float']['input']>;
  amount_SUM_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  amount_SUM_GT?: InputMaybe<Scalars['Float']['input']>;
  amount_SUM_GTE?: InputMaybe<Scalars['Float']['input']>;
  amount_SUM_LT?: InputMaybe<Scalars['Float']['input']>;
  amount_SUM_LTE?: InputMaybe<Scalars['Float']['input']>;
  code_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  code_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  code_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  code_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  code_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  code_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  code_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  code_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  code_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  code_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  code_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  code_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  code_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  code_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  code_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type VersionnedGraphQuotingQuotingAggregationSelection = {
  __typename?: 'VersionnedGraphQuotingQuotingAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<VersionnedGraphQuotingQuotingNodeAggregateSelection>;
};

export type VersionnedGraphQuotingQuotingNodeAggregateSelection = {
  __typename?: 'VersionnedGraphQuotingQuotingNodeAggregateSelection';
  amount: FloatAggregateSelection;
  code: StringAggregateSelection;
  description: StringAggregateSelection;
};

export type VersionnedGraphQuotingRelationship = {
  __typename?: 'VersionnedGraphQuotingRelationship';
  cursor: Scalars['String']['output'];
  node: Quoting;
};

export type VersionnedGraphQuotingUpdateConnectionInput = {
  node?: InputMaybe<QuotingUpdateInput>;
};

export type VersionnedGraphQuotingUpdateFieldInput = {
  connect?: InputMaybe<VersionnedGraphQuotingConnectFieldInput>;
  create?: InputMaybe<VersionnedGraphQuotingCreateFieldInput>;
  delete?: InputMaybe<VersionnedGraphQuotingDeleteFieldInput>;
  disconnect?: InputMaybe<VersionnedGraphQuotingDisconnectFieldInput>;
  update?: InputMaybe<VersionnedGraphQuotingUpdateConnectionInput>;
  where?: InputMaybe<VersionnedGraphQuotingConnectionWhere>;
};

export type VersionnedGraphRelationInput = {
  alerts?: InputMaybe<VersionnedGraphAlertsCreateFieldInput>;
  cooldown?: InputMaybe<VersionnedGraphCooldownCreateFieldInput>;
  firstStep?: InputMaybe<VersionnedGraphFirstStepCreateFieldInput>;
  modifiedBy?: InputMaybe<VersionnedGraphModifiedByCreateFieldInput>;
  questionnaire?: InputMaybe<VersionnedGraphQuestionnaireCreateFieldInput>;
  quoting?: InputMaybe<VersionnedGraphQuotingCreateFieldInput>;
  steps?: InputMaybe<Array<VersionnedGraphStepsCreateFieldInput>>;
};

/** Fields to sort VersionnedGraphs by. The order in which sorts are applied is not guaranteed when specifying many fields in one VersionnedGraphSort object. */
export type VersionnedGraphSort = {
  createdAt?: InputMaybe<SortDirection>;
  firstStepId?: InputMaybe<SortDirection>;
  hasDocument?: InputMaybe<SortDirection>;
  isTemplate?: InputMaybe<SortDirection>;
  maxScore?: InputMaybe<SortDirection>;
};

export type VersionnedGraphStepsAggregateInput = {
  AND?: InputMaybe<Array<VersionnedGraphStepsAggregateInput>>;
  NOT?: InputMaybe<VersionnedGraphStepsAggregateInput>;
  OR?: InputMaybe<Array<VersionnedGraphStepsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<VersionnedGraphStepsNodeAggregationWhereInput>;
};

export type VersionnedGraphStepsConnectFieldInput = {
  connect?: InputMaybe<QuestionnaireStepConnectInput>;
  where?: InputMaybe<QuestionnaireStepConnectWhere>;
};

export type VersionnedGraphStepsConnection = {
  __typename?: 'VersionnedGraphStepsConnection';
  edges: Array<VersionnedGraphStepsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type VersionnedGraphStepsConnectionSort = {
  node?: InputMaybe<QuestionnaireStepSort>;
};

export type VersionnedGraphStepsConnectionWhere = {
  AND?: InputMaybe<Array<VersionnedGraphStepsConnectionWhere>>;
  NOT?: InputMaybe<VersionnedGraphStepsConnectionWhere>;
  OR?: InputMaybe<Array<VersionnedGraphStepsConnectionWhere>>;
  node?: InputMaybe<QuestionnaireStepWhere>;
};

export type VersionnedGraphStepsCreateFieldInput = {
  node: QuestionnaireStepCreateInput;
};

export type VersionnedGraphStepsDeleteFieldInput = {
  delete?: InputMaybe<QuestionnaireStepDeleteInput>;
  where?: InputMaybe<VersionnedGraphStepsConnectionWhere>;
};

export type VersionnedGraphStepsDisconnectFieldInput = {
  disconnect?: InputMaybe<QuestionnaireStepDisconnectInput>;
  where?: InputMaybe<VersionnedGraphStepsConnectionWhere>;
};

export type VersionnedGraphStepsFieldInput = {
  connect?: InputMaybe<Array<VersionnedGraphStepsConnectFieldInput>>;
  create?: InputMaybe<Array<VersionnedGraphStepsCreateFieldInput>>;
};

export type VersionnedGraphStepsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<VersionnedGraphStepsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<VersionnedGraphStepsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<VersionnedGraphStepsNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type VersionnedGraphStepsRelationship = {
  __typename?: 'VersionnedGraphStepsRelationship';
  cursor: Scalars['String']['output'];
  node: QuestionnaireStep;
};

export type VersionnedGraphStepsUpdateConnectionInput = {
  node?: InputMaybe<QuestionnaireStepUpdateInput>;
};

export type VersionnedGraphStepsUpdateFieldInput = {
  connect?: InputMaybe<Array<VersionnedGraphStepsConnectFieldInput>>;
  create?: InputMaybe<Array<VersionnedGraphStepsCreateFieldInput>>;
  delete?: InputMaybe<Array<VersionnedGraphStepsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<VersionnedGraphStepsDisconnectFieldInput>>;
  update?: InputMaybe<VersionnedGraphStepsUpdateConnectionInput>;
  where?: InputMaybe<VersionnedGraphStepsConnectionWhere>;
};

export type VersionnedGraphUpdateInput = {
  alerts?: InputMaybe<VersionnedGraphAlertsUpdateFieldInput>;
  cooldown?: InputMaybe<VersionnedGraphCooldownUpdateFieldInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  firstStep?: InputMaybe<VersionnedGraphFirstStepUpdateFieldInput>;
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  modifiedBy?: InputMaybe<VersionnedGraphModifiedByUpdateInput>;
  questionnaire?: InputMaybe<VersionnedGraphQuestionnaireUpdateFieldInput>;
  quoting?: InputMaybe<VersionnedGraphQuotingUpdateFieldInput>;
  steps?: InputMaybe<Array<VersionnedGraphStepsUpdateFieldInput>>;
};

export type VersionnedGraphWhere = {
  AND?: InputMaybe<Array<VersionnedGraphWhere>>;
  NOT?: InputMaybe<VersionnedGraphWhere>;
  OR?: InputMaybe<Array<VersionnedGraphWhere>>;
  alerts?: InputMaybe<AlertGroupWhere>;
  alertsAggregate?: InputMaybe<VersionnedGraphAlertsAggregateInput>;
  alertsConnection?: InputMaybe<VersionnedGraphAlertsConnectionWhere>;
  alertsConnection_NOT?: InputMaybe<VersionnedGraphAlertsConnectionWhere>;
  alerts_NOT?: InputMaybe<AlertGroupWhere>;
  cooldown?: InputMaybe<CooldownWhere>;
  cooldownAggregate?: InputMaybe<VersionnedGraphCooldownAggregateInput>;
  cooldownConnection?: InputMaybe<VersionnedGraphCooldownConnectionWhere>;
  cooldownConnection_NOT?: InputMaybe<VersionnedGraphCooldownConnectionWhere>;
  cooldown_NOT?: InputMaybe<CooldownWhere>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_IN?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  createdAt_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  firstStep?: InputMaybe<QuestionnaireStepWhere>;
  firstStepAggregate?: InputMaybe<VersionnedGraphFirstStepAggregateInput>;
  firstStepConnection?: InputMaybe<VersionnedGraphFirstStepConnectionWhere>;
  firstStepConnection_NOT?: InputMaybe<VersionnedGraphFirstStepConnectionWhere>;
  firstStepId?: InputMaybe<Scalars['ID']['input']>;
  firstStepId_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  firstStepId_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  firstStepId_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  firstStepId_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  firstStep_NOT?: InputMaybe<QuestionnaireStepWhere>;
  hasDocument?: InputMaybe<Scalars['Boolean']['input']>;
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  maxScore?: InputMaybe<Scalars['Int']['input']>;
  maxScore_GT?: InputMaybe<Scalars['Int']['input']>;
  maxScore_GTE?: InputMaybe<Scalars['Int']['input']>;
  maxScore_IN?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  maxScore_LT?: InputMaybe<Scalars['Int']['input']>;
  maxScore_LTE?: InputMaybe<Scalars['Int']['input']>;
  modifiedBy?: InputMaybe<EditorWhere>;
  modifiedByConnection?: InputMaybe<VersionnedGraphModifiedByConnectionWhere>;
  modifiedByConnection_NOT?: InputMaybe<VersionnedGraphModifiedByConnectionWhere>;
  modifiedBy_NOT?: InputMaybe<EditorWhere>;
  questionnaire?: InputMaybe<BaseQuestionnaireWhere>;
  questionnaireAggregate?: InputMaybe<VersionnedGraphQuestionnaireAggregateInput>;
  questionnaireConnection?: InputMaybe<VersionnedGraphQuestionnaireConnectionWhere>;
  questionnaireConnection_NOT?: InputMaybe<VersionnedGraphQuestionnaireConnectionWhere>;
  questionnaire_NOT?: InputMaybe<BaseQuestionnaireWhere>;
  quoting?: InputMaybe<QuotingWhere>;
  quotingAggregate?: InputMaybe<VersionnedGraphQuotingAggregateInput>;
  quotingConnection?: InputMaybe<VersionnedGraphQuotingConnectionWhere>;
  quotingConnection_NOT?: InputMaybe<VersionnedGraphQuotingConnectionWhere>;
  quoting_NOT?: InputMaybe<QuotingWhere>;
  stepsAggregate?: InputMaybe<VersionnedGraphStepsAggregateInput>;
  /** Return VersionnedGraphs where all of the related VersionnedGraphStepsConnections match this filter */
  stepsConnection_ALL?: InputMaybe<VersionnedGraphStepsConnectionWhere>;
  /** Return VersionnedGraphs where none of the related VersionnedGraphStepsConnections match this filter */
  stepsConnection_NONE?: InputMaybe<VersionnedGraphStepsConnectionWhere>;
  /** Return VersionnedGraphs where one of the related VersionnedGraphStepsConnections match this filter */
  stepsConnection_SINGLE?: InputMaybe<VersionnedGraphStepsConnectionWhere>;
  /** Return VersionnedGraphs where some of the related VersionnedGraphStepsConnections match this filter */
  stepsConnection_SOME?: InputMaybe<VersionnedGraphStepsConnectionWhere>;
  /** Return VersionnedGraphs where all of the related QuestionnaireSteps match this filter */
  steps_ALL?: InputMaybe<QuestionnaireStepWhere>;
  /** Return VersionnedGraphs where none of the related QuestionnaireSteps match this filter */
  steps_NONE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return VersionnedGraphs where one of the related QuestionnaireSteps match this filter */
  steps_SINGLE?: InputMaybe<QuestionnaireStepWhere>;
  /** Return VersionnedGraphs where some of the related QuestionnaireSteps match this filter */
  steps_SOME?: InputMaybe<QuestionnaireStepWhere>;
};

export type VersionnedGraphsConnection = {
  __typename?: 'VersionnedGraphsConnection';
  edges: Array<VersionnedGraphEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/**
 * The edge properties for the following fields:
 * * VersionnedGraph.questionnaire
 * * Questionnaire.versions
 * * Workflow.versions
 */
export type VersionnedRelation = {
  __typename?: 'VersionnedRelation';
  version: Scalars['Int']['output'];
};

export type VersionnedRelationAggregationWhereInput = {
  AND?: InputMaybe<Array<VersionnedRelationAggregationWhereInput>>;
  NOT?: InputMaybe<VersionnedRelationAggregationWhereInput>;
  OR?: InputMaybe<Array<VersionnedRelationAggregationWhereInput>>;
  version_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  version_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>;
  version_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>;
  version_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>;
  version_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>;
  version_MAX_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  version_MAX_GT?: InputMaybe<Scalars['Int']['input']>;
  version_MAX_GTE?: InputMaybe<Scalars['Int']['input']>;
  version_MAX_LT?: InputMaybe<Scalars['Int']['input']>;
  version_MAX_LTE?: InputMaybe<Scalars['Int']['input']>;
  version_MIN_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  version_MIN_GT?: InputMaybe<Scalars['Int']['input']>;
  version_MIN_GTE?: InputMaybe<Scalars['Int']['input']>;
  version_MIN_LT?: InputMaybe<Scalars['Int']['input']>;
  version_MIN_LTE?: InputMaybe<Scalars['Int']['input']>;
  version_SUM_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  version_SUM_GT?: InputMaybe<Scalars['Int']['input']>;
  version_SUM_GTE?: InputMaybe<Scalars['Int']['input']>;
  version_SUM_LT?: InputMaybe<Scalars['Int']['input']>;
  version_SUM_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type VersionnedRelationCreateInput = {
  version: Scalars['Int']['input'];
};

export type VersionnedRelationSort = {
  version?: InputMaybe<SortDirection>;
};

export type VersionnedRelationUpdateInput = {
  version?: InputMaybe<Scalars['Int']['input']>;
  version_DECREMENT?: InputMaybe<Scalars['Int']['input']>;
  version_INCREMENT?: InputMaybe<Scalars['Int']['input']>;
};

export type VersionnedRelationWhere = {
  AND?: InputMaybe<Array<VersionnedRelationWhere>>;
  NOT?: InputMaybe<VersionnedRelationWhere>;
  OR?: InputMaybe<Array<VersionnedRelationWhere>>;
  version?: InputMaybe<Scalars['Int']['input']>;
  version_GT?: InputMaybe<Scalars['Int']['input']>;
  version_GTE?: InputMaybe<Scalars['Int']['input']>;
  version_IN?: InputMaybe<Array<Scalars['Int']['input']>>;
  version_LT?: InputMaybe<Scalars['Int']['input']>;
  version_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type Workflow = BaseQuestionnaire & {
  __typename?: 'Workflow';
  id: Scalars['ID']['output'];
  latest: VersionnedGraph;
  name: Scalars['String']['output'];
  owner?: Maybe<Owner>;
  ownerConnection: BaseQuestionnaireOwnerConnection;
  specialities: Array<Speciality>;
  specialitiesAggregate?: Maybe<WorkflowSpecialitySpecialitiesAggregationSelection>;
  specialitiesConnection: WorkflowSpecialitiesConnection;
  versions: Array<VersionnedGraph>;
  versionsAggregate?: Maybe<WorkflowVersionnedGraphVersionsAggregationSelection>;
  versionsConnection: BaseQuestionnaireVersionsConnection;
};


export type WorkflowOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<QueryOptions>;
  where?: InputMaybe<OwnerWhere>;
};


export type WorkflowOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BaseQuestionnaireOwnerConnectionWhere>;
};


export type WorkflowSpecialitiesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<SpecialityOptions>;
  where?: InputMaybe<SpecialityWhere>;
};


export type WorkflowSpecialitiesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<SpecialityWhere>;
};


export type WorkflowSpecialitiesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<WorkflowSpecialitiesConnectionSort>>;
  where?: InputMaybe<WorkflowSpecialitiesConnectionWhere>;
};


export type WorkflowVersionsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<VersionnedGraphOptions>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type WorkflowVersionsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<VersionnedGraphWhere>;
};


export type WorkflowVersionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<BaseQuestionnaireVersionsConnectionSort>>;
  where?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
};

export type WorkflowAggregateSelection = {
  __typename?: 'WorkflowAggregateSelection';
  count: Scalars['Int']['output'];
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type WorkflowConnectInput = {
  owner?: InputMaybe<WorkflowOwnerConnectInput>;
  specialities?: InputMaybe<Array<WorkflowSpecialitiesConnectFieldInput>>;
  versions?: InputMaybe<Array<WorkflowVersionsConnectFieldInput>>;
};

export type WorkflowConnectOrCreateInput = {
  owner?: InputMaybe<WorkflowOwnerConnectOrCreateInput>;
  specialities?: InputMaybe<Array<WorkflowSpecialitiesConnectOrCreateFieldInput>>;
};

export type WorkflowConnectOrCreateWhere = {
  node: WorkflowUniqueWhere;
};

export type WorkflowConnectWhere = {
  node: WorkflowWhere;
};

export type WorkflowCreateInput = {
  name: Scalars['String']['input'];
  owner?: InputMaybe<WorkflowOwnerCreateInput>;
  specialities?: InputMaybe<WorkflowSpecialitiesFieldInput>;
  versions?: InputMaybe<WorkflowVersionsFieldInput>;
};

export type WorkflowDeleteInput = {
  owner?: InputMaybe<WorkflowOwnerDeleteInput>;
  specialities?: InputMaybe<Array<WorkflowSpecialitiesDeleteFieldInput>>;
  versions?: InputMaybe<Array<BaseQuestionnaireVersionsDeleteFieldInput>>;
};

export type WorkflowDisconnectInput = {
  owner?: InputMaybe<WorkflowOwnerDisconnectInput>;
  specialities?: InputMaybe<Array<WorkflowSpecialitiesDisconnectFieldInput>>;
  versions?: InputMaybe<Array<BaseQuestionnaireVersionsDisconnectFieldInput>>;
};

export type WorkflowEdge = {
  __typename?: 'WorkflowEdge';
  cursor: Scalars['String']['output'];
  node: Workflow;
};

export type WorkflowLink = {
  __typename?: 'WorkflowLink';
  autoAppointmentDate?: Maybe<Scalars['Boolean']['output']>;
  deleted: Scalars['Boolean']['output'];
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  doctors: Array<Doctor>;
  doctorsAggregate?: Maybe<WorkflowLinkDoctorDoctorsAggregationSelection>;
  doctorsConnection: WorkflowLinkDoctorsConnection;
  id: Scalars['String']['output'];
  institution: Institution;
  institutionAggregate?: Maybe<WorkflowLinkInstitutionInstitutionAggregationSelection>;
  institutionConnection: WorkflowLinkInstitutionConnection;
  name?: Maybe<Scalars['String']['output']>;
  workflow: Workflow;
  workflowAggregate?: Maybe<WorkflowLinkWorkflowWorkflowAggregationSelection>;
  workflowConnection: WorkflowLinkWorkflowConnection;
};


export type WorkflowLinkDoctorsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<DoctorOptions>;
  where?: InputMaybe<DoctorWhere>;
};


export type WorkflowLinkDoctorsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<DoctorWhere>;
};


export type WorkflowLinkDoctorsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<WorkflowLinkDoctorsConnectionSort>>;
  where?: InputMaybe<WorkflowLinkDoctorsConnectionWhere>;
};


export type WorkflowLinkInstitutionArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<InstitutionOptions>;
  where?: InputMaybe<InstitutionWhere>;
};


export type WorkflowLinkInstitutionAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<InstitutionWhere>;
};


export type WorkflowLinkInstitutionConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<WorkflowLinkInstitutionConnectionSort>>;
  where?: InputMaybe<WorkflowLinkInstitutionConnectionWhere>;
};


export type WorkflowLinkWorkflowArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  options?: InputMaybe<WorkflowOptions>;
  where?: InputMaybe<WorkflowWhere>;
};


export type WorkflowLinkWorkflowAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  where?: InputMaybe<WorkflowWhere>;
};


export type WorkflowLinkWorkflowConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  directed?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<WorkflowLinkWorkflowConnectionSort>>;
  where?: InputMaybe<WorkflowLinkWorkflowConnectionWhere>;
};

export type WorkflowLinkAggregateSelection = {
  __typename?: 'WorkflowLinkAggregateSelection';
  count: Scalars['Int']['output'];
  deletedAt: DateTimeAggregateSelection;
  id: StringAggregateSelection;
  name: StringAggregateSelection;
};

export type WorkflowLinkConnectInput = {
  doctors?: InputMaybe<Array<WorkflowLinkDoctorsConnectFieldInput>>;
  institution?: InputMaybe<WorkflowLinkInstitutionConnectFieldInput>;
  workflow?: InputMaybe<WorkflowLinkWorkflowConnectFieldInput>;
};

export type WorkflowLinkConnectOrCreateInput = {
  doctors?: InputMaybe<Array<WorkflowLinkDoctorsConnectOrCreateFieldInput>>;
  institution?: InputMaybe<WorkflowLinkInstitutionConnectOrCreateFieldInput>;
  workflow?: InputMaybe<WorkflowLinkWorkflowConnectOrCreateFieldInput>;
};

export type WorkflowLinkConnectOrCreateWhere = {
  node: WorkflowLinkUniqueWhere;
};

export type WorkflowLinkConnectWhere = {
  node: WorkflowLinkWhere;
};

export type WorkflowLinkCreateInput = {
  autoAppointmentDate?: InputMaybe<Scalars['Boolean']['input']>;
  deleted?: Scalars['Boolean']['input'];
  doctors?: InputMaybe<WorkflowLinkDoctorsFieldInput>;
  institution?: InputMaybe<WorkflowLinkInstitutionFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  workflow?: InputMaybe<WorkflowLinkWorkflowFieldInput>;
};

export type WorkflowLinkDeleteInput = {
  doctors?: InputMaybe<Array<WorkflowLinkDoctorsDeleteFieldInput>>;
  institution?: InputMaybe<WorkflowLinkInstitutionDeleteFieldInput>;
  workflow?: InputMaybe<WorkflowLinkWorkflowDeleteFieldInput>;
};

export type WorkflowLinkDisconnectInput = {
  doctors?: InputMaybe<Array<WorkflowLinkDoctorsDisconnectFieldInput>>;
  institution?: InputMaybe<WorkflowLinkInstitutionDisconnectFieldInput>;
  workflow?: InputMaybe<WorkflowLinkWorkflowDisconnectFieldInput>;
};

export type WorkflowLinkDoctorDoctorsAggregationSelection = {
  __typename?: 'WorkflowLinkDoctorDoctorsAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<WorkflowLinkDoctorDoctorsNodeAggregateSelection>;
};

export type WorkflowLinkDoctorDoctorsNodeAggregateSelection = {
  __typename?: 'WorkflowLinkDoctorDoctorsNodeAggregateSelection';
  email: StringAggregateSelection;
  firstName: StringAggregateSelection;
  firstNameNormalized: StringAggregateSelection;
  id: IdAggregateSelection;
  lastName: StringAggregateSelection;
  lastNameNormalized: StringAggregateSelection;
  phone: StringAggregateSelection;
  rpps: StringAggregateSelection;
};

export type WorkflowLinkDoctorsAggregateInput = {
  AND?: InputMaybe<Array<WorkflowLinkDoctorsAggregateInput>>;
  NOT?: InputMaybe<WorkflowLinkDoctorsAggregateInput>;
  OR?: InputMaybe<Array<WorkflowLinkDoctorsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<WorkflowLinkDoctorsNodeAggregationWhereInput>;
};

export type WorkflowLinkDoctorsConnectFieldInput = {
  connect?: InputMaybe<Array<DoctorConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<DoctorConnectWhere>;
};

export type WorkflowLinkDoctorsConnectOrCreateFieldInput = {
  onCreate: WorkflowLinkDoctorsConnectOrCreateFieldInputOnCreate;
  where: DoctorConnectOrCreateWhere;
};

export type WorkflowLinkDoctorsConnectOrCreateFieldInputOnCreate = {
  node: DoctorOnCreateInput;
};

export type WorkflowLinkDoctorsConnection = {
  __typename?: 'WorkflowLinkDoctorsConnection';
  edges: Array<WorkflowLinkDoctorsRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type WorkflowLinkDoctorsConnectionSort = {
  node?: InputMaybe<DoctorSort>;
};

export type WorkflowLinkDoctorsConnectionWhere = {
  AND?: InputMaybe<Array<WorkflowLinkDoctorsConnectionWhere>>;
  NOT?: InputMaybe<WorkflowLinkDoctorsConnectionWhere>;
  OR?: InputMaybe<Array<WorkflowLinkDoctorsConnectionWhere>>;
  node?: InputMaybe<DoctorWhere>;
};

export type WorkflowLinkDoctorsCreateFieldInput = {
  node: DoctorCreateInput;
};

export type WorkflowLinkDoctorsDeleteFieldInput = {
  delete?: InputMaybe<DoctorDeleteInput>;
  where?: InputMaybe<WorkflowLinkDoctorsConnectionWhere>;
};

export type WorkflowLinkDoctorsDisconnectFieldInput = {
  disconnect?: InputMaybe<DoctorDisconnectInput>;
  where?: InputMaybe<WorkflowLinkDoctorsConnectionWhere>;
};

export type WorkflowLinkDoctorsFieldInput = {
  connect?: InputMaybe<Array<WorkflowLinkDoctorsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<WorkflowLinkDoctorsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<WorkflowLinkDoctorsCreateFieldInput>>;
};

export type WorkflowLinkDoctorsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<WorkflowLinkDoctorsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<WorkflowLinkDoctorsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<WorkflowLinkDoctorsNodeAggregationWhereInput>>;
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  firstName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  firstName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  firstName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastNameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastNameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  lastName_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  lastName_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  lastName_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  phone_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  phone_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  phone_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  rpps_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  rpps_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  rpps_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  rpps_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkflowLinkDoctorsRelationship = {
  __typename?: 'WorkflowLinkDoctorsRelationship';
  cursor: Scalars['String']['output'];
  node: Doctor;
};

export type WorkflowLinkDoctorsUpdateConnectionInput = {
  node?: InputMaybe<DoctorUpdateInput>;
};

export type WorkflowLinkDoctorsUpdateFieldInput = {
  connect?: InputMaybe<Array<WorkflowLinkDoctorsConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<WorkflowLinkDoctorsConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<WorkflowLinkDoctorsCreateFieldInput>>;
  delete?: InputMaybe<Array<WorkflowLinkDoctorsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<WorkflowLinkDoctorsDisconnectFieldInput>>;
  update?: InputMaybe<WorkflowLinkDoctorsUpdateConnectionInput>;
  where?: InputMaybe<WorkflowLinkDoctorsConnectionWhere>;
};

export type WorkflowLinkEdge = {
  __typename?: 'WorkflowLinkEdge';
  cursor: Scalars['String']['output'];
  node: WorkflowLink;
};

export type WorkflowLinkInstitutionAggregateInput = {
  AND?: InputMaybe<Array<WorkflowLinkInstitutionAggregateInput>>;
  NOT?: InputMaybe<WorkflowLinkInstitutionAggregateInput>;
  OR?: InputMaybe<Array<WorkflowLinkInstitutionAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<WorkflowLinkInstitutionNodeAggregationWhereInput>;
};

export type WorkflowLinkInstitutionConnectFieldInput = {
  connect?: InputMaybe<InstitutionConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<InstitutionConnectWhere>;
};

export type WorkflowLinkInstitutionConnectOrCreateFieldInput = {
  onCreate: WorkflowLinkInstitutionConnectOrCreateFieldInputOnCreate;
  where: InstitutionConnectOrCreateWhere;
};

export type WorkflowLinkInstitutionConnectOrCreateFieldInputOnCreate = {
  node: InstitutionOnCreateInput;
};

export type WorkflowLinkInstitutionConnection = {
  __typename?: 'WorkflowLinkInstitutionConnection';
  edges: Array<WorkflowLinkInstitutionRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type WorkflowLinkInstitutionConnectionSort = {
  node?: InputMaybe<InstitutionSort>;
};

export type WorkflowLinkInstitutionConnectionWhere = {
  AND?: InputMaybe<Array<WorkflowLinkInstitutionConnectionWhere>>;
  NOT?: InputMaybe<WorkflowLinkInstitutionConnectionWhere>;
  OR?: InputMaybe<Array<WorkflowLinkInstitutionConnectionWhere>>;
  node?: InputMaybe<InstitutionWhere>;
};

export type WorkflowLinkInstitutionCreateFieldInput = {
  node: InstitutionCreateInput;
};

export type WorkflowLinkInstitutionDeleteFieldInput = {
  delete?: InputMaybe<InstitutionDeleteInput>;
  where?: InputMaybe<WorkflowLinkInstitutionConnectionWhere>;
};

export type WorkflowLinkInstitutionDisconnectFieldInput = {
  disconnect?: InputMaybe<InstitutionDisconnectInput>;
  where?: InputMaybe<WorkflowLinkInstitutionConnectionWhere>;
};

export type WorkflowLinkInstitutionFieldInput = {
  connect?: InputMaybe<WorkflowLinkInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<WorkflowLinkInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<WorkflowLinkInstitutionCreateFieldInput>;
};

export type WorkflowLinkInstitutionInstitutionAggregationSelection = {
  __typename?: 'WorkflowLinkInstitutionInstitutionAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<WorkflowLinkInstitutionInstitutionNodeAggregateSelection>;
};

export type WorkflowLinkInstitutionInstitutionNodeAggregateSelection = {
  __typename?: 'WorkflowLinkInstitutionInstitutionNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type WorkflowLinkInstitutionNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<WorkflowLinkInstitutionNodeAggregationWhereInput>>;
  NOT?: InputMaybe<WorkflowLinkInstitutionNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<WorkflowLinkInstitutionNodeAggregationWhereInput>>;
  nameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkflowLinkInstitutionRelationship = {
  __typename?: 'WorkflowLinkInstitutionRelationship';
  cursor: Scalars['String']['output'];
  node: Institution;
};

export type WorkflowLinkInstitutionUpdateConnectionInput = {
  node?: InputMaybe<InstitutionUpdateInput>;
};

export type WorkflowLinkInstitutionUpdateFieldInput = {
  connect?: InputMaybe<WorkflowLinkInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<WorkflowLinkInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<WorkflowLinkInstitutionCreateFieldInput>;
  delete?: InputMaybe<WorkflowLinkInstitutionDeleteFieldInput>;
  disconnect?: InputMaybe<WorkflowLinkInstitutionDisconnectFieldInput>;
  update?: InputMaybe<WorkflowLinkInstitutionUpdateConnectionInput>;
  where?: InputMaybe<WorkflowLinkInstitutionConnectionWhere>;
};

export type WorkflowLinkOnCreateInput = {
  autoAppointmentDate?: InputMaybe<Scalars['Boolean']['input']>;
  deleted?: Scalars['Boolean']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

export type WorkflowLinkOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more WorkflowLinkSort objects to sort WorkflowLinks by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<WorkflowLinkSort>>;
};

export type WorkflowLinkRelationInput = {
  doctors?: InputMaybe<Array<WorkflowLinkDoctorsCreateFieldInput>>;
  institution?: InputMaybe<WorkflowLinkInstitutionCreateFieldInput>;
  workflow?: InputMaybe<WorkflowLinkWorkflowCreateFieldInput>;
};

/** Fields to sort WorkflowLinks by. The order in which sorts are applied is not guaranteed when specifying many fields in one WorkflowLinkSort object. */
export type WorkflowLinkSort = {
  autoAppointmentDate?: InputMaybe<SortDirection>;
  deleted?: InputMaybe<SortDirection>;
  deletedAt?: InputMaybe<SortDirection>;
  id?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type WorkflowLinkUniqueWhere = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type WorkflowLinkUpdateInput = {
  autoAppointmentDate?: InputMaybe<Scalars['Boolean']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  doctors?: InputMaybe<Array<WorkflowLinkDoctorsUpdateFieldInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  institution?: InputMaybe<WorkflowLinkInstitutionUpdateFieldInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  workflow?: InputMaybe<WorkflowLinkWorkflowUpdateFieldInput>;
};

export type WorkflowLinkWhere = {
  AND?: InputMaybe<Array<WorkflowLinkWhere>>;
  NOT?: InputMaybe<WorkflowLinkWhere>;
  OR?: InputMaybe<Array<WorkflowLinkWhere>>;
  autoAppointmentDate?: InputMaybe<Scalars['Boolean']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAt?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_GT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_IN?: InputMaybe<Array<InputMaybe<Scalars['DateTime']['input']>>>;
  deletedAt_LT?: InputMaybe<Scalars['DateTime']['input']>;
  deletedAt_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  doctorsAggregate?: InputMaybe<WorkflowLinkDoctorsAggregateInput>;
  /** Return WorkflowLinks where all of the related WorkflowLinkDoctorsConnections match this filter */
  doctorsConnection_ALL?: InputMaybe<WorkflowLinkDoctorsConnectionWhere>;
  /** Return WorkflowLinks where none of the related WorkflowLinkDoctorsConnections match this filter */
  doctorsConnection_NONE?: InputMaybe<WorkflowLinkDoctorsConnectionWhere>;
  /** Return WorkflowLinks where one of the related WorkflowLinkDoctorsConnections match this filter */
  doctorsConnection_SINGLE?: InputMaybe<WorkflowLinkDoctorsConnectionWhere>;
  /** Return WorkflowLinks where some of the related WorkflowLinkDoctorsConnections match this filter */
  doctorsConnection_SOME?: InputMaybe<WorkflowLinkDoctorsConnectionWhere>;
  /** Return WorkflowLinks where all of the related Doctors match this filter */
  doctors_ALL?: InputMaybe<DoctorWhere>;
  /** Return WorkflowLinks where none of the related Doctors match this filter */
  doctors_NONE?: InputMaybe<DoctorWhere>;
  /** Return WorkflowLinks where one of the related Doctors match this filter */
  doctors_SINGLE?: InputMaybe<DoctorWhere>;
  /** Return WorkflowLinks where some of the related Doctors match this filter */
  doctors_SOME?: InputMaybe<DoctorWhere>;
  id?: InputMaybe<Scalars['String']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  id_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  institution?: InputMaybe<InstitutionWhere>;
  institutionAggregate?: InputMaybe<WorkflowLinkInstitutionAggregateInput>;
  institutionConnection?: InputMaybe<WorkflowLinkInstitutionConnectionWhere>;
  institutionConnection_NOT?: InputMaybe<WorkflowLinkInstitutionConnectionWhere>;
  institution_NOT?: InputMaybe<InstitutionWhere>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  workflow?: InputMaybe<WorkflowWhere>;
  workflowAggregate?: InputMaybe<WorkflowLinkWorkflowAggregateInput>;
  workflowConnection?: InputMaybe<WorkflowLinkWorkflowConnectionWhere>;
  workflowConnection_NOT?: InputMaybe<WorkflowLinkWorkflowConnectionWhere>;
  workflow_NOT?: InputMaybe<WorkflowWhere>;
};

export type WorkflowLinkWorkflowAggregateInput = {
  AND?: InputMaybe<Array<WorkflowLinkWorkflowAggregateInput>>;
  NOT?: InputMaybe<WorkflowLinkWorkflowAggregateInput>;
  OR?: InputMaybe<Array<WorkflowLinkWorkflowAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<WorkflowLinkWorkflowNodeAggregationWhereInput>;
};

export type WorkflowLinkWorkflowConnectFieldInput = {
  connect?: InputMaybe<WorkflowConnectInput>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<WorkflowConnectWhere>;
};

export type WorkflowLinkWorkflowConnectOrCreateFieldInput = {
  onCreate: WorkflowLinkWorkflowConnectOrCreateFieldInputOnCreate;
  where: WorkflowConnectOrCreateWhere;
};

export type WorkflowLinkWorkflowConnectOrCreateFieldInputOnCreate = {
  node: WorkflowOnCreateInput;
};

export type WorkflowLinkWorkflowConnection = {
  __typename?: 'WorkflowLinkWorkflowConnection';
  edges: Array<WorkflowLinkWorkflowRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type WorkflowLinkWorkflowConnectionSort = {
  node?: InputMaybe<WorkflowSort>;
};

export type WorkflowLinkWorkflowConnectionWhere = {
  AND?: InputMaybe<Array<WorkflowLinkWorkflowConnectionWhere>>;
  NOT?: InputMaybe<WorkflowLinkWorkflowConnectionWhere>;
  OR?: InputMaybe<Array<WorkflowLinkWorkflowConnectionWhere>>;
  node?: InputMaybe<WorkflowWhere>;
};

export type WorkflowLinkWorkflowCreateFieldInput = {
  node: WorkflowCreateInput;
};

export type WorkflowLinkWorkflowDeleteFieldInput = {
  delete?: InputMaybe<WorkflowDeleteInput>;
  where?: InputMaybe<WorkflowLinkWorkflowConnectionWhere>;
};

export type WorkflowLinkWorkflowDisconnectFieldInput = {
  disconnect?: InputMaybe<WorkflowDisconnectInput>;
  where?: InputMaybe<WorkflowLinkWorkflowConnectionWhere>;
};

export type WorkflowLinkWorkflowFieldInput = {
  connect?: InputMaybe<WorkflowLinkWorkflowConnectFieldInput>;
  connectOrCreate?: InputMaybe<WorkflowLinkWorkflowConnectOrCreateFieldInput>;
  create?: InputMaybe<WorkflowLinkWorkflowCreateFieldInput>;
};

export type WorkflowLinkWorkflowNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<WorkflowLinkWorkflowNodeAggregationWhereInput>>;
  NOT?: InputMaybe<WorkflowLinkWorkflowNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<WorkflowLinkWorkflowNodeAggregationWhereInput>>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkflowLinkWorkflowRelationship = {
  __typename?: 'WorkflowLinkWorkflowRelationship';
  cursor: Scalars['String']['output'];
  node: Workflow;
};

export type WorkflowLinkWorkflowUpdateConnectionInput = {
  node?: InputMaybe<WorkflowUpdateInput>;
};

export type WorkflowLinkWorkflowUpdateFieldInput = {
  connect?: InputMaybe<WorkflowLinkWorkflowConnectFieldInput>;
  connectOrCreate?: InputMaybe<WorkflowLinkWorkflowConnectOrCreateFieldInput>;
  create?: InputMaybe<WorkflowLinkWorkflowCreateFieldInput>;
  delete?: InputMaybe<WorkflowLinkWorkflowDeleteFieldInput>;
  disconnect?: InputMaybe<WorkflowLinkWorkflowDisconnectFieldInput>;
  update?: InputMaybe<WorkflowLinkWorkflowUpdateConnectionInput>;
  where?: InputMaybe<WorkflowLinkWorkflowConnectionWhere>;
};

export type WorkflowLinkWorkflowWorkflowAggregationSelection = {
  __typename?: 'WorkflowLinkWorkflowWorkflowAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<WorkflowLinkWorkflowWorkflowNodeAggregateSelection>;
};

export type WorkflowLinkWorkflowWorkflowNodeAggregateSelection = {
  __typename?: 'WorkflowLinkWorkflowWorkflowNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
};

export type WorkflowLinksConnection = {
  __typename?: 'WorkflowLinksConnection';
  edges: Array<WorkflowLinkEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type WorkflowOnCreateInput = {
  name: Scalars['String']['input'];
};

export type WorkflowOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Specify one or more WorkflowSort objects to sort Workflows by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<WorkflowSort>>;
};

export type WorkflowOwnerConnectInput = {
  Doctor?: InputMaybe<WorkflowOwnerDoctorConnectFieldInput>;
  Institution?: InputMaybe<WorkflowOwnerInstitutionConnectFieldInput>;
};

export type WorkflowOwnerConnectOrCreateInput = {
  Doctor?: InputMaybe<WorkflowOwnerDoctorConnectOrCreateFieldInput>;
  Institution?: InputMaybe<WorkflowOwnerInstitutionConnectOrCreateFieldInput>;
};

export type WorkflowOwnerCreateFieldInput = {
  Doctor?: InputMaybe<WorkflowOwnerDoctorCreateFieldInput>;
  Institution?: InputMaybe<WorkflowOwnerInstitutionCreateFieldInput>;
};

export type WorkflowOwnerCreateInput = {
  Doctor?: InputMaybe<WorkflowOwnerDoctorFieldInput>;
  Institution?: InputMaybe<WorkflowOwnerInstitutionFieldInput>;
};

export type WorkflowOwnerDeleteInput = {
  Doctor?: InputMaybe<BaseQuestionnaireOwnerDoctorDeleteFieldInput>;
  Institution?: InputMaybe<BaseQuestionnaireOwnerInstitutionDeleteFieldInput>;
};

export type WorkflowOwnerDisconnectInput = {
  Doctor?: InputMaybe<BaseQuestionnaireOwnerDoctorDisconnectFieldInput>;
  Institution?: InputMaybe<BaseQuestionnaireOwnerInstitutionDisconnectFieldInput>;
};

export type WorkflowOwnerDoctorConnectFieldInput = {
  connect?: InputMaybe<DoctorConnectInput>;
  where?: InputMaybe<DoctorConnectWhere>;
};

export type WorkflowOwnerDoctorConnectOrCreateFieldInput = {
  onCreate: WorkflowOwnerDoctorConnectOrCreateFieldInputOnCreate;
  where: DoctorConnectOrCreateWhere;
};

export type WorkflowOwnerDoctorConnectOrCreateFieldInputOnCreate = {
  node: DoctorOnCreateInput;
};

export type WorkflowOwnerDoctorCreateFieldInput = {
  node: DoctorCreateInput;
};

export type WorkflowOwnerDoctorFieldInput = {
  connect?: InputMaybe<WorkflowOwnerDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<WorkflowOwnerDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<WorkflowOwnerDoctorCreateFieldInput>;
};

export type WorkflowOwnerDoctorUpdateConnectionInput = {
  node?: InputMaybe<DoctorUpdateInput>;
};

export type WorkflowOwnerDoctorUpdateFieldInput = {
  connect?: InputMaybe<WorkflowOwnerDoctorConnectFieldInput>;
  connectOrCreate?: InputMaybe<WorkflowOwnerDoctorConnectOrCreateFieldInput>;
  create?: InputMaybe<WorkflowOwnerDoctorCreateFieldInput>;
  delete?: InputMaybe<BaseQuestionnaireOwnerDoctorDeleteFieldInput>;
  disconnect?: InputMaybe<BaseQuestionnaireOwnerDoctorDisconnectFieldInput>;
  update?: InputMaybe<WorkflowOwnerDoctorUpdateConnectionInput>;
  where?: InputMaybe<BaseQuestionnaireOwnerDoctorConnectionWhere>;
};

export type WorkflowOwnerInstitutionConnectFieldInput = {
  connect?: InputMaybe<InstitutionConnectInput>;
  where?: InputMaybe<InstitutionConnectWhere>;
};

export type WorkflowOwnerInstitutionConnectOrCreateFieldInput = {
  onCreate: WorkflowOwnerInstitutionConnectOrCreateFieldInputOnCreate;
  where: InstitutionConnectOrCreateWhere;
};

export type WorkflowOwnerInstitutionConnectOrCreateFieldInputOnCreate = {
  node: InstitutionOnCreateInput;
};

export type WorkflowOwnerInstitutionCreateFieldInput = {
  node: InstitutionCreateInput;
};

export type WorkflowOwnerInstitutionFieldInput = {
  connect?: InputMaybe<WorkflowOwnerInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<WorkflowOwnerInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<WorkflowOwnerInstitutionCreateFieldInput>;
};

export type WorkflowOwnerInstitutionUpdateConnectionInput = {
  node?: InputMaybe<InstitutionUpdateInput>;
};

export type WorkflowOwnerInstitutionUpdateFieldInput = {
  connect?: InputMaybe<WorkflowOwnerInstitutionConnectFieldInput>;
  connectOrCreate?: InputMaybe<WorkflowOwnerInstitutionConnectOrCreateFieldInput>;
  create?: InputMaybe<WorkflowOwnerInstitutionCreateFieldInput>;
  delete?: InputMaybe<BaseQuestionnaireOwnerInstitutionDeleteFieldInput>;
  disconnect?: InputMaybe<BaseQuestionnaireOwnerInstitutionDisconnectFieldInput>;
  update?: InputMaybe<WorkflowOwnerInstitutionUpdateConnectionInput>;
  where?: InputMaybe<BaseQuestionnaireOwnerInstitutionConnectionWhere>;
};

export type WorkflowOwnerUpdateInput = {
  Doctor?: InputMaybe<WorkflowOwnerDoctorUpdateFieldInput>;
  Institution?: InputMaybe<WorkflowOwnerInstitutionUpdateFieldInput>;
};

export type WorkflowRelationInput = {
  owner?: InputMaybe<WorkflowOwnerCreateFieldInput>;
  specialities?: InputMaybe<Array<WorkflowSpecialitiesCreateFieldInput>>;
  versions?: InputMaybe<Array<WorkflowVersionsCreateFieldInput>>;
};

/** Fields to sort Workflows by. The order in which sorts are applied is not guaranteed when specifying many fields in one WorkflowSort object. */
export type WorkflowSort = {
  id?: InputMaybe<SortDirection>;
  latest?: InputMaybe<SortDirection>;
  name?: InputMaybe<SortDirection>;
};

export type WorkflowSpecialitiesAggregateInput = {
  AND?: InputMaybe<Array<WorkflowSpecialitiesAggregateInput>>;
  NOT?: InputMaybe<WorkflowSpecialitiesAggregateInput>;
  OR?: InputMaybe<Array<WorkflowSpecialitiesAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  node?: InputMaybe<WorkflowSpecialitiesNodeAggregationWhereInput>;
};

export type WorkflowSpecialitiesConnectFieldInput = {
  connect?: InputMaybe<Array<SpecialityConnectInput>>;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<SpecialityConnectWhere>;
};

export type WorkflowSpecialitiesConnectOrCreateFieldInput = {
  onCreate: WorkflowSpecialitiesConnectOrCreateFieldInputOnCreate;
  where: SpecialityConnectOrCreateWhere;
};

export type WorkflowSpecialitiesConnectOrCreateFieldInputOnCreate = {
  node: SpecialityOnCreateInput;
};

export type WorkflowSpecialitiesConnection = {
  __typename?: 'WorkflowSpecialitiesConnection';
  edges: Array<WorkflowSpecialitiesRelationship>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type WorkflowSpecialitiesConnectionSort = {
  node?: InputMaybe<SpecialitySort>;
};

export type WorkflowSpecialitiesConnectionWhere = {
  AND?: InputMaybe<Array<WorkflowSpecialitiesConnectionWhere>>;
  NOT?: InputMaybe<WorkflowSpecialitiesConnectionWhere>;
  OR?: InputMaybe<Array<WorkflowSpecialitiesConnectionWhere>>;
  node?: InputMaybe<SpecialityWhere>;
};

export type WorkflowSpecialitiesCreateFieldInput = {
  node: SpecialityCreateInput;
};

export type WorkflowSpecialitiesDeleteFieldInput = {
  delete?: InputMaybe<SpecialityDeleteInput>;
  where?: InputMaybe<WorkflowSpecialitiesConnectionWhere>;
};

export type WorkflowSpecialitiesDisconnectFieldInput = {
  disconnect?: InputMaybe<SpecialityDisconnectInput>;
  where?: InputMaybe<WorkflowSpecialitiesConnectionWhere>;
};

export type WorkflowSpecialitiesFieldInput = {
  connect?: InputMaybe<Array<WorkflowSpecialitiesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<WorkflowSpecialitiesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<WorkflowSpecialitiesCreateFieldInput>>;
};

export type WorkflowSpecialitiesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<WorkflowSpecialitiesNodeAggregationWhereInput>>;
  NOT?: InputMaybe<WorkflowSpecialitiesNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<WorkflowSpecialitiesNodeAggregationWhereInput>>;
  nameNormalized_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  nameNormalized_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  nameNormalized_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>;
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>;
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>;
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkflowSpecialitiesRelationship = {
  __typename?: 'WorkflowSpecialitiesRelationship';
  cursor: Scalars['String']['output'];
  node: Speciality;
};

export type WorkflowSpecialitiesUpdateConnectionInput = {
  node?: InputMaybe<SpecialityUpdateInput>;
};

export type WorkflowSpecialitiesUpdateFieldInput = {
  connect?: InputMaybe<Array<WorkflowSpecialitiesConnectFieldInput>>;
  connectOrCreate?: InputMaybe<Array<WorkflowSpecialitiesConnectOrCreateFieldInput>>;
  create?: InputMaybe<Array<WorkflowSpecialitiesCreateFieldInput>>;
  delete?: InputMaybe<Array<WorkflowSpecialitiesDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<WorkflowSpecialitiesDisconnectFieldInput>>;
  update?: InputMaybe<WorkflowSpecialitiesUpdateConnectionInput>;
  where?: InputMaybe<WorkflowSpecialitiesConnectionWhere>;
};

export type WorkflowSpecialitySpecialitiesAggregationSelection = {
  __typename?: 'WorkflowSpecialitySpecialitiesAggregationSelection';
  count: Scalars['Int']['output'];
  node?: Maybe<WorkflowSpecialitySpecialitiesNodeAggregateSelection>;
};

export type WorkflowSpecialitySpecialitiesNodeAggregateSelection = {
  __typename?: 'WorkflowSpecialitySpecialitiesNodeAggregateSelection';
  id: IdAggregateSelection;
  name: StringAggregateSelection;
  nameNormalized: StringAggregateSelection;
};

export type WorkflowUniqueWhere = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type WorkflowUpdateInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<WorkflowOwnerUpdateInput>;
  specialities?: InputMaybe<Array<WorkflowSpecialitiesUpdateFieldInput>>;
  versions?: InputMaybe<Array<WorkflowVersionsUpdateFieldInput>>;
};

export type WorkflowVersionnedGraphVersionsAggregationSelection = {
  __typename?: 'WorkflowVersionnedGraphVersionsAggregationSelection';
  count: Scalars['Int']['output'];
  edge?: Maybe<WorkflowVersionnedGraphVersionsEdgeAggregateSelection>;
  node?: Maybe<WorkflowVersionnedGraphVersionsNodeAggregateSelection>;
};

export type WorkflowVersionnedGraphVersionsEdgeAggregateSelection = {
  __typename?: 'WorkflowVersionnedGraphVersionsEdgeAggregateSelection';
  version: IntAggregateSelection;
};

export type WorkflowVersionnedGraphVersionsNodeAggregateSelection = {
  __typename?: 'WorkflowVersionnedGraphVersionsNodeAggregateSelection';
  createdAt: DateTimeAggregateSelection;
};

export type WorkflowVersionsAggregateInput = {
  AND?: InputMaybe<Array<WorkflowVersionsAggregateInput>>;
  NOT?: InputMaybe<WorkflowVersionsAggregateInput>;
  OR?: InputMaybe<Array<WorkflowVersionsAggregateInput>>;
  count?: InputMaybe<Scalars['Int']['input']>;
  count_GT?: InputMaybe<Scalars['Int']['input']>;
  count_GTE?: InputMaybe<Scalars['Int']['input']>;
  count_LT?: InputMaybe<Scalars['Int']['input']>;
  count_LTE?: InputMaybe<Scalars['Int']['input']>;
  edge?: InputMaybe<VersionnedRelationAggregationWhereInput>;
  node?: InputMaybe<WorkflowVersionsNodeAggregationWhereInput>;
};

export type WorkflowVersionsConnectFieldInput = {
  connect?: InputMaybe<Array<VersionnedGraphConnectInput>>;
  edge: VersionnedRelationCreateInput;
  /** Whether or not to overwrite any matching relationship with the new properties. */
  overwrite?: Scalars['Boolean']['input'];
  where?: InputMaybe<VersionnedGraphConnectWhere>;
};

export type WorkflowVersionsCreateFieldInput = {
  edge: VersionnedRelationCreateInput;
  node: VersionnedGraphCreateInput;
};

export type WorkflowVersionsFieldInput = {
  connect?: InputMaybe<Array<WorkflowVersionsConnectFieldInput>>;
  create?: InputMaybe<Array<WorkflowVersionsCreateFieldInput>>;
};

export type WorkflowVersionsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<WorkflowVersionsNodeAggregationWhereInput>>;
  NOT?: InputMaybe<WorkflowVersionsNodeAggregationWhereInput>;
  OR?: InputMaybe<Array<WorkflowVersionsNodeAggregationWhereInput>>;
  createdAt_MAX_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MAX_LTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_EQUAL?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_GTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_MIN_LTE?: InputMaybe<Scalars['DateTime']['input']>;
};

export type WorkflowVersionsUpdateConnectionInput = {
  edge?: InputMaybe<VersionnedRelationUpdateInput>;
  node?: InputMaybe<VersionnedGraphUpdateInput>;
};

export type WorkflowVersionsUpdateFieldInput = {
  connect?: InputMaybe<Array<WorkflowVersionsConnectFieldInput>>;
  create?: InputMaybe<Array<WorkflowVersionsCreateFieldInput>>;
  delete?: InputMaybe<Array<BaseQuestionnaireVersionsDeleteFieldInput>>;
  disconnect?: InputMaybe<Array<BaseQuestionnaireVersionsDisconnectFieldInput>>;
  update?: InputMaybe<WorkflowVersionsUpdateConnectionInput>;
  where?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
};

export type WorkflowWhere = {
  AND?: InputMaybe<Array<WorkflowWhere>>;
  NOT?: InputMaybe<WorkflowWhere>;
  OR?: InputMaybe<Array<WorkflowWhere>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>;
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>;
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>;
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>;
  latest?: InputMaybe<VersionnedGraphWhere>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>;
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>;
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>;
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<OwnerWhere>;
  ownerConnection?: InputMaybe<BaseQuestionnaireOwnerConnectionWhere>;
  ownerConnection_NOT?: InputMaybe<BaseQuestionnaireOwnerConnectionWhere>;
  owner_NOT?: InputMaybe<OwnerWhere>;
  specialitiesAggregate?: InputMaybe<WorkflowSpecialitiesAggregateInput>;
  /** Return Workflows where all of the related WorkflowSpecialitiesConnections match this filter */
  specialitiesConnection_ALL?: InputMaybe<WorkflowSpecialitiesConnectionWhere>;
  /** Return Workflows where none of the related WorkflowSpecialitiesConnections match this filter */
  specialitiesConnection_NONE?: InputMaybe<WorkflowSpecialitiesConnectionWhere>;
  /** Return Workflows where one of the related WorkflowSpecialitiesConnections match this filter */
  specialitiesConnection_SINGLE?: InputMaybe<WorkflowSpecialitiesConnectionWhere>;
  /** Return Workflows where some of the related WorkflowSpecialitiesConnections match this filter */
  specialitiesConnection_SOME?: InputMaybe<WorkflowSpecialitiesConnectionWhere>;
  /** Return Workflows where all of the related Specialities match this filter */
  specialities_ALL?: InputMaybe<SpecialityWhere>;
  /** Return Workflows where none of the related Specialities match this filter */
  specialities_NONE?: InputMaybe<SpecialityWhere>;
  /** Return Workflows where one of the related Specialities match this filter */
  specialities_SINGLE?: InputMaybe<SpecialityWhere>;
  /** Return Workflows where some of the related Specialities match this filter */
  specialities_SOME?: InputMaybe<SpecialityWhere>;
  versionsAggregate?: InputMaybe<WorkflowVersionsAggregateInput>;
  /** Return Workflows where all of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_ALL?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return Workflows where none of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_NONE?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return Workflows where one of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_SINGLE?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return Workflows where some of the related BaseQuestionnaireVersionsConnections match this filter */
  versionsConnection_SOME?: InputMaybe<BaseQuestionnaireVersionsConnectionWhere>;
  /** Return Workflows where all of the related VersionnedGraphs match this filter */
  versions_ALL?: InputMaybe<VersionnedGraphWhere>;
  /** Return Workflows where none of the related VersionnedGraphs match this filter */
  versions_NONE?: InputMaybe<VersionnedGraphWhere>;
  /** Return Workflows where one of the related VersionnedGraphs match this filter */
  versions_SINGLE?: InputMaybe<VersionnedGraphWhere>;
  /** Return Workflows where some of the related VersionnedGraphs match this filter */
  versions_SOME?: InputMaybe<VersionnedGraphWhere>;
};

export type WorkflowsConnection = {
  __typename?: 'WorkflowsConnection';
  edges: Array<WorkflowEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type DoctorFragment = { __typename?: 'Doctor', id: string, firstName: string, lastName: string, speciality?: { __typename?: 'Speciality', name: string } | null, picture?: { __typename?: 'Document', url?: string | null } | null };

export type InstitutionFragment = { __typename?: 'Institution', id: string, name: string, operatingMode: OperatingMode, subscriptionPlan: SubscriptionPlan };

export type PatientFragment = { __typename?: 'Patient', id: string, firstName?: string | null, lastName?: string | null, birthName?: string | null, gender?: string | null, email?: string | null };

type StepFragment_CheckboxQuestion_Fragment = { __typename: 'CheckboxQuestion', id: string };

type StepFragment_DateQuestion_Fragment = { __typename: 'DateQuestion', id: string };

type StepFragment_QuestionnaireAi_Fragment = { __typename: 'QuestionnaireAi', id: string };

type StepFragment_QuestionnaireAppointmentDate_Fragment = { __typename: 'QuestionnaireAppointmentDate', id: string };

type StepFragment_QuestionnaireCondition_Fragment = { __typename: 'QuestionnaireCondition', id: string };

type StepFragment_QuestionnaireDocument_Fragment = { __typename: 'QuestionnaireDocument', id: string };

type StepFragment_QuestionnaireDocumentFiller_Fragment = { __typename: 'QuestionnaireDocumentFiller', id: string };

type StepFragment_QuestionnaireIdentity_Fragment = { __typename: 'QuestionnaireIdentity', id: string };

type StepFragment_QuestionnaireInfoStep_Fragment = { __typename: 'QuestionnaireInfoStep', id: string };

type StepFragment_QuestionnaireInterview_Fragment = { __typename: 'QuestionnaireInterview', id: string };

type StepFragment_QuestionnaireMenu_Fragment = { __typename: 'QuestionnaireMenu', id: string };

type StepFragment_QuestionnaireRouter_Fragment = { __typename: 'QuestionnaireRouter', id: string };

type StepFragment_QuestionnaireSelectMenu_Fragment = { __typename: 'QuestionnaireSelectMenu', id: string };

type StepFragment_QuestionnaireSetProperty_Fragment = { __typename: 'QuestionnaireSetProperty', id: string };

type StepFragment_QuestionnaireSurvey_Fragment = { __typename: 'QuestionnaireSurvey', id: string };

type StepFragment_QuestionnaireThirdParty_Fragment = { __typename: 'QuestionnaireThirdParty', id: string };

type StepFragment_QuestionnaireWelcomeStep_Fragment = { __typename: 'QuestionnaireWelcomeStep', id: string };

type StepFragment_RadioQuestion_Fragment = { __typename: 'RadioQuestion', id: string };

type StepFragment_RangeQuestion_Fragment = { __typename: 'RangeQuestion', id: string };

type StepFragment_SelectQuestion_Fragment = { __typename: 'SelectQuestion', id: string };

type StepFragment_TextQuestion_Fragment = { __typename: 'TextQuestion', id: string };

export type StepFragmentFragment = StepFragment_CheckboxQuestion_Fragment | StepFragment_DateQuestion_Fragment | StepFragment_QuestionnaireAi_Fragment | StepFragment_QuestionnaireAppointmentDate_Fragment | StepFragment_QuestionnaireCondition_Fragment | StepFragment_QuestionnaireDocument_Fragment | StepFragment_QuestionnaireDocumentFiller_Fragment | StepFragment_QuestionnaireIdentity_Fragment | StepFragment_QuestionnaireInfoStep_Fragment | StepFragment_QuestionnaireInterview_Fragment | StepFragment_QuestionnaireMenu_Fragment | StepFragment_QuestionnaireRouter_Fragment | StepFragment_QuestionnaireSelectMenu_Fragment | StepFragment_QuestionnaireSetProperty_Fragment | StepFragment_QuestionnaireSurvey_Fragment | StepFragment_QuestionnaireThirdParty_Fragment | StepFragment_QuestionnaireWelcomeStep_Fragment | StepFragment_RadioQuestion_Fragment | StepFragment_RangeQuestion_Fragment | StepFragment_SelectQuestion_Fragment | StepFragment_TextQuestion_Fragment;

export type GetAiResponseQueryVariables = Exact<{
  questionIndex: Scalars['Int']['input'];
  questionnaireId: Scalars['ID']['input'];
}>;


export type GetAiResponseQuery = { __typename?: 'Query', aiResponse?: { __typename?: 'AiResponse', type: AiResponseType, name: string, hint?: string | null, placeholder?: string | null, choices?: Array<string> | null } | null };

export type GetDoctorQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetDoctorQuery = { __typename?: 'Query', doctors: Array<{ __typename?: 'Doctor', id: string, firstName: string, lastName: string, speciality?: { __typename?: 'Speciality', name: string } | null, picture?: { __typename?: 'Document', url?: string | null } | null }> };

export type ReceiveInfoByEmailMutationVariables = Exact<{
  question: Scalars['ID']['input'];
  email: Scalars['String']['input'];
}>;


export type ReceiveInfoByEmailMutation = { __typename?: 'Mutation', sendNoticeByEmail?: boolean | null };

export type GetInstitutionDoctorsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetInstitutionDoctorsQuery = { __typename?: 'Query', institutions: Array<{ __typename?: 'Institution', doctors: Array<{ __typename?: 'Doctor', id: string, firstName: string, lastName: string, speciality?: { __typename?: 'Speciality', name: string } | null, picture?: { __typename?: 'Document', url?: string | null } | null }> }> };

export type CreateSessionMutationVariables = Exact<{
  linkId: Scalars['String']['input'];
  isDeviceLink: Scalars['Boolean']['input'];
  doctorId: Scalars['ID']['input'];
}>;


export type CreateSessionMutation = { __typename?: 'Mutation', createSession: string };

export type AnswerMutationVariables = Exact<{
  session: Scalars['ID']['input'];
  question: Scalars['ID']['input'];
  values: Array<Scalars['String']['input']> | Scalars['String']['input'];
  field?: InputMaybe<Scalars['String']['input']>;
  order: Scalars['Int']['input'];
  hint?: InputMaybe<Scalars['String']['input']>;
  choices?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
  type?: InputMaybe<AiResponseType>;
}>;


export type AnswerMutation = { __typename?: 'Mutation', answer: boolean };

export type CompleteInterviewMutationVariables = Exact<{
  session: Scalars['ID']['input'];
}>;


export type CompleteInterviewMutation = { __typename?: 'Mutation', completeInterview: boolean };

export type ThirdPartySessionQueryVariables = Exact<{
  session: Scalars['ID']['input'];
}>;


export type ThirdPartySessionQuery = { __typename?: 'Query', isThirdPartySession?: boolean | null };

export type GetNextStepQueryVariables = Exact<{
  session: Scalars['ID']['input'];
  question: Scalars['ID']['input'];
}>;


export type GetNextStepQuery = { __typename?: 'Query', nextStep?: string | null };

export type EvaluateStepQueryVariables = Exact<{
  session: Scalars['ID']['input'];
  question: Scalars['ID']['input'];
}>;


export type EvaluateStepQuery = { __typename?: 'Query', evaluateStep?: string | null };

export type AddPatientMutationVariables = Exact<{
  session: Scalars['ID']['input'];
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  birthdate?: InputMaybe<Scalars['Date']['input']>;
  gender?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  birthName?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  additionalAddressInfo?: InputMaybe<Scalars['String']['input']>;
}>;


export type AddPatientMutation = { __typename?: 'Mutation', addPatient?: string | null };

export type UpdatePatientMutationVariables = Exact<{
  patient: Scalars['ID']['input'];
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  birthdate?: InputMaybe<Scalars['Date']['input']>;
  gender?: InputMaybe<Scalars['String']['input']>;
}>;


export type UpdatePatientMutation = { __typename?: 'Mutation', updatePatients: { __typename?: 'UpdatePatientsMutationResponse', patients: Array<{ __typename?: 'Patient', id: string }> } };

export type SignInPatientMutationVariables = Exact<{
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type SignInPatientMutation = { __typename?: 'Mutation', signInPatient?: string | null };

export type SignUpPatientMutationVariables = Exact<{
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type SignUpPatientMutation = { __typename?: 'Mutation', signUpPatient?: string | null };

export type AuthPatientMutationVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type AuthPatientMutation = { __typename?: 'Mutation', authPatient?: string | null };

export type GetPatientSelectMenuChoiceQueryVariables = Exact<{
  field: Scalars['String']['input'];
  patientId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type GetPatientSelectMenuChoiceQuery = { __typename?: 'Query', answers: Array<{ __typename?: 'Answer', values: Array<string> }> };

export type GetPatientNameQueryVariables = Exact<{
  sessionId: Scalars['ID']['input'];
}>;


export type GetPatientNameQuery = { __typename?: 'Query', patients: Array<{ __typename?: 'Patient', firstName?: string | null }> };

export type IsEmailAlreadyTakenQueryVariables = Exact<{ [key: string]: never; }>;


export type IsEmailAlreadyTakenQuery = { __typename?: 'Query', isEmailAlreadyTaken: boolean };

export type GetQuestionnaireQueryVariables = Exact<{
  linkCode: Scalars['String']['input'];
}>;


export type GetQuestionnaireQuery = { __typename?: 'Query', workflowLinks: Array<{ __typename?: 'WorkflowLink', institution: { __typename?: 'Institution', id: string, name: string, operatingMode: OperatingMode, subscriptionPlan: SubscriptionPlan }, doctors: Array<{ __typename?: 'Doctor', id: string, firstName: string, lastName: string, speciality?: { __typename?: 'Speciality', name: string } | null, picture?: { __typename?: 'Document', url?: string | null } | null }>, workflow: { __typename?: 'Workflow', latest: { __typename?: 'VersionnedGraph', firstStepId: string } } }> };

export type GetQuestionnaireFromDeviceQueryVariables = Exact<{
  serial: Scalars['String']['input'];
}>;


export type GetQuestionnaireFromDeviceQuery = { __typename?: 'Query', devices: Array<{ __typename?: 'Device', institution: { __typename?: 'Institution', id: string, name: string, operatingMode: OperatingMode, subscriptionPlan: SubscriptionPlan }, doctors: Array<{ __typename?: 'Doctor', id: string, firstName: string, lastName: string, speciality?: { __typename?: 'Speciality', name: string } | null, picture?: { __typename?: 'Document', url?: string | null } | null }>, workflow: { __typename?: 'Workflow', latest: { __typename?: 'VersionnedGraph', firstStepId: string } } }> };

export type QuestionItemFragmentFragment = { __typename?: 'QuestionItem', label: string, medicalLabel?: string | null };

export type InterviewFragment = { __typename?: 'Questionnaire', id: string, name: string, latest: { __typename?: 'VersionnedGraph', firstStepId: string, isFirstStepOnCooldown: boolean } };

export type GetStepQueryVariables = Exact<{
  session: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
}>;


export type GetStepQuery = { __typename?: 'Query', isThirdPartySession?: boolean | null, questionnaireSteps: Array<{ __typename: 'CheckboxQuestion', hint?: string | null, field?: string | null, id: string, choices: Array<{ __typename?: 'QuestionItem', label: string, medicalLabel?: string | null }> } | { __typename: 'DateQuestion', hint?: string | null, field?: string | null, dateType?: DateFormatType | null, id: string } | { __typename: 'QuestionnaireAi', prompt: string, maxQuestions?: number | null, id: string } | { __typename: 'QuestionnaireAppointmentDate', id: string } | { __typename: 'QuestionnaireCondition', hint?: string | null, showToDoctor?: boolean | null, id: string } | { __typename: 'QuestionnaireDocument', id: string } | { __typename: 'QuestionnaireDocumentFiller', id: string } | { __typename: 'QuestionnaireIdentity', fields?: Array<IdentityField> | null, withAuthentication?: boolean | null, id: string } | { __typename: 'QuestionnaireInfoStep', text?: string | null, showReceiveByEmail?: boolean | null, id: string } | { __typename: 'QuestionnaireInterview', id: string, questionnaire?: { __typename?: 'Questionnaire', id: string, name: string, latest: { __typename?: 'VersionnedGraph', firstStepId: string, isFirstStepOnCooldown: boolean } } | null } | { __typename: 'QuestionnaireMenu', name?: string | null, id: string, choices: Array<{ __typename: 'QuestionnaireMenuItem', label: string, description?: string | null, icon: number, iconFontFamily: string, iconFontPackage: string }> } | { __typename: 'QuestionnaireRouter', id: string, routes: Array<{ __typename?: 'ConditionGroup', label?: string | null, order: ConditionLogic, conditions: Array<{ __typename?: 'Condition' } | { __typename?: 'ConditionGroup', conditions: Array<{ __typename?: 'Condition', var: string, comparator: ConditionComparison, value: string } | { __typename?: 'ConditionGroup' }> }> }> } | { __typename: 'QuestionnaireSelectMenu', field?: string | null, placeholder?: string | null, id: string, entries: Array<{ __typename?: 'QuestionnaireMenuEntry', keywords?: string | null, label: string, questionnaires: Array<{ __typename?: 'Questionnaire', id: string, name: string, latest: { __typename?: 'VersionnedGraph', firstStepId: string, isFirstStepOnCooldown: boolean } }> }> } | { __typename: 'QuestionnaireSetProperty', id: string } | { __typename: 'QuestionnaireSurvey', id: string } | { __typename: 'QuestionnaireThirdParty', id: string } | { __typename: 'QuestionnaireWelcomeStep', text?: string | null, id: string } | { __typename: 'RadioQuestion', hint?: string | null, field?: string | null, id: string, choices: Array<{ __typename?: 'QuestionItem', label: string, medicalLabel?: string | null }> } | { __typename: 'RangeQuestion', hint?: string | null, field?: string | null, min?: number | null, max?: number | null, id: string } | { __typename: 'SelectQuestion', hint?: string | null, field?: string | null, placeholder?: string | null, multiple?: boolean | null, id: string, choices: Array<{ __typename?: 'QuestionItem', label: string, medicalLabel?: string | null }> } | { __typename: 'TextQuestion', hint?: string | null, field?: string | null, placeholder?: string | null, id: string }> };

export type SyncMutationVariables = Exact<{
  serial: Scalars['String']['input'];
  institutionId: Scalars['ID']['input'];
  doctorIds: Array<Scalars['ID']['input']> | Scalars['ID']['input'];
  workflowId: Scalars['ID']['input'];
  deviceName: Scalars['String']['input'];
}>;


export type SyncMutation = { __typename?: 'Mutation', createDevices: { __typename?: 'CreateDevicesMutationResponse', devices: Array<{ __typename?: 'Device', serial: string }> } };
